
--- Start of AI_doc.html ---

<HTML>
<HEAD></HEAD>
<BODY>
<h3>Using AI objects in FlightGear</h3><hr>
<br><br>
Starting with FlightGear version 0.9.4 you can place AI objects in the "FlightGear world".
  In version 0.9.4 the AI objects can be defined in the <b><tt>preferences.xml</tt></b> file, or 
  in an airplane's <b><tt>*-set.xml</tt></b> file. In later versions of FlightGear they are 
  defined in a "scenario file" only.  Types of AI objects available are ships, airplanes, 
  thunderstorms, thermals, aircraft carriers, static and ballistic objects.
<BR><BR>  

AI objects have some things in common:  The have a location in the "FlightGear world", 
they can have an associated exterior 3D model, and they can move according to an internal 
FDM (flight dynamics model).  As of now, these objects are created at simulator start-up 
by adding some XML code to a scenario file. The scenario file must be in the 
<b><tt>data/Data/AI</tt></b> directory. You select which scenario file you want to use by naming 
it in the <b><tt>preferences.xml</tt></b> file.  (Note: As with everything in the 
<b><tt>preferences.xml</tt></b> file, the entries can be overridden by an aircraft's 
<b><tt>*-set.xml</tt></b> file, or at the command line.)  The <b><tt>preferences.xml</tt></b> 
file has an entry that looks like this (FlightGear versions newer than 0.9.4):
<BR><BR>

<b><tt>
  &#60;ai><br>
  &nbsp; &#60;enabled type="bool">true&#60;/enabled><br>
  &nbsp; &#60;scenario>demo_scenario&#60;/scenario><br>
  &#60;/ai><br>
</tt></b>
<BR><BR>

The scenario contains one entry for each AI object.  The entry specifies what kind of 
object to create, what it's initial conditions will be, and optionally (for aircraft and 
ships) a flight plan.
<BR><BR><BR>

<h3>Ships</h3><hr>
The entry to create a sailboat would look like this:
<br><br>

<b><tt>
  &#60;entry><br>
  &nbsp; &#60;type>ship&#60;/type><br>
  &nbsp; &#60;path>AI/Aircraft/sailboat1/sailboat.xml&#60;/path><br>
  &nbsp; &#60;speed type="double">12.0&#60;/speed><br>
  &nbsp; &#60;altitude type="double">0.0&#60;/altitude><br>
  &nbsp; &#60;longitude type="double">-122.33333&#60;/longitude><br>
  &nbsp; &#60;latitude type="double">37.61667&#60;/latitude><br>
  &nbsp; &#60;heading type="double">20.0&#60;/heading><br>
  &nbsp; &#60;rudder type="double">-3.0&#60;/rudder><br>
  &#60;/entry><br>
</tt></b>
<BR><BR>

Most of the entries are self-explanatory.  The "type" of object can be one of "aircraft", 
"ship", "storm", "thermal", "carrier", "static" or "ballistic".  The rest of the items 
give the AI object a model, a starting location, and a starting speed and direction.  You 
use the <b>&#60;path&#62;</b> item to give the object any valid exterior model. You can even 
make the ship look like an airplane if you want!  The "ship" type can also have a 
<b>&#60;rudder&#62;</b> value specified, which will cause the ship to move in a circle 
(HINT: use small values, five degrees or less, and right rudder is positive). 
<BR><BR>

<h3>Aircraft</h3><hr>
Here is an example of how to create an aircraft AI object:
<BR><BR>

<b><tt>
  &#60;!-- puts an A-4 north of KSFO, orbiting at 7000 ft  --><br>
  &#60;entry><br>
  &nbsp; &#60;type>aircraft&#60;/type><br>
  &nbsp; &#60;class>jet_fighter&#60;/class><br>
  &nbsp; &#60;path>Aircraft/a4/Models/a4-blue.xml&#60;/path><br>
  &nbsp; &#60;speed type="double">320.0&#60;/speed><br>
  &nbsp; &#60;altitude type="double">7000.0&#60;/altitude><br>
  &nbsp; &#60;longitude type="double">-122.6&#60;/longitude><br>
  &nbsp; &#60;latitude type="double">37.9&#60;/latitude><br>
  &nbsp; &#60;heading type="double">210.0&#60;/heading><br>
  &nbsp; &#60;roll type="double">-15.0&#60;/roll><br>
  &#60;/entry>
</tt></b>
<BR><BR>

It looks much the same as the ship AI code.  There are two differences, the 
<b>&#60;class&#62;</b> item and the <b>&#60;roll&#62;</b> item.  If the class is set to 
"tanker" the airplane will allow you to refuel if you can get close behind it (so far 
supported by JSBSim only)  The "roll" will cause the airplane to fly in a circle.  In the 
above example the A-4 will be orbiting to the left at 15 degrees of bank.  You can also 
create a ship or airplane with a flight plan.  In this case the object will follow the 
flight plan and then delete itself when it reaches the end, or (new since version 0.9.8) 
the object can be set to endlessly repeat a flight plan.  The flight plans are located in 
<b><tt>data/Data/AI/FlightPlans</tt></b>.  To create an airplane with a flightplan do this:
<BR><BR>

<b><tt>
  &#60;entry><br>
  &nbsp; &#60;type>aircraft&#60;/type><br>
  &nbsp; &#60;class>jet-transport&#60;/class><br>
  &nbsp; &#60;path>Aircraft/737/Models/737.xml&#60;/path><br>
  &nbsp; &#60;flightplan>KSFO_ILS28L.xml&#60;/flightplan><br>
  &#60;/entry><br>
</tt></b>
<BR><BR>


In this case you don't need to specify initial conditions because they are already defined 
in the flight plan.  The AI aircraft objects can be displayed on radar.  See the 
<b><tt>Aircraft/Instruments/radar.xml</tt></b> file for details.  

<BR><BR>
<h3>Thunderstorms</h3><hr>
<BR>
To make a thunderstorm, use this:
<BR><BR>

<b><tt>
  &#60;!-- puts a thunderstorm overhead OSI (Woodside VOR) --><br>
  &#60;entry><br>
  &nbsp; &#60;type>storm&#60;/type><br>
  &nbsp; &#60;path>Models/Geometry/thunderstorm.xml&#60;/path><br>
  &nbsp; &#60;speed type="double">20.0&#60;/speed><br>
  &nbsp; &#60;altitude type="double">4000.0&#60;/altitude><br>
  &nbsp; &#60;latitude type="double">37.3917&#60;/latitude><br>
  &nbsp; &#60;longitude type="double">-122.2817&#60;/longitude><br>
  &nbsp; &#60;heading type="double">90&#60;/heading><br>
  &#60;/entry><br>
</tt></b>
<BR><BR>

There's not much to it.  No, they don't turn :)  New since version 0.9.8 is the ability
to add lightning and turbulence to a thunderstorm.  For an example of this see the scenario 
file called "bigstorm_demo.xml".  The AI storm objects can be displayed on weather radar.  See the 
<b><tt>Aircraft/Instruments/wxradar.xml</tt></b> file for details.  

<br><br>
<h3>Thermals</h3><hr>
<BR>
To create a thermal, use this:
<BR><BR>

<b><tt>
 &#60;!-- puts a thermal over the control tower at KSFO --><br>
 &#60;entry><br>
 &nbsp; &#60;type>thermal&#60;/type><br>
 &nbsp; &#60;latitude type="double">37.61633&#60;/latitude><br>
 &nbsp; &#60;longitude type="double">-122.38334&#60;/longitude><br>
 &nbsp; &#60;strength-fps type="double">8.33&#60;/strength-fps><br>
 &nbsp; &#60;diameter-ft type="double">4000.0&#60;/diameter-ft><br>
 &nbsp; &#60;height-msl type="double">6000.0&#60;/height-msl><br>
 &#60;/entry><br>
</tt></b>
<BR><BR>

The AI thermals don't move, they are invisible, and they don't "lean" downwind.  
The <b>&#60;strength-fps&#62;</b> defines the maximum vertical velocity of the airmass 
at the center of the thermal.  The strength decreases to zero at the thermal's edge.  
<b>&#60;height-msl&#62;</b> defines the top of the thermal.
  

<br><br>
<h3>Ballistic objects</h3><hr>
<br>
A ballistic AI object starts with an initial location, azimuth, elevation and speed, then 
follows a ballistic path from there (with air resistance included).  Try this:
<BR><BR>

<b><tt>
  &#60;entry><br>
  &nbsp; &#60;type>ballistic&#60;/type><br>
  &nbsp; &#60;path>Models/Geometry/rocket.xml&#60;/path><br>
  &nbsp; &#60;speed type="double">500.0&#60;/speed><br>
  &nbsp; &#60;altitude type="double">50.0&#60;/altitude><br>
  &nbsp; &#60;longitude type="double">-122.39&#60;/longitude><br>
  &nbsp; &#60;latitude type="double">37.62&#60;/latitude><br>
  &nbsp; &#60;heading type="double">200.0&#60;/heading><br>
  &nbsp; &#60;azimuth type="double">70.0&#60;/azimuth><br>
  &nbsp; &#60;elevation type="double">45.0&#60;/elevation><br>
  &#60;/entry><br>
</tt></b>
<BR><BR>

There is not much call for rocket launches in FlightGear, but the ballistic AI object is
the basis for FlightGear's <a href="README.submodels">submodels</a> system.

<BR><BR><BR>
<h3>Aircraft Carriers</h3><hr>
<br>
The aircraft carrier AI object is based on the "ship" object but is much more complicated.  
See the scenario file called <b><tt>nimitz_demo.xml</tt></b> for details.
<BR><BR><BR>
<hr>
Dave Culp, updated 23 Oct 2005<br>
davidculp2@comcast.net
</BODY>
</HTML>
--- End of AI_doc.html ---


--- Start of FGShortRef.html ---

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>text</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<!-- html,1,info,frames,next,sections+ --> 
<meta name="src" content="FGShortRef.tex"> 
<link rel="stylesheet" type="text/css" href="FGShortRef.css"> 
</head><body 
id="tex4ht-main">
<!--l. 59--><p class="noindent" ><a 
 id="tex4ht-body"></a>
   <div  
class="centerline">                                            <span 
class="ptmbi7t-x-x-120">FlightGear </span><span 
class="ptmb7t-x-x-120">Short Reference</span>                                     </div>
<!--l. 61--><p class="noindent" ><span 
class="ptmbi7t-x-x-70">FlightGear </span><span 
class="ptmr7t-x-x-70">is a free flight simulator developed collectively over the Internet under the GPL. For more information see</span>
<a 
href="http://www.flightgear.org/" ><span 
class="ptmr7t-x-x-70">http://www.flightgear.org/</span></a><br 
class="newline" />
<!--l. 66--><p class="indent" ><!--tex4ht:inline--><div class="tabular"><table id="TBL-1" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-1-1g"><col 
id="TBL-1-1"><col 
id="TBL-1-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-1-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-1-1"  
class="td11"><span 
class="ptmb7t-x-x-70">Program Start:</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-1-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Linux/UNIX via fgfs under FlightGear/,                                                                                                                                             </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-2-1"  
class="td11">           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-1-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Mac OS X via FlightGear.app under /Applications/,                                                                                                                           </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-3-1"  
class="td11">           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-1-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Windows via the </span><span 
class="ptmbi7t-x-x-70">FlightGear </span><span 
class="ptmr7t-x-x-70">wizard fgrun.exe under </span><span 
class="cmsy-7">\</span><span 
class="ptmr7t-x-x-70">Program Files</span><span 
class="cmsy-7">\</span><span 
class="ptmr7t-x-x-70">FlightGear</span><span 
class="cmsy-7">\</span><span 
class="ptmr7t-x-x-70">bin</span><span 
class="cmsy-7">\</span><span 
class="ptmr7t-x-x-70">Win32</span><span 
class="cmsy-7">\               </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-4-1"  
class="td11"><span 
class="ptmb7t-x-x-70">Engine Start:    </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-1-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Set ignition switch to BOTH (&#8220;</span><span 
class="cmsy-7">}</span><span 
class="ptmr7t-x-x-70">&#8221; three times). Set mixture to 100%. Set throttle to about 25%. Operate starter using the &#8220;s&#8221; key.</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-5-1"  
class="td11">           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-1-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Once the engine has started, set throttle back to idle. Release parking brake (&#8220;B&#8221;), if applied.                                                          </span></td></tr></table>
</div>
<!--l. 81--><p class="noindent" ><span 
class="ptmb7t-x-x-70">Keyboard controls:</span>
   <div class="columns-2">
<!--l. 84--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 1: </span><span 
class="ptmri7t-x-x-70">Directional controls (activated </span><span 
class="pcrro7t-x-x-70">NumLock</span><span 
class="ptmr7t-x-x-70">)</span><br 
class="newline" />
<!--l. 87--><p class="noindent" >
   <div class="tabular"> <table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1"></colgroup><colgroup id="TBL-2-2g"><col 
id="TBL-2-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                     </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">9 / 3       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Throttle</span><a 
 id="dx3-2"></a>                                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">4 / 6 </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Aileron</span><a 
 id="dx3-3"></a></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-1"  
class="td11"><span 
class="ptmr7t-x-x-70">8 / 2       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Elevator</span><a 
 id="dx3-4"></a>                                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-1"  
class="td11"><span 
class="ptmr7t-x-x-70">0 / Enter</span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Rudder</span><a 
 id="dx3-5"></a></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-1"  
class="td11"><span 
class="ptmr7t-x-x-70">5            </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Center aileron/elevator/rudder</span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-1"  
class="td11"><span 
class="ptmr7t-x-x-70">7 / 1 </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Elevator trim</span><a 
 id="dx3-6"></a></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-1"  
class="td11">      </td> </tr></table></div>
<!--l. 92--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 2: </span><span 
class="ptmri7t-x-x-70">Engine controls</span>
<!--l. 96--><p class="noindent" >
   <div class="tabular"> <table id="TBL-3" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1"></colgroup><colgroup id="TBL-3-2g"><col 
id="TBL-3-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                                         </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">!        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Select 1st engine                                         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">@      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Select 2nd engine                                       </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-4-1"  
class="td11"><span 
class="ptmr7t-x-x-70">#        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Select 3rd engine                                        </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-5-1"  
class="td11"><span 
class="ptmr8c-x-x-70">$        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Select 4th engine                                        </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-6-1"  
class="td11"><span 
class="cmsy-7">~  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Select all engines                                        </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-7-1"  
class="td11"><span 
class="cmsy-7">{  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Decrease magneto on selected engine        </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-8-1"  
class="td11"><span 
class="cmsy-7">}  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-8-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Increase magneto on selected engine         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-9-1"  
class="td11"><span 
class="ptmr7t-x-x-70">s        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-9-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Fire starter on selected engine(s)                </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-10-1"  
class="td11"><span 
class="ptmr7t-x-x-70">M / m</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-10-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Lean/Enrich selected engine mixture         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-11-1"  
class="td11"><span 
class="ptmr7t-x-x-70">N / n  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-11-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Decrease/Increase selected propeller RPM</span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-12-1"  
class="td11">    </td> </tr></table></div>
<!--l. 101--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 3: </span><span 
class="ptmri7t-x-x-70">Miscellaneous aircraft controls</span>
<!--l. 105--><p class="noindent" >
   <div class="tabular"> <table id="TBL-4" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-4-1g"><col 
id="TBL-4-1"></colgroup><colgroup id="TBL-4-2g"><col 
id="TBL-4-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key   </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                       </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">b        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Apply all brakes</span><a 
 id="dx3-7"></a>                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">, / .     </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Apply left/right brake               </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-4-1"  
class="td11">    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">(useful for differential braking</span><a 
 id="dx3-8"></a><span 
class="ptmr7t-x-x-70">)</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-5-1"  
class="td11"><span 
class="ptmr7t-x-x-70">l         </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle tail-wheel lock</span><a 
 id="dx3-9"></a>              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-6-1"  
class="td11"><span 
class="ptmr7t-x-x-70">B        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle parking brake</span> <a 
 id="dx3-10"></a><a 
 id="dx3-11"></a>               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-7-1"  
class="td11"><span 
class="ptmr7t-x-x-70">g/G    </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Raise/lower landing gear</span><a 
 id="dx3-12"></a><a 
 id="dx3-13"></a>          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-8-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Space </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-8-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Push To Talk (PTT)                  </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-9-1"  
class="td11"><span 
class="ptmr7t-x-x-70">- / </span><span 
class="ptmr7t-x-x-70">_    </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-9-2"  
class="td11"><span 
class="ptmr7t-x-x-70">MP text chat menu/entry          </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-10-1"  
class="td11"><span 
class="cmr-7">[ </span><span 
class="ptmr7t-x-x-70">/ </span><span 
class="cmr-7">]   </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-10-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Retract/extend flaps</span><a 
 id="dx3-14"></a>                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-11-1"  
class="td11"><span 
class="ptmr7t-x-x-70">j / k    </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-11-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Retract/extend spoilers</span><a 
 id="dx3-15"></a>             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-12-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-B</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-12-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle speed brakes</span><a 
 id="dx3-16"></a>                 </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-13-1"  
class="td11">    </td> </tr></table></div>
<!--l. 111--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 4: </span><span 
class="ptmri7t-x-x-70">General simulator controls</span>
<!--l. 115--><p class="noindent" >
   <div class="tabular"> <table id="TBL-5" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1"></colgroup><colgroup id="TBL-5-2g"><col 
id="TBL-5-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key   </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                        </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">p        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Pause simulator</span> <a 
 id="dx3-17"></a>                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">a / A  </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Simulation speed up/slow down</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-1"  
class="td11"><span 
class="ptmr7t-x-x-70">t / T    </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Clock speed up/slow down        </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-R</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Instant replay                             </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-1"  
class="td11"><span 
class="ptmr7t-x-x-70">F3      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Save screen shot                         </span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-1"  
class="td11"><span 
class="ptmr7t-x-x-70">ESC </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Exit program</span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-1"  
class="td11">    </td> </tr></table></div>
<!--l. 120--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 5: </span><span 
class="ptmri7t-x-x-70">View controls (de-activated </span><span 
class="pcrro7t-x-x-70">NumLock</span><span 
class="ptmri7t-x-x-70">)</span>
<!--l. 124--><p class="noindent" >
   <div class="tabular"> <table id="TBL-6" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1"></colgroup><colgroup id="TBL-6-2g"><col 
id="TBL-6-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Numpad Key</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">View direction</span><a 
 id="dx3-18"></a></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-2-1"  
class="td11">  <span 
class="ptmr7t-x-x-70">Shift-8      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Forward          </span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-3-1"  
class="td11"> <span 
class="ptmr7t-x-x-70">Shift-7 </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Left/forward</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-4-1"  
class="td11">  <span 
class="ptmr7t-x-x-70">Shift-4      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Left                 </span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-5-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-5-1"  
class="td11"> <span 
class="ptmr7t-x-x-70">Shift-1 </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-6-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Left/back</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-6-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-6-1"  
class="td11">  <span 
class="ptmr7t-x-x-70">Shift-2      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Back               </span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-7-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-7-1"  
class="td11"> <span 
class="ptmr7t-x-x-70">Shift-3 </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-6-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Right/back</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-8-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-8-1"  
class="td11">  <span 
class="ptmr7t-x-x-70">Shift-6      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-8-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Right               </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-9-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-9-1"  
class="td11">  <span 
class="ptmr7t-x-x-70">Shift-9      </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-9-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Right/forward </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-10-"><td  style="white-space:nowrap; text-align:center;" id="TBL-6-10-1"  
class="td11">         </td> </tr></table></div>
<!--l. 132--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 6: </span><span 
class="ptmri7t-x-x-70">Autopilot controls</span>
<!--l. 136--><p class="noindent" >
                                                                     

                                                                     
   <div class="tabular"> <table id="TBL-7" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1"></colgroup><colgroup id="TBL-7-2g"><col 
id="TBL-7-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key          </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                                        </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Backspace</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle autopilot                                         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-A       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle altitude lock</span> <a 
 id="dx3-19"></a>                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-G       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle glide slope lock (NAV 1)               </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-H       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle heading hold</span><a 
 id="dx3-20"></a>                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-N       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle NAV 1 lock                                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-S       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle autothrottle</span><a 
 id="dx3-21"></a>                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-T       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle terrain follow (AGL) lock             </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-9-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-U       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-9-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Add 1000 ft. to your altitude (emergency)</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-10-1"  
class="td11"><span 
class="ptmr7t-x-x-70">F6             </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-10-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle autopilot heading mode                 </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-11-1"  
class="td11"><span 
class="ptmr7t-x-x-70">F11           </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-11-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Autopilot altitude dialog                            </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-12-1"  
class="td11"><span 
class="ptmr7t-x-x-70">8 / 2          </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-12-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Altitude adjust                                           </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-13-1"  
class="td11"><span 
class="ptmr7t-x-x-70">4 / 6          </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-13-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Heading adjust                                           </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-14-1"  
class="td11"><span 
class="ptmr7t-x-x-70">9 / 3          </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-14-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Autothrottle adjust                                     </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-15-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-15-1"  
class="td11">       </td> </tr></table></div>
<!--l. 141--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Table 7: </span><span 
class="ptmri7t-x-x-70">Display controls</span>
<!--l. 145--><p class="noindent" >
   <div class="tabular"> <table id="TBL-8" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1"></colgroup><colgroup id="TBL-8-2g"><col 
id="TBL-8-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Key        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Action                                                            </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-1"  
class="td11"><span 
class="ptmr7t-x-x-70">P             </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle instrument panel</span><a 
 id="dx3-22"></a> <span 
class="ptmr7t-x-x-70">on/off                      </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-1"  
class="td11"><span 
class="ptmr7t-x-x-70">c              </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle3D/2D cockpit</span> <a 
 id="dx3-23"></a><span 
class="ptmr7t-x-x-70">(if both are available)</span> <a 
 id="dx3-24"></a><a 
 id="dx3-25"></a></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-1"  
class="td11"><span 
class="ptmr7t-x-x-70">S             </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Cycle panel style full/mini                            </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-5-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-C     </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-5-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle panel/cockpit hotspot visibility         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-6-1"  
class="td11"><span 
class="ptmr7t-x-x-70">h             </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-6-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle HUD                                                  </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-7-1"  
class="td11"><span 
class="ptmr7t-x-x-70">H            </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-7-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Change HUD brightness                                </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-8-1"  
class="td11"><span 
class="ptmr7t-x-x-70">i / I          </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-8-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Minimize/maximize HUD                             </span></td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-9-1"  
class="td11"><span 
class="ptmr7t-x-x-70">x / X </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-8-9-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Zoom in/out</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-10-1"  
class="td11"><span 
class="ptmr7t-x-x-70">v / V       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-10-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Cycle view modes</span><a 
 id="dx3-26"></a> <span 
class="ptmr7t-x-x-70">forth and back                 </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-11-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Ctrl-V     </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-11-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Reset view modes</span><a 
 id="dx3-27"></a> <span 
class="ptmr7t-x-x-70">to pilot view                     </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-12-1"  
class="td11"><span 
class="ptmr7t-x-x-70">z / Z        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-12-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Increase/Decrease visibility (fog)                  </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-13-1"  
class="td11"><span 
class="ptmr7t-x-x-70">F10         </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-13-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle menu on/off                                       </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-14-1"  
class="td11"><span 
class="ptmr7t-x-x-70">Shift-F10</span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-14-2"  
class="td11"><span 
class="ptmr7t-x-x-70">Toggle fullscreen mode on/off                       </span></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-15-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-15-1"  
class="td11">      </td> </tr></table></div>
   </div>
<!--l. 151--><p class="noindent" ><span 
class="ptmb7t-x-x-70">Mouse controlled functions: </span><span 
class="ptmr7t-x-x-70">There are three mouse modes, which can be swapped between by using the Tab key on your</span>
<span 
class="ptmr7t-x-x-70">keyboard.</span>
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x3-29x1"><span 
class="ptmr7t-x-x-70">In </span><span 
class="ptmb7t-x-x-70">normal </span><span 
class="ptmr7t-x-x-70">mode (pointer cursor), the panel and cockpit controls can be operated using the mouse. To change a control,</span>
     <span 
class="ptmr7t-x-x-70">click with the left/middle mouse button on the corresponding knob/lever. Generally, the left side of the control decreases</span>
     <span 
class="ptmr7t-x-x-70">the setting, while the right side increases the setting. The left mouse button makes small changes while the middle button</span>
     <span 
class="ptmr7t-x-x-70">makes larger ones. Some controls can also be manipulated by holding down the left mouse button and dragging them, or</span>
     <span 
class="ptmr7t-x-x-70">by using the mouse scrollwheel. You can change the view direction by holding down the right mouse button and moving</span>
     <span 
class="ptmr7t-x-x-70">your mouse. Press Ctrl-c to view panel/cockpit hotspots.</span>
     </li>
     <li 
  class="enumerate" id="x3-31x2"><span 
class="ptmr7t-x-x-70">In </span><span 
class="ptmb7t-x-x-70">control </span><span 
class="ptmr7t-x-x-70">mode (cross hair cursor), the mouse is used to directly control the aircraft in the absence of a joystick. Moving</span>
     <span 
class="ptmr7t-x-x-70">the mouse controls the aileron (left/right) and elevator (forwards/backwards). Holding the left mouse button down allows</span>
     <span 
class="ptmr7t-x-x-70">control of the rudder (left/right), while holding the middle mouse button controls throttle (forwards/backwards). The</span>
     <span 
class="ptmr7t-x-x-70">scrollwheel controls elevator trim. Using auto-coordination (</span><span 
class="pcrr7t-x-x-70">--enable-auto-coordination</span><span 
class="ptmr7t-x-x-70">) is recommended.</span>
     <span 
class="ptmr7t-x-x-70">You can change the view direction by holding down the right mouse button and moving your mouse.</span>
     </li>
     <li 
  class="enumerate" id="x3-33x3"><span 
class="ptmr7t-x-x-70">In </span><span 
class="ptmb7t-x-x-70">view </span><span 
class="ptmr7t-x-x-70">mode (arrow cursor), you can control the view direction using the mouse. Clicking the left mouse button resets</span>
     <span 
class="ptmr7t-x-x-70">the view direction. Holding the middle button down while moving the mouse shifts the viewpoint. The scrollwheel may</span>
     <span 
class="ptmr7t-x-x-70">be used to control the field of view.</span>
     </li></ol>
<!--l. 179--><p class="noindent" ><span 
class="ptmr7t-x-x-70">Short Reference by M. Basler, S. Buchanan for </span><span 
class="ptmbi7t-x-x-70">FlightGear </span><span 
class="ptmr7t-x-x-70">2020.3.0.</span><br 
class="newline" /><span 
class="ptmr7t-x-x-70">Published under the GPL (</span><a 
href="http://www.gnu.org/copyleft/gpl.html" ><span 
class="ptmr7t-x-x-70">http://www.gnu.org/copyleft/gpl.html</span></a><span 
class="ptmr7t-x-x-70">)</span>
                                                                     

                                                                     
    
</body></html> 

--- End of FGShortRef.html ---


--- Start of Goldhofert.xml ---

<?xml version="1.0" encoding="UTF-8"?>


<!-- SETTINGS -->

<!DOCTYPE PropertyList [
 <!-- Property defining whether the pushback is connected. -->
 <!ENTITY CONNECTED-PROP "sim/model/autopush/connected">
 <!-- Property for aircraft's front wheel rollspeed in m/s. -->
 <!ENTITY ROLLSPEED-PROP "gear/gear[0]/rollspeed-ms">
 <!-- Property for front wheel steering. -->
 <!ENTITY YAW-PROP "sim/model/autopush/yaw">
 <!-- Scaling factor for the steering property, must be equal to /sim/model/autopush/yaw-mult. -->
 <!ENTITY YAW-MULT "60.0">
 <!-- Property for gear compression in ft. -->
 <!ENTITY COMPRESSION-PROP "gear/gear[0]/compression-ft">
 <!-- Property for aircraft pitch in degrees, or pushback's pitch if it is variable. -->
 <!ENTITY PITCH-PROP "orientation/pitch-deg">
 <!-- Scaling factor for the pitch property. -->
 <!ENTITY PITCH-FACTOR "0.0">
 <!-- Pitch offset, must be equal to /sim/model/autopush/pitch-deg. If pitch is variable, must be "0.0". -->
 <!ENTITY PITCH-OFFSET "-7.0">
]>


<!--

AUTOPUSH

Copyright (c) 2018 Autopush authors:
 Michael Danilov <mike.d.ft402 -eh- gmail.com>
 Joshua Davidson http://github.com/Octal450
 Merspieler http://github.com/merspieler
Original code (c) FlightGear
Distribute under the terms of GPLv2.

-->


<PropertyList>
  <path>Models/Airport/Pushback/Goldhofert.ac</path>

  <!-- Trucks models and artworks courtesy of XPGoodWay Team
(http://www.xpgoodwayteam.org/site_xpushback/) -->

  <model>
    <path>Models/Airport/Pushback/Goldhofert-warning-light.xml</path>
    <offsets>
      <x-m>-2.908</x-m>
      <y-m>0.260</y-m>
      <z-m>1.326</z-m>
      <heading-deg>0</heading-deg>
    </offsets>
  </model>

  <model>
    <path>Models/Airport/Pushback/Goldhofert-warning-light.xml</path>
    <offsets>
      <x-m>-1.781</x-m>
      <y-m>0.260</y-m>
      <z-m>1.326</z-m>
      <heading-deg>90</heading-deg>
    </offsets>
  </model>

 <animation>
   <type>spin</type>
   <object-name>wheelfl</object-name>
   <object-name>wheelfr</object-name>
   <property>&ROLLSPEED-PROP;</property>
   <factor>-16.3</factor>
   <center>
     <x-m>-2.8976</x-m>
     <y-m>0</y-m>
     <z-m>0.5809</z-m>
   </center>
   <axis>
     <x>0</x>
     <y>1</y>
     <z>0</z>
   </axis>
 </animation>

 <animation>
   <type>spin</type>
   <object-name>wheelrl</object-name>
   <object-name>wheelrr</object-name>
   <property>&ROLLSPEED-PROP;</property>
   <factor>-16.3</factor>
   <center>
     <x-m>2.0501</x-m>
     <y-m>0</y-m>
     <z-m>0.5735</z-m>
   </center>
   <axis>
     <x>0</x>
     <y>1</y>
     <z>0</z>
   </axis>
 </animation>

 <animation>
   <type>select</type>
   <condition>
     <property>&CONNECTED-PROP;</property>
   </condition>
 </animation>

 <animation>
   <type>rotate</type>
   <property>&YAW-PROP;</property>
   <factor>&YAW-MULT;</factor>
   <center>
     <x-m>0</x-m>
     <y-m>0</y-m>
     <z-m>0</z-m>
   </center>
   <axis>
     <x>0</x>
     <y>0</y>
     <z>-1</z>
   </axis>
 </animation>

 <animation>
   <type>translate</type>
   <property>&COMPRESSION-PROP;</property>
   <factor>0.3048</factor>
   <axis>
     <x>0</x>
     <y>0</y>
     <z>1</z>
   </axis>
 </animation>

 <animation>
   <type>rotate</type>
   <property>&PITCH-PROP;</property>
   <factor>&PITCH-FACTOR;</factor>
   <offset-deg>&PITCH-OFFSET;</offset-deg>
   <center>
     <x-m>0</x-m>
     <y-m>0</y-m>
     <z-m>0</z-m>
   </center>
   <axis>
     <x>0</x>
     <y>1</y>
     <z>0</z>
   </axis>
 </animation>
</PropertyList>

--- End of Goldhofert.xml ---


--- Start of README ---

FGShortRef.pdf describes the key bindings and has a
nice short description of controls for FGFS.

The HTML documentation is a copy of the official 
manual. If you would like a nicely printed copy
it is available in PDF form at the the FGFS website

http://flightgear.org/Docs/InstallGuide/getstart.pdf




--- End of README ---


--- Start of README.3DClouds ---

Configuring 3D Clouds
=====================

3D clouds can be created in two ways:
- By placing individual clouds using a command (e.g. from Nasal)
- Using the global weather function, which reads cloud definition from
  an XML file.

Placing Clouds Individually
===========================

Clouds are created using the "add-cloud" command, passing a property
node defining the location and characterstics of the cloud.

Location is defined by the following properties:

<layer>      - The cloud layer number to add the cloud to. (default 0)
<index>      - A unique identifier for the cloud in the layer. If a cloud
               already exists with this index, the new cloud will not be
               created, and 0 is returned.
<lon-deg>    - Longitude to place the cloud, in degrees (default 0)
<lat-deg>    - Latitude t place the cloud, in degrees (default 0)
<alt-ft>     - Altitude to place the cloud, relative to the layer (!) in ft
               (default 0)
<x-offset-m> - Offset in m from the lon-deg. +ve is south (default 0)
<y-offset-m> - Offset in m from the lat-deg. +ve is east (default 0)

The cloud itself is built up of a number of "sprites" - simple 2D textures
that are always rotated to be facing the viewer. These sprites are handled
by a OpenGL Shader - a small program that is run on your graphics card.

The cloud is defined by the following properties:

<min-cloud-width-m>   - minimum width of the cloud in meters (default 500)
<max-cloud-width-m>   - maximum width of the cloud (default min-cloud-width-m*1.5)
<min-cloud-height-m>  - minimum height of the cloud (default 400)
<max-cloud-height-m>  - maximum height of the cloud (default min-cloud-height-m*1.5)
<texture>             - texture file of sprites to use (default cl_cumulus.png)
<num-textures-x>      - number of cloud textures defined horizontally in the
                        texture file (default 4)
<num-textures-y>      - number of cloud textures defined vertically in the
                        texture file (default 4)
<height-map-texture>  - whether to choose the vertical texture index based on
                        sprite height within the clouds (default false)
<num-sprites>         - Number of sprite to generate for the cloud (default 20)
<min-sprite-width-m>  - minimum width of the sprites used to create the cloud
                        (default 200)
<max-sprite-width-m>  - maximum width of the sprites used to create the cloud
                        (default min-sprite-width-m*1.5)
<min-sprite-height-m> - minimum height of the spites used to create the cloud
                        (default 150)
<max-sprite-height-m> - maximum height of the sprites used to create the cloud
                        (default min-sprite-height-m*1.5)
<z-scale>             - vertical scaling factor to apply to to the sprite after
                        billboarding. A small value would create a sprite that
                        looks squashed when viewed from the side. (default 1.0)
<min-bottom-lighting-factor> - See Shading below (default 1.0)
<max-bottom-lighting-factor> - See Shading below (default min-...-factor + 0.1)
<min-middle-lighting-factor> - See Shading below (default 1.0)
<max-middle-lighting-factor> - See Shading below (default min-...-factor + 0.1)
<min-top-lighting-factor>    - See Shading below (default 1.0)
<max-top-lighting-factor>    - See Shading below (default min-...-factor + 0.1)
<min-shade-lighting-factor>  - See Shading below (default 0.5)
<max-shade-lighting-factor>  - See Shading below (default min-...-factor + 0.1)
                                                
Shading
-------

the [min|max]-...-lighting-factor properties allow you to define diffuse lighting 
multipliers to the bottom, middle, top, sunny and shaded parts of the cloud. In 
each case, individual clouds will have a random multiplier between the min and 
max values used to allow for some variation between individual clouds.

The top, middle and bottom lighting factors are applied based on the pixels vertical 
positon in the cloud. A linear interpolation is used either between top/middle (if
the pixel is above the middle of the cloud) or middle/bottom (if the pixel is below
the middle of the cloud). 

The top factor is also applied to _all_ pixels on the sunny side of the cloud. The
shade factor is applied based on the pixel position away from the sun, linearly
interpolated from top to shade. E.g this is not a straight linear interpolation
from top to shade across the entire cloud.

The final lighting factor is determined by the minimum of the vertical factor and
the sunny/shade factor. Note that this is applied to the individual pixels, not
sprites.

Textures
--------

The texture to use for the sprites is defined in the <texture> tag.
To allow some variation, you can create a texture file containing multiple
sprites in a grid, and define the <num-textures-x/y> tags. The code
decides which texture to use for a given sprite : randomly in the x-direction
and based on the altitude of the sprite within the cloud in the y-direction
if <height-map-texture> is set. Therefore, you should put sprite textures 
you want to use for the bottom of your cloud at the bottom of the texture 
file, and those you want to use for the top of the cloud at the top of the 
texture file.

For example, the following Nasal snippet will create a cloud immediately above the
aircraft at an altitude of 1000 ft above /environment/clouds/layer[0]/elevation-ft :

var p = props.Node.new({ "layer" : 0,
                         "index": 1,
                         "lat-deg": getprop("/position/latitude-deg"),
                         "lon-deg": getprop("/position/longitude-deg"),
                         "alt-ft" : 1000 });
fgcommand("add-cloud", p);

Moving Individual Clouds
========================

Clouds may be moved by using the "move-cloud" command. This takes the following
property arguments.

<layer>      - The cloud layer number containing the cloud to move. (default 0)
<index>      - The unique identifier of the cloud to move.
<lon-deg>    - Longitude to place the cloud, in degrees (default 0)
<lat-deg>    - Latitude t place the cloud, in degrees (default 0)
<alt-ft>     - Altitude to place the cloud, relative to the layer (!) in ft
               (default 0)
<x-offset-m> - Offset in m from the lon-deg. +ve is south (default 0)
<y-offset-m> - Offset in m from the lat-deg. +ve is east (default 0)

Deleting Individual Clouds
===========================

Clouds may be deleted by using the "del-cloud" command. This takes the following
property arguments.

<layer>      - The cloud layer number containing the cloud to delete. (default 0)
<index>      - The unique identifier of the cloud to delete.

Global 3D Clouds
================

The global weather system uses sets of clouds defined in 
FG_ROOT/Environment/cloudlayers.xml

The file has 3 distinct sections: layers, cloud boxes and clouds,
described below.

Notes for those editing clouds:
- All distances are in m. Note that this is in contrast to cloud heights
  in METAR etc. which are in ft.
- The XML file is loaded into the properties system, so you can modify
  the settings in-sim, and see the results by re-generating the cloud
  layer. The simplest way to do this is to disable METAR, and control
  the cloud layers using the Clouds dialog, and in particular the coverage.
- Texture files are in .png format, and have a transparent background.
  To make the textures easier to edit, create a black layer behind them,
  so there is some contrast between the background and the white cloud.
  Having a grid based on the texture dimensions also helps, so you don't
  bleed over the edges, which causes ugly sharp horizontal and vertical
  lines.

Clouds
======

The cloud definitions are as described above for placing individual
clouds, but no position information is used (this is defined in the
cloud box and layers below).

Cloud Boxes
===========

The <boxes> section contains definitions of groups of cloads,for example
an entire towering CB mass.

The <boxes> section contains a number of named types, which are referenced
by the <layers> section, described below. Therefore, the names used are
completely user-defined.

Each of the named section consists of one or more <box> section,
defining a particular cloud type

Each <box> section contains the following tags:

<type>   - The cloud to use, defined above
<count>  - The number of clouds to generate (+/- 50%)
<width>  - The x and y within which these clouds should be generated
<height> - The height within which the clouds should be generated
<hdist>  - The horizontal distribution of the clouds within the area.
           Equates to a sum of random distributions. Defaults to 1.
           1 = even distribution, 2 = distributed towards the center.
           3 = very strongly distributed towards the center.
<vdist>  - The vertical distribution of the clouds. As for hdist.


If the  /sim/rendering/clouds3d-density is less than 1.0 (100%), then a
proportional number of clouds will be displayed.

The following example shows a stratus cloud group, which consists of 5
st-large clouds and 5 st-small clouds, distributed in a box 2000mx2000m,
and 100m high, evenly distributed.

    <st>
      <box>
        <type>st-large</type>
        <count>5</count>
        <width>2000</width>
        <height>100</height>
      </box>
      <box>
        <type>st-small</type>
        <count>5</count>
        <width>2000</width>
        <height>100</height>
      </box>
    </st>


Layers
======

The <layers> section contains definitions for a specific layer type.
The layer type is derived from the METAR/Weather settings by FG itself.

Each layer type is a named XML tag, i.e.: ns, sc, st, ac, cb, cu.
If a layer type is not defined, then a 2D layer is used instead.

The layer type contains one or more <cloud> definitions. This
defines a type of cloud box, and a weighting for that type (<count>).

For example, the following XML fragment will produce 3 "cb" cloud boxes
for every 1 "cu":

<cloud>
    <name>cb</name>
    <count>3</count>
</cloud>
<cloud>
    <name>cu</name>
    <count>1</count>
</cloud>

Clouds are randomly distributed across the sky in the x/y plane, but the
height of them is set by the weather conditions, with a random height range
applied, defined by <grid-z-rand>

--- End of README.3DClouds ---


--- Start of README.IO ---

This document describes how to invoke FlightGear's generic IO subsystem.

FlightGear has a fairly flexible generic IO subsystem that allows you
to "speak" any supported protocol over any supported medium.  The IO
options are configured at runtime via command line options.  You can
specify multiple entries if you like, one per command line option.


The general form of the command line option is as follows:

    --protocol=medium,direction,hz,medium_options,...

    protocol = { native, nmea, garmin, fgfs, rul, pve, ray, etc. }
    medium = { serial, socket, file, etc. }
    direction = { in, out, bi }
    hz = number of times to process channel per second (floating
         point values are ok.


Generic Communication:

    --generic=params

    With this option it is possible to output a pre-configured
    ASCII string or binary sequence  using a predefined separator.
    The configuration is defined in an XML file located in the
    Protocol directory of the base package.

    params can be:
    serial port communication:    serial,dir,hz,device,baud,protocol
    socket communication:         socket,dir,hz,machine,port,style,protocol
    i/o to a file:                file,dir,hz,filename,protocol

    See README.protocol for how to define a generic protocol.


Serial Port Communication:

    --nmea=serial,dir,hz,device,baud

    device = OS device name of serial line to be open()'ed
    baud = {300, 1200, 2400, ..., 230400}

    example to pretend we are a real gps and output to a moving map application:

    --nmea=serial,out,0.5,COM1,4800

    Note that for unix variants you might use a device name like "/dev/ttyS0"


Socket Communication:

    --native=socket,dir,hz,machine,port,style

    machine = machine name or ip address if client (leave empty if server)
    port = port, leave empty to let system choose
    style = tcp or udp

    example to slave one copy of fgfs to another

    fgfs1:  --native=socket,out,30,fgfs2,5500,udp
    fgfs2:  --native=socket,in,30,,5500,udp --fdm=external

    This instructs the first copy of fgfs to send UDP packets in the
    native format to a machine called fgfs2 on port 5500.

    The second copy of fgfs will accept UDP packets (from anywhere) on
    port 5500.  Note the additional --fdm=external option.  This tells
    the second copy of fgfs to not run the normal flight model, but
    instead set the FDM values based on an external source (the
    network in this case.)


File I/O:

    --garmin=file,dir,hz,filename

    filename = file system file name

    example to record a flight path at 10 hz:

    --native=file,out,10,flight1.fgfs

    example to replay your flight

    --native=file,in,10,flight1.fgfs --fdm=external

    You can make the replay from a file loop back to the beginning
    when it reaches the end of the file with the "repeat" flag:

    --generic=file,in,20,flight.out,playback,repeat

    With a numeric argument, FlightGear will exit after that number of repeats.
    --generic=file,in,20,flight.out,playback,repeat,5


Moving Map Example:

    Per Liedman has developed a moving map program called Atlas
    (atlas.sourceforge.net) The initial inspiration and much code came
    from Alexei Novikov.

    The moving map supports NMEA format input either via network or
    via serial port.  Either way will work, but this example
    demonstrates the use of a socket connection.

    Start up fgfs with:

        fgfs --nmea=socket,out,0.5,atas-host-name,5500,udp

    Start up the Atlas program with:

        Atlas --udp=5500 --fgroot=path-to-fg-root --glutfonts

    Once both programs are running, the Atlas program should display
    your current location.  Atlas is a really nifty program with many
    neat options such as the ability to generate and use background
    bitmaps that show the terrain, cities, lakes, oceans, rivers, etc.


HTTP Server Example

    You can now interact with a running copy of FlightGear using your
    web browser.  You can view all the key internal variables and even
    change the ones that are writable.  If you have support in your
    favorite [scripting] language for interacting with an http server,
    you should be able to use this as a mechanism to interface your
    script with FlightGear.

    Start up fgfs with the --httpd=<port#> option:

    For example:

        fgfs --httpd=5500

    Now point your web browser to:

        http://host.domain.name:5500/

    When a value is displayed, you can click on it to bring up a form
    to assign it a new value.


ACMS flight data recorder playback

  fgfs --fdm=acms --generic=file,in,1,<path_to_replay_file>,acms


--- End of README.IO ---


--- Start of README.JSBsim ---

JSBSim

JSBSim is an ongoing attempt at producing an OO Flight Dynamics Model
(FDM) to replace LaRCsim as the default FDM for FlightGear. It can
also be used standalone.

JSBSim uses config files to represent aircraft, engines, propellers,
etc. Also, the flight control system is described in the config
file. Normally, for use with FlightGear, the config files are named
this way [case is significant]:

<FG_ROOT>/Aircraft/<aircraft name>/<aircraft name>.xml

Engines are named like this:

<FG_ROOT>/Engines/<engine name>.xml

Aircraft and engine config files are present in the FGFS Base package
which must be downloaded. See the FlightGear web site for more
information.

How to run FGFS using JSBSim

All the various FDMs are currently compiled into FGFS. You can specify
which FDM you want at run time. You can also specify which aircraft
you want. Currently, for JSBSim only the X-15 and C-172 aircraft are
available. Here is an example command line used to start up FlightGear
using JSBSim as the FDM:

fgfs --fdm=jsb --aircraft=X15 --units-feet --altitude=60000 --uBody=2000 --wBody=120

or,

fgfs --fdm=jsb --aircraft=c172

[Note: uBody is the forward velocity of the aircraft, wBody is the
downward velocity - from the aircraft point of view. This essentially
means that the aircraft is going forward fast and has an angle of
attack of about 4 degrees or so]

The first command line sets up the initial velocity and altitude to
allow the X15 to glide down. Note that if you fire up the engine, it
will burn for only about two minutes and then run out of fuel - but
you will go very, very fast! The second command line example will
start up the C172 on the end of the runway.

Check out the JSBSim home page at http://jsbsim.sf.net. Please report
any bugs to jsb@hal-pc.org, or apeden@earthlink.net, or post on the
jsbsim web site using the SourceForge bug tracking system for the
project.

JSBSim is written by Jon S. Berndt and Tony Peden with contributions
by other FlightGear programmers, as well.

--- End of README.JSBsim ---


--- Start of README.Joystick ---

Replaced by Docs/README.Joystick.html in the base package.

--- End of README.Joystick ---


--- Start of README.Joystick.html ---

<HTML>
<HEAD>
<TITLE>Users Guide to FGInput - Joystick And Keyboard Bindings For FlightGear</TITLE>
</HEAD>

<body>

<H1>Users Guide to FGInput - Joystick And Keyboard Bindings For FlightGear</H1>
Or The document formerly know as 
<H2>The Users Guide to Joystick Usage Under FlightGear Flight Simulator"</H2>

<cite>
version 0.9.8.1 13/10/2005
Author John Check
</cite>

<ol>
 <li><A HREF="#history">Some History</A>
 <li><A HREF="#first_things">First Things First</A>
 <li><A HREF="#xml">About XML</A>
 <li><A HREF="#output">Determining Your Joystick Output</A>
 <li><A HREF="#default">Default Joystick Properties</A>
 <li><A HREF="#okay">Okay, Now What?</A>
 <li><A HREF="#modifiers">Modifiers For Raw Joystick Values</A>
 <li><A HREF="#command_manager">The Command Manager</A>
 <li><A HREF="#bindings">Bindings</A>
 <li><A HREF="#axes">Joystick Axes</A>
 <li><A HREF="#buttons">Button Properties</A>
 <li><A HREF="#coolie_hat">Digital Coolie Hats</A>
 <li><A HREF="#keyboard">Keyboard Bindings</A>
</ol>

<p>
This document is written with versions of FlightGear 0.7.7 and greater
in mind. It assumes a working joystick present on your system. It
is written from the perspective a Linux user, but the information presented
is valid on other platforms. 
</p>
<p>
Thanks to David Megginson, who aside from actually implementing FGFS XML
features, lets me rip off his descriptions of how stuff works so I can look
smart.
</p>


<HR WIDTH="20%">
<H2><A NAME="history">Some History:</A></H2>
<HR WIDTH="20%">
<p>
Earlier versions of FGFS had assignments of joystick axis/buttons
and key bindings hard coded. If you had a joystick that did not use
the default channel assignments, or wanted different key bindings,
you had to edit the source code and recompile.
</p>
<p>
Fortunately, around about v0.7.5 a "property manager" was implemented,
which facilitated being able to set the parameters for the joystick at runtime.
Version 0.7.7 saw an expanded role for the property manager and the
addition of a "command manager" that allows for binding of events to commands.
The code that does this is known as FGInput and is used to configure
keyboard command bindings as well as joysticks.
</p>
<p>Version 0.7.9 added a compiled decision tree allowing for conditionals
to be used.
<HR WIDTH="20%">
<H2><A NAME="first_things">First Things First:</A></H2>
<HR WIDTH="20%">

<p>
I will cover joysticks first and save the keyboard stuff for later.
FGInput treats things in a generic enough way that the line between
joystick buttons and keyboard events starts to blur.
</p>
<p>
Storing alternate keyboard or joystick bindings can be done in a variety of ways. The order of precedence for options is thus:
</p>

<pre>
Source        Location  Format                Scope
------        --------  ------                -----
command line  STDIN     see examples          session
.fgfsrc       ~/        command line options  single user
system.fgfsrc $FG_ROOT  command line options  system wide
joystick.xml  $FG_ROOT  XML property list     system wide
keyboard.xml  $FG_ROOT  XML property list     system wide
</pre>
<br>


<HR WIDTH="20%">
<H2><A NAME="xml">About XML:</A></H2>
<HR WIDTH="20%">

<p>
In case you were wondering, XML stands for eXtensible Markup Language.
It looks a lot like HTML, except you get to define your own tags. Well,
in the case of FGFS we defined the tags you need to configure things.
It is well suited for describing hierarchically organized structures, such as
the property tree FGFS uses to expose the it's innards to external applications.
Your XML configuration files for FGFS must start and end with the following
pair of tags.
</p>

<pre>
&lt;PropertyList&gt;
 &lt;!-- this is a comment, See I told you it was like HTML --&gt;
&lt;/PropertyList&gt;
</pre>
<br>

<HR WIDTH="20%">
<H2><A NAME="output">Determining your joystick output:</A></H2>
<HR WIDTH="20%">

<p>
FlightGear ships with a utility called js_demo. It will report
the number of joysticks attached to a system and their capabilities.
By observing the output of js_demo while working your joystick you can
determine what controls are where.
It should be noted that, at least on UNIX, numbering generally starts with
zero. In the following example the system has 1 joystick (js0) connected.
The output shown is from an analog Gravis BlackHawk with four buttons and
a throttle.
</p>

<pre>
Typical output of js_demo:

Joystick test program.
~~~~~~~~~~~~~~~~~~~~~~
Joystick 1 not detected    &lt;!-- remember we start at 0 --&gt;
Joystick 2 not detected
+--------------JS.0--------------+
| Btns    Ax:0   Ax:1    Ax:2    |                    
+--------------------------------+
| 0000    +0.0   +0.0    -1.0    |
</pre>
<br>
<P>
The buttons are handled internally as a binary number in which bit 0 (the
least significant bit) represents button 0, bit 1 represents button 1, etc.,
but this number is displayed on the screen in hexadecimal notation, so:
</p>
<pre>
  0001 => button 0 pressed
  0002 => button 1 pressed
  0004 => button 2 pressed
  0008 => button 3 pressed
  0010 => button 4 pressed
  0020 => button 5 pressed
  0040 => button 6 pressed
  ... etc. up to ...
  8000 => button 15 pressed
  ... and ...
  0014 => buttons 2 and 4 pressed simultaneously
  ... etc.
</PRE>
<br>
<HR WIDTH="20%">
<H2><A NAME="default">Default Joystick Properties:</A></H2>
<HR WIDTH="20%">
<pre>
 Axis 0    =  Aileron
 Axis 1    =  Elevator
 Axis 2    =  Rudder
 Axis 3    =  Throttle 
 Button 0  =  All brakes
 Button 1  =  Elevator trim (up)
 Button 2  =  Elevator trim (down)
</pre>
<br>

<HR WIDTH="20%">
<H2><A NAME="okay">Okay, Now what?</A></H2>
<HR WIDTH="20%">
<p>
Now that you know what the output of the devices connected to the joystick
port (or USB port joystick devices) is, you probably want to dive straight
in and to start connecting to FGInput. If you are familiar with configuring
the joystick on versions of FGFS prior to 0.7.7 you can skip down to the
section <A HREF="#command_manager">"The Command Manager"</A>.
</P>
<P>
If you are a new FGFS user, you should at least skim the next bit since it
explains some concepts you may or may not know. It also covers some legacy
joystick options which have not been implemented yet in the context of the
command manager.
</p>

<HR WIDTH="20%">
<H2><A NAME="modifiers">Modifiers For Raw Joystick Values</A></H2>
<HR WIDTH="20%">

<p>
These concepts are expressed by supplying arguments to the joystick bindings.
The raw values coming from the joystick axes may not be suitable to use directly.
For that matter not all joysticks are created equal so understanding the basic
concepts should save you some time when experimenting to get the best performance.
</P>
<P>
The full order of precedence for axis properties is
</P>
<P>
1. The raw axis value ...<BR>
2. is filtered by dead-band, ... (deadband is implemented outside the command manager.)<BR>
3. then adjusted to offset, ...<BR>
4. then multiplied by factor,  ...<BR>
5. the resulting value is assigned to the FlightGear control property.<BR>
<BR>
Put another way....<BR>
<BR>
	cooked_value = (( raw_value > dead-band ) + offset) * factor<BR>
<BR>

<pre>
Axis properties:

    dead-band

-1      0      1
 ...............
-1     | |     1
        ^
    dead-band
</pre>
<br>

<P>
This is an area where signals are ignored. It is used to compensate
for noise, or potentiometers of dubious quality by creating a threshold
below which any signal is suppressed. dead-band is relative to zero.
</P>
<P>
The default of 0.1 for elevators and ailerons is very forgiving. A lower
number results in a tighter feel. In some cases such as throttle you may
wish to not set a deadband. Use a value of 0.0 in this case.
</P>

<pre>
     offset
-1 0         1
 .............
-1 ^         1
 offset
</pre>
<br>
<P>
Used to maximize a controls use of it's axis, as in the case of a
throttle where zero would be a minimum and not a center point like in the case
of a rudder. Typical value -1.0.
</P>
<br>
<pre>tolerance</pre>
<br>
<P>
Used to compensate for jittery potentiometer output, tolerance is in essence
a gate. Amounts of movement below the threshold are ignored. Unlike dead-band,
tolerance is relative to where ever the axis is at rest.
</p>
<br>
<pre>factor</pre>
<br>
<P>
Controls proportional movement of an axis. If the factor is too low it results in control not reaching its maximum possible limit. Negating the number will result in the control moving counter to the default. The default value is 1.0, think unity gain.
</P>
<P>
In my case, throttle behavior was inverted from what I preferred.
I set this value to -1.0 and everything was groovy.
</p>
<HR WIDTH="20%">
<H2><A NAME="command_manager">The Command Manager:</A></H2>
<HR WIDTH="20%">

<p>
Previous versions of FGFS allowed joystick output to be bound directly
to the property manager. This has changed for FGFS v0.7.7 and now events
are bound to commands. Commands *must* be specified for a binding to have
an effect. The current list of commands is broken down here into two
categories, mainly for my convenience.
</P>
<pre>
Visual And File Related:
command           options      used for
-------           -------      --------
null              none         clearing a previous binding
exit              none         Exiting FGFS
load              file name*   Load a saved flight
save              file name*   Save current flight
load-panel        path **      Change/reload panel
load-preferences  path **      Load preferences ***
screen-capture    none         Save a screenshot to ./fgfs-screen.ppm
view-cycle        none         Change the direction of the pilots view


*Saved/loaded relative to current working directory.<br>
**The path includes the filename you wish to load and is relative to $FG_ROOT,
  which is the location of the installed base package. The default for load-panel
  is the value of /sim/panel/path (from preferences.xml) or if that is unset
  Panel/Default/default.xml. The default for load preferences is preferences.xml.
  
***This might make a good first binding to experiment with, since it's not currently
   bound to anything. Reloading preferences will allow you to test settings
   without having to sit through a restart of FGFS for every edit. You can
   always (re)move it later.

Flight Control:

command         options                effect
-------         -------                ------
property-toggle property               toggle the property full on
property-assign "" "", value           targets a property for action
property-adjust "" "", step            Increment size for changes
property-swap   "" ""[0], "" ""[1]     Set values in a switch
property-scale  "" "", offset, factor  Processes the raw joystick value
</pre>
<br>

<HR WIDTH="20%">
<H2><A NAME="bindings">Bindings:</A></H2>
<HR WIDTH="20%">
<p>

A command may have more than one binding.  By default, the examples below
use just /binding or &lt;binding&gt;, but /binding[0] or &lt;binding n="0"&gt; is implied.
When bindings are specified in XML the indices are created automagically. If
you wish to avoid XML you must supply the index number for multiple bindings
in your command line formatted options.
</P>

<HR WIDTH="20%">
<H2><A NAME="axes">Joystick Axes:</A></H2>
<HR WIDTH="20%">

<p>
Here's a sample Joystick axis declaration in XML:
</p>

<PRE>
&lt;axis n="0"&gt;                   &lt;!-- target an axis --&gt;
 &lt;desc&gt;Aileron&lt;/desc&gt;          &lt;!-- descriptive name (optional) --&gt;
 &lt;binding&gt;                     &lt;!-- open a container for the binding --&gt;
  &lt;command&gt;property-scale&lt;/command&gt;    &lt;!-- pick a command --&gt;
  &lt;property&gt;/controls/flight/aileron&lt;/property&gt;   &lt;!-- target a property --&gt;
 &lt;/binding&gt;                    &lt;!-- closing tag for binding --&gt;
&lt;/axis&gt;                        &lt;!-- closing tag for axis --&gt;
</PRE>
<br>
<P>
Remember how I said the property tree was a hierarchy? Thoughtful readers
will notice how the nested tags keep things organized.
This binding appears in the context /input/joysticks/js/, so the
command-line option equivalent of this declaration (leaving out the
'desc', which isn't strictly necessary), is
</P>
<PRE>
  --prop:/input/joysticks/js[0]/axis[0]/binding/command=property-scale
  --prop:/input/joysticks/js[0]/axis[0]/binding/property=/controls/flight/aileron
</PRE>
<br>
<P>
Do you see how the command line versions uses a path to represent the hierarchy?
Cool! You should read README.xmlpanel next, working with FGFS XML configuration
system is easy and it's fun for the whole family! ( not sold in stores. excludes
tax and title. void where prohibited by law.)
</P>
<P>
Ok, back to business. The 'property-scale' command also recognizes 'offset' and
'factor' arguments. The "type" arguments shown in the following example are
specifying a double precision floating point number. A double has more discrete
steps and gives a smoother action than a plain float.
</P>
<PRE>

&lt;axis n="2"&gt;
 &lt;desc&gt;Throttle&lt;/desc&gt;
 &lt;!-- See important note about dead-band below --&gt;
 &lt;binding&gt;
  &lt;command&gt;property-scale&lt;/command&gt;
  &lt;property&gt;/controls/engines/engine[0]/throttle&lt;/property&gt;
  &lt;offset type="double"&gt;-1.0&lt;/offset&gt;
  &lt;factor type="double"&gt;-0.5&lt;/factor&gt;
 &lt;/binding&gt;
&lt;/axis&gt;</tt>

or

 --prop:/input/joysticks/js[0]/axis[2]/binding/command=property-scale
 --prop:/input/joysticks/js[0]/axis[2]/binding/property=/controls/engines/engine[0]/throttle
 --prop:/input/joysticks/js[0]/axis[2]/binding/offset=-1.0
 --prop:/input/joysticks/js[0]/axis[2]/binding/factor=-0.5
</PRE>
<br>
<p>
*Important Note About dead-band*<br>
--------------------------------
</P>

<P>
You may recall from the section about raw axis value modifiers that dead-band
is implemented outside the command manager. This means that if you want to apply
a dead-band, the tag *must* precede the binding tag. If you are using the command
line format you must omit the 'binding' part like so:
</P>

<PRE>
  --prop:/input/joysticks/js[0]/axis[2]/dead-band=0.005
</PRE>

<br>
<HR WIDTH="20%">
<H2><A NAME="buttons">Joystick Button Properties:</A></H2>
<HR WIDTH="20%">

<p>
Buttons, being boolean by nature, can use a little help. By this I mean that there are times when you need momentary action, times where you need a repeating action and sometimes you just want a plain old toggle. In order to facilitate this need we have some tags that modify the actions of buttons.
</P>

<PRE>

&lt;repeatable&gt; 
&lt;!-- Will be either true or false. If it is true, holding down a button (or key) will cause 
repeated events, say, for moving the trim; if false (the default), pressing a key will cause only a single event. --&gt;

&lt;step&gt;
&lt;!-- The property-adjust command takes a 'step' argument specifying the amount of the adjustment 
for each event. In the following example, the elevator trim moves 0.1% for each event (without automatic 
repetition, you'd have a pretty sore finger). --&gt;

&lt;value&gt;
&lt;!-- Use value on non-repeatables to supply the value for each consecutive press--&gt;
&lt;mod-up&gt;
&lt;!-- This stands for "modifier up", my favorite I think. This is used to set up a binding for 
when you *release* a key. As you'll see, it comes in handy --&gt;
</PRE>
<br>
<P>
Here's a sample joystick button declaration in XML:
</P>

<PRE>
&lt;button n="1"&gt;                        &lt;!-- target a button --&gt;
 &lt;desc&gt;Elevator trim up&lt;/desc&gt;  &lt;!-- optional description --&gt;
 &lt;repeatable&gt;true&lt;/repeatable&gt;  &lt;!-- Ok, repeatable is outside the command manager too --&gt;
  &lt;binding&gt;                           &lt;!-- Open the "binding" node of the tree--&gt;
   &lt;command&gt;property-adjust&lt;/command&gt;           &lt;!-- pick a command type to bind --&gt;
   &lt;property&gt;/controls/flight/elevator-trim&lt;/property&gt; &lt;!-- target a property --&gt;
   &lt;step type="double"&gt;0.001&lt;/step&gt;
  &lt;/binding&gt;
&lt;/button&gt;
</PRE>
<br>
<P>
In command-line option syntax, this would appear as
</P>

<PRE>
  --prop:/input/joysticks/js[0]/button[1]/repeatable=true     &lt;-- See? no 'binding' --&gt;
  --prop:/input/joysticks/js[0]/button[1]/binding/command=property-adjust
  --prop:/input/joysticks/js[0]/button[1]/binding/property=/controls/flight/elevator-trim
  --prop:/input/joysticks/js[0]/button[1]/binding/step=0.001
</PRE>
<br>
<P>
Here's a slightly fancier declaration, that applies the left (differential) brakes
when button 4 is pressed, and releases them automatically when the user releases the
button:
</P>

<PRE>
&lt;button n="4"&gt;
 &lt;desc&gt;Left brake&lt;/desc&gt;
 &lt;binding&gt;
  &lt;command&gt;property-assign&lt;/command&gt;
  &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
  &lt;value type="double"&gt;1.0&lt;/value&gt;    &lt;!-- brakes are a toggle so 1.0 represents on --&gt;
  &lt;/binding&gt;
   &lt;mod-up&gt;                    &lt;!-- it's not a parking brake so we need to release it --&gt;
    &lt;binding&gt;
    &lt;command&gt;property-assign&lt;/command&gt;
    &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
    &lt;value type="double"&gt;0.0&lt;/value&gt;       &lt;!-- 1.0 is on so 0.0 is off, right? --&gt;
   &lt;/binding&gt;
  &lt;/mod-up&gt;
&lt;/button&gt;
</PRE>
<br>
<p>
The first binding is straight-forward: when the button is pressed, the
'property-assign' command assigns the value 1.0 (i.e. full) to the left brake
property.  The second binding, however, is nested inside a 'mod-up' element,
it will be fired when the user *releases* the button, and will use the
'property-assign' command to assign the value 0.0 (i.e. none) to the left brake
property.  Repetition is left at the default value of false, so that the same
value will not be assigned over and over again.
</P>
<P>
Here's the command-line equivalent:
</p>
<PRE>
  --prop:/input/joysticks/js[0]/button[4]/binding/command=property-assign
  --prop:/input/joysticks/js[0]/button[4]/binding/property=/controls/gear/brake-left
  --prop:/input/joysticks/js[0]/button[4]/binding/value=1.0
  --prop:/input/joysticks/js[0]/button[4]/mod-up/binding/command=property-assign
  --prop:/input/joysticks/js[0]/button[4]/mod-up/binding/property=/controls/gear/brake-left
  --prop:/input/joysticks/js[0]/button[4]/mod-up/binding/value=0.0
</PRE>
<br>
<P>
Remember that more than one binding can be included in each context. Here's a
very hairy example from the default bindings that fires all three brakes when
button 0 is pressed, and releases all three when button 0 is released:
</P>

<PRE>
 &lt;button n="0"&gt;
  &lt;desc&gt;Brakes&lt;/desc&gt;
  &lt;binding&gt;
   &lt;command&gt;property-assign&lt;/command&gt;
   &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
   &lt;value type="double"&gt;1.0&lt;/value&gt;
  &lt;/binding&gt;
  &lt;binding&gt;
   &lt;command&gt;property-assign&lt;/command&gt;
   &lt;property&gt;/controls/gear/brake-right&lt;/property&gt;
   &lt;value type="double"&gt;1.0&lt;/value&gt;
  &lt;/binding&gt;
  &lt;mod-up&gt;
   &lt;binding&gt;
    &lt;command&gt;property-assign&lt;/command&gt;
    &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
    &lt;value type="double"&gt;0.0&lt;/value&gt;
   &lt;/binding&gt;
   &lt;binding&gt;
    &lt;command&gt;property-assign&lt;/command&gt;
    &lt;property&gt;/controls/gear/brake-right&lt;/property&gt;
    &lt;value type="double"&gt;0.0&lt;/value&gt;
   &lt;/binding&gt;
  &lt;/mod-up&gt;
&lt;/button&gt;
</PRE>
<br>
<p>
For people who take pleasure in avoiding XML, here's the command-line
equivalent (note the subscripts to distinguish multiple bindings; the
XML will handle this automatically):
</P>
<PRE>
  --prop:/input/joysticks/js[0]/button[0]/binding[0]/command=property-assign
  --prop:/input/joysticks/js[0]/button[0]/binding[0]/property=/controls/gear/brake-left
  --prop:/input/joysticks/js[0]/button[0]/binding[0]/value=1.0
  --prop:/input/joysticks/js[0]/button[0]/binding[1]/command=property-assign
  --prop:/input/joysticks/js[0]/button[0]/binding[1]/property=/controls/gear/brake-right
  --prop:/input/joysticks/js[0]/button[0]/binding[2]/value=1.0
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[0]/command=property-assign
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[0]/property=brakes[0]
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[0]/value=0.0
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[1]/command=property-assign
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[1]/property=brakes[1]
  --prop:/input/joysticks/js[0]/button[0]/mod-up/binding[1]/value=0.0
</PRE>
<br>
<P>
This is a good time to remind you that command line formatted options are used
in your .fgfsrc file. You can put them in $FG_ROOT/system.fgfsrc to make them
global.
</P>
<HR WIDTH="20%">
<H2><A NAME="coolie_hat">Digital Coolie Hats:</A></H2>
<HR WIDTH="20%">
<p>
Many common joysticks come with digital coolie hats. These are detected as 
axes rather than as buttons, although they are in fact just four (or eight) 
simple switches. FGFS provides 2 virtual buttons to every axis which are 
triggered whenever the axis reaches one of the end positions. These virtual 
buttons can be addressed via two sub-properties "low" and "high" and accept any
of the common button properties.  
</P>
<P>
For example, if you just want to control view direction, you can map two of the 
axes to /sim/view/axes/long and /sim/view/axes/lat:
</P>
<PRE>
  --prop:/input/joysticks/js/axis[5]/binding/command=property-scale
  --prop:/input/joysticks/js/axis[5]/binding/property=/sim/view/axes/lat

  --prop:/input/joysticks/js/axis[6]/binding/command=property-scale
  --prop:/input/joysticks/js/axis[6]/binding/property=/sim/view/axes/long
</PRE>
<br>
<p>
If you want to use them as buttons (say, to scroll the panel
vertically or horizontally), you can use the high/low bindings.
Here's an example of how to use an axis to adjust the elevator trim:
</P>
<PRE>
  --prop:/input/joysticks/js/axis[1]/low/repeatable=true
  --prop:/input/joysticks/js/axis[1]/low/binding/command=property-adjust
  --prop:/input/joysticks/js/axis[1]/low/binding/property=/controls/flight/elevator-trim
  --prop:/input/joysticks/js/axis[1]/low/binding/step=0.001

  --prop:/input/joysticks/js/axis[1]/high/repeatable=true
  --prop:/input/joysticks/js/axis[1]/high/binding/command=property-adjust
  --prop:/input/joysticks/js/axis[1]/high/binding/property=/controls/flight/elevator-trim
  --prop:/input/joysticks/js/axis[1]/high/binding/step=-0.001
</PRE>
<br>
<p>
If you want you can specify a time interval for processing digital hat repeats.  For example 
if you want an interval of 0.05 seconds, which will effect up to 20 repeats per second, then add 
the following to the property:
</p>
<PRE>
  --prop:/input/joysticks/js/axis[1]/interval-sec=0.05
</PRE>
<br>
<p>
If you want specify a delay time before interval repeats action.  For example 
if you want an interval of 0.05 seconds after 1 second the axis has been pressed, then add 
the following to the property:
</p>
<PRE>
  --prop:/input/joysticks/js/axis[1]/delay-sec=1
  --prop:/input/joysticks/js/axis[1]/interval-sec=0.05
</PRE>
<p>
Similarly, release-delay-sec is how long to wait after releasing the button.
</p>
<br>
<P>
You could also bind some axes to brakes, so that you can use positions
between between 0.0 (no brakes) and 1.0 (full brakes).
</P>

<HR WIDTH="20%">
<H2><A NAME="keyboard">Keyboard Bindings:</A></H2>
<HR WIDTH="20%">
<p>
Keyboard bindings are almost exactly identical to joystick-button
bindings, as in the following example (the context is
/input/keyboard):
</P>
<PRE>
 &lt;key n="1"&gt;
  &lt;name&gt;Ctrl-A&lt;/name&gt;
  &lt;desc&gt;Toggle autopilot altitude lock.&lt;/desc&gt;
  &lt;binding&gt;
   &lt;command&gt;property-toggle&lt;/command&gt;
   &lt;property&gt;/autopilot/locks/altitude&lt;/property&gt;
  &lt;/binding&gt;
 &lt;/key&gt;
</PRE>
<br>
<P>
There are a few gotcha's though.  First, the index of the key
specifies the key code that you're binding; in the above example, '1'
corresponds to Ctrl-A (as mentioned in the friendly comment).  Regular
key codes go up to 255; codes from 256 up represent special keys like
function and arrow keys (you can get the value from include/GL/glut.h,
but adding 256 to the special key code).  Here is the command-line
equivalent of the above, leaving out the documentation properties:
</P>
<PRE>
  --prop:/input/keyboard/key[1]/binding/command=property-toggle
  --prop:/input/keyboard/key[1]/binding/property=/autopilot/locks/altitude
</PRE>
<br>
<p>
(The 'property-toggle' command switches a boolean value between true and
false, so it needs no arguments except for the property name.)  DON'T
LEAVE OUT THE INDEX!!!
</P>
<P>
The second gotcha is that keys can take more modifiers than joystick
buttons.  In addition to mod-up (representing the key release), a key
may use any combination of nested 'mod-alt', 'mod-ctrl', and
'mod-shift' modifiers, as in the following example:
</P>
<PRE>
 &lt;key n="49"&gt;
  &lt;name&gt;1&lt;/name&gt;
   &lt;mod-shift&gt;
   &lt;desc&gt;Look back left&lt;/desc&gt;
   &lt;binding&gt;
    &lt;command&gt;property-assign&lt;/command&gt;
    &lt;property&gt;/sim/view/goal-offset&lt;/property&gt;
    &lt;value type="double"&gt;135&lt;/value&gt;
   &lt;/binding&gt;
  &lt;/mod-shift&gt;
 &lt;/key&gt;
</PRE>
<br>
<P>
In this example, the '1' key combined with shift causes the view to
switch to back left.  Note that this will work only with the keypad 1,
since pressing shift+1 on the regular keyboard will give a '!'
character instead.
</P>
<P>
The input module tries to be smart about supplying control and shift
modifiers automatically where they make sense -- note that it wasn't
necessary to use a nested 'mod-ctrl' element for the ctrl-A binding
earlier, since a keycode less that 32 implies a control character
anyway.
</P>
<P>
With the new input module, the key-up events can also be detected for
the keyboard, so it's possible to have touch-sensitive brakes (etc.)
just as with the joystick:
</P>
<PRE>
 &lt;key n="44"&gt;
  &lt;name&gt;,&lt;/name&gt;
  &lt;desc&gt;Left brake&lt;/desc&gt;
   &lt;binding&gt;
   &lt;command&gt;property-assign&lt;/command&gt;
   &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
   &lt;value type="double"&gt;1.0&lt;/value&gt;
  &lt;/binding&gt;
  &lt;mod-up&gt;
   &lt;binding&gt;
   &lt;command&gt;property-assign&lt;/command&gt;
   &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;
   &lt;value type="double"&gt;0.0&lt;/value&gt;
   &lt;/binding&gt;
  &lt;/mod-up&gt;
 &lt;/key&gt;
</PRE>
<br>
<P>
Now here is a different way to bind a brake. In this example, there is
no &lt;mod-up&gt; tag, so it *does* work like a parking brake.
</P>

 <PRE>
 &lt;key n="66"&gt; 
  &lt;name&gt;B&lt;/name&gt;
  &lt;desc&gt;Toggle parking brake on or off&lt;/desc&gt;
  &lt;binding&gt;
   &lt;command&gt;property-toggle&lt;/command&gt;
   &lt;property&gt;/controls/gear/brake-parking&lt;/property&gt;
  &lt;/binding&gt;
 &lt;/key&gt;
 </PRE>

 </BODY>
</HTML>

--- End of README.Joystick.html ---


--- Start of README.add-ons ---

-*- coding: utf-8; fill-column: 72; -*-

Add-ons in FlightGear
=====================

This document explains how add-ons work in FlightGear. The add-on
feature was first added in FlightGear 2017.3. This document describes an
evolution of the framework that appeared in FlightGear 2017.4.


Contents
--------

1. Terminology

2. The addon-metadata.xml file

3. Add-ons and the Property Tree

   a) Add-on metadata
   b) Subtree reserved for add-on developers

4. Resources under the add-on directory

5. Persistent storage location for add-ons

6. Add-on-specific menus and dialogs

   a) Add-on-specific menus
   b) Add-on-specific dialogs

7. How to run code after an add-on is loaded

8. Overview of the C++ API

9. Nasal API

10. Add-on development; in-sim reload of Nasal code


Introduction
------------

fgfs can be passed the --addon=<path> option, where <path> indicates an
add-on directory. Such a directory, when used as the argument of
--addon, receives special treatment :

  1) The add-on directory is added to the list of aircraft paths.

  2) The add-on directory must contain a PropertyList file called
     addon-metadata.xml that gives the name of the add-on, its
     identifier (id), its version and possibly a few other things (see
     details below).

  3) The add-on directory may contain a PropertyList file called
     addon-config.xml, in which case it will be loaded into the Property
     Tree at FlightGear startup, as if it were passed to the --config
     fgfs option.

  4) The add-on directory must contain a Nasal file called
     addon-main.nas. This file will be loaded at startup too, and its
     main() function run in the namespace __addon[ADDON_ID]__, where
     ADDON_ID is the add-on identifier specified in the
     addon-metadata.xml file. The main() function is passed one
     argument: the addons.Addon object (a Nasal ghost, see below)
     corresponding to the add-on being loaded. This operation is done by
     $FG_ROOT/Nasal/addons.nas at the time of this writing.

Also, the Property Tree is populated (under /addons) with information
about registered add-ons. More details will be given below.

The --addon option can be specified zero or more times; each of the
operations indicated above is carried out for every specified add-on in
the order given by the --addon options used: that's what we call add-on
registration order, or add-on load order. In other words, add-ons are
registered and loaded in the order specified by the --addon options
used.


1. Terminology
   ~~~~~~~~~~~

add-on base path

  Path to a directory containing all of the add-on files. This is the
  path passed to the --addon fgfs option, when one wants to load the
  add-on in question.

add-on identifier (id)

  A string such as org.flightgear.addons.ATCChatter or
  user.joe.MyGreatAddon, used to uniquely identify an add-on. The add-on
  identifier is declared in <path>/addon-metadata.xml, where <path> is
  the add-on base path.

add-on registration

  When a --addon option is processed, FlightGear ensures that the add-on
  identifier found in the corresponding addon-metadata.xml file isn't
  already used by an add-on from a previous --addon option on the same
  command line, and stores the add-on metadata inside dedicated C++
  objects. This process is called add-on registration.

add-on loading

  The following sequence of actions:

    a) loading an add-on's addon-main.nas file in the namespace
       __addon[ADDON_ID]__
    b) calling its main() function

  is performed later (see $FG_ROOT/Nasal/addons.nas) and called add-on
  loading.


2. The addon-metadata.xml file
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~

Every add-on must have in its base directory a file called
'addon-metadata.xml'. This section explains how to write this file.

Sample addon-metadata.xml file
==============================

Here is an example of an addon-metadata.xml file, for a hypothetical
add-on called Flying Turtle distributed by Joe User:

  <?xml version="1.0" encoding="UTF-8"?>

  <PropertyList>
    <meta>
      <file-type type="string">FlightGear add-on metadata</file-type>
      <format-version type="int">1</format-version>
    </meta>

    <addon>
      <identifier type="string">user.joe.FlyingTurtle</identifier>
      <name type="string">Flying Turtle</name>
      <version type="string">1.0.0rc2</version>

      <authors>
        <author>
          <name type="string">Joe User</name>
          <email type="string">optional_address@example.com</email>
          <url type="string">http://joe.example.com/foobar/</url>
        </author>

        <author>
          <name type="string">Jane Maintainer</name>
          <email type="string">jane@example.com</email>
          <url type="string">https://jane.example.com/</url>
        </author>
      </authors>

      <maintainers>
        <maintainer>
          <name type="string">Jane Maintainer</name>
          <email type="string">jane@example.com</email>
          <url type="string">https://jane.example.com/</url>
        </maintainer>
      </maintainers>

      <short-description type="string">
        Allow flying with new foobar powers.
      </short-description>

      <long-description type="string">
        This add-on enables something really great involving turtles...
      </long-description>

      <localized>
        <fr>
          <short-description type="string">
            Permet de voler avec de nouveaux pouvoirs foobar.
          </short-description>
          <name>
          Tortue volante
          </name>
        </fr>
        <de>
        <short-description type="string">
         Erlaube das Fliegen mit neuen Foobar-Krften.
          </short-description>
        </de>
      </localized>

      <license>
        <designation type="string">
          GNU GPL version 2 or later
        </designation>

        <file type="string">
          COPYING
        </file>

        <url type="string">
          https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
        </url>
      </license>

      <min-FG-version type="string">2017.4.0</min-FG-version>
      <max-FG-version type="string">none</max-FG-version>

      <urls>
        <home-page type="string">
          https://example.com/quux
        </home-page>

        <download type="string">
          https://example.com/quux/download
        </download>

        <support type="string">
          https://example.com/quux/support
        </support>

        <code-repository type="string">
          https://example.com/quux/code-repository
        </code-repository>
      </urls>

      <tags>
        <tag type="string">first tag</tag>
        <tag type="string">second tag</tag>
        <tag type="string">etc.</tag>
      </tags>
    </addon>
  </PropertyList>

General rules
=============

We use the terms field or node interchangeably here to refer to
nodes of the addon-metadata.xml PropertyList file (technically, a field
always has a value, possibly empty, therefore fields are all leaf
nodes).

Leading and trailing whitespace in each field of addon-metadata.xml is
removed. All other whitespace is a priori preserved (this could depend
on the particular field, though).

Most fields are optional. In most cases, omitting a field is the same as
leaving it empty. But don't write empty tag fields, it is really too
ugly. ;-)

Name and id
===========

Nodes: /addon/name and /addon/identifier

The add-on name is the pretty form. It should not be overly long, but
otherwise isn't constrained. On the other hand, the add-on identifier
(id), which serves to uniquely identify an add-on:
  - must contain only ASCII letters (A-Z, a-z) and dots ('.');
  - must be in reverse DNS style (even if the domain doesn't exist),
    e.g., org.flightgear.addons.ATCChatter for an add-on distributed in
    FGAddon, or user.joe.FlyingTurtle for Joe User's Flying Turtle
    add-on. Of course, if Joe User owns a domain name and uses it to
    distribute his add-on, he should put it here.

Authors and maintainers
=======================

Nodes: /addon/authors and /addon/maintainers

Authors are people who contributed significantly to the add-on.
Maintainers are people currently in charge of maintaining it.

It is possible to declare any number of authors and any number of
maintainers---the example above shows only one maintainer for shortness,
but this is not a restriction.

For each author and maintainer, you can give a name, an email address
and a URL. The name must be non-empty, but the email address and URL
need not be specified or may be left empty, which is equivalent.
Obviously, if no email address nor URL is given for any maintainer, it
is highly desirable that /addon/urls/support contains a usable URL for
contacting the add-on maintainers.

The data in children nodes of /addon/maintainers may refer either to
real persons or to more abstract entities such as mailing-lists. In case
of a real person, the corresponding URL, if specified, is expected to be
the person's home page. On the other hand, if a declared maintainer is
a mailing-list, a good use for the 'url' field is to indicate the
address of a web page from which people can subscribe to the
mailing-list.

Short and long descriptions
===========================

Nodes: /addon/short-description and /addon/long-description

The short description should fit on one line (try not to exceed, say, 78
characters), and in general consist of only one sentence.

The long description is essentially free-form, but only break lines when
you do want a line break at this point. In other words, don't wrap lines
manually in the XML file: this will be automatically done by the
software displaying the add-on description, according to the particular
line width it uses (which can depend on the user's screen or
configuration, etc.). A single \n inside a paragraph (see footnote [1])
means a hard line break. Two \n in a row (i.e., a blank line) should be
used to separate paragraphs. Example:

This is a paragraph.
This is the second line of the same paragraph. It can be very, very, very long and contain several sentences.

This is a different paragraph. Again, don't break lines (i.e., don't press Enter) unless a particular formatting reason makes it necessary. For instance, it is okay to break lines in order to present a list of items, but not for line wrapping.

Licensing terms
===============

Nodes: /addon/license/designation
       /addon/license/file
       /addon/license/url

The /add-on/license/designation node should describe the add-on
licensing terms in a short but accurate way, if possible. If this is not
practically doable, use the value Custom. If the add-on is distributed
under several licenses, use the value Multiple. In all cases, make
sure the licensing terms are clearly specified in other files of the
add-on (typically, at least README.txt or COPYING). Values for
/add-on/license/designation could be GNU GPL version 2 or later, CC0
1.0 Universal, 3-clause BSD, etc.

In most cases, the add-on should contain a file containing the full
license text. Use the /add-on/license/file node to point to this file:
it should contain a file path that is relative to the add-on base
directory. This path must use slash separators ('/'), even if you use
Windows.

The /add-on/license/url node should contain a single URL if there is an
official, stable URL for the license under which the add-on is
distributed. The term official here is to be interpreted in the
context of the particular license. For instance, for a GNU license
(GPL2, LGPL2.1, etc.), the URL domain must be gnu.org; for a CC license
(CC0 1.0 Universal, CC-BY-SA 4.0...), it must be creativecommons.org,
etc.

Minimum and maximum FlightGear versions
=======================================

Nodes: /addon/min-FG-version and /addon/max-FG-version

These two nodes are optional and may be omitted unless the add-on is
known not to work with particular FlightGear versions.
/addon/min-FG-version defaults to 2017.4.0 and /addon/max-FG-version to
the special value 'none' (only allowed for /addon/max-FG-version). Apart
from this special case, every non-empty value present in one of these
two fields must be a proper FlightGear version number usable with
simgear::strutils::compare_versions(), for instance '2017.4.1'.

Add-on version
==============

Node: /addon/version

The /addon/version node gives the version of the add-on and must obey a
strict syntax[2], which is a subset of what is described in PEP 440:

  https://www.python.org/dev/peps/pep-0440/

Valid examples are, in increasing sort order:

  1.2.5.dev1      # first development release of 1.2.5
  1.2.5.dev4      # fourth development release of 1.2.5
  1.2.5
  1.2.9
  1.2.10a1.dev2   # second dev release of the first alpha release of 1.2.10
  1.2.10a1        # first alpha release of 1.2.10
  1.2.10b5        # fifth beta release of 1.2.10
  1.2.10rc12      # twelfth release candidate for 1.2.10
  1.2.10
  1.3.0
  2017.4.12a2
  2017.4.12b1
  2017.4.12rc1
  2017.4.12

.devN suffixes can of course be used on beta and release candidates too,
just as with the 1.2.10a1.dev2 example given above for an alpha release.
Note that a development release always sorts before the corresponding
non-development release (e.g., 2017.2.1b5.dev4 comes before 2017.2.1b5).

Translations
============

Certain nodes can be translated based on the active languages within FlightGear.
Especially, the name and descriptions can be translated, by adding them to
a language node beneath 'localized', as show in the example above. Where there is
no translation for a particular value, the default one is used.

Other fields
============

The other nodes of 'addon-metadata.xml' should be self-explanatory. :-)


3. Add-ons and the Property Tree
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

a) Add-on metadata
   ^^^^^^^^^^^^^^^

The most important metadata for each registered add-on is made
accessible in the Property Tree under /addons/by-id/ADDON_ID and the
property /addons/by-id/ADDON_ID/loaded can be checked or listened to, in
order to determine when a particular add-on is loaded. There is also a
Nasal interface to access add-on metadata in a convenient way (see
below).

More precisely, when an add-on is registered, its name, id, base path,
version (converted to a string), loaded status (boolean) and load
sequence number (int) become available in the Property Tree as
/addons/by-id/ADDON_ID/{name,id,path,version,loaded,load-seq-num}. The
loaded status is initially false, and set to true when the add-on
loading phase is complete.

There are also /addons/addon[i]/path nodes where i is 0 for the first
registered add-on, 1 for the second one, etc.


b) Subtree reserved for add-on developers
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For each add-on, the subtree of the global Property Tree starting at
/addons/by-id/ADDON_ID/addon-devel is reserved for the specific needs of
the add-on, where ADDON_ID stands for the add-on identifier. For
instance, developers of the add-on whose identifier is
user.joe.FlyingTurtle can store whatever they want under
/addons/by-id/user.joe.FlyingTurtle/addon-devel with the assurance that
doing this won't clash with properties used by the add-on framework.

Example:

  /addons/by-id/user.joe.FlyingTurtle/addon-devel/some/property and
  /addons/by-id/user.joe.FlyingTurtle/addon-devel/other/property

  could be two properties used for the specific needs of the
  add-on whose identifier is user.joe.FlyingTurtle.

Add-on developers should *not* use other places in the /addons subtree
of the Property Tree for their custom properties.


4. Resources under the add-on directory
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many functions in FlightGear use files that are located using the
SimGear ResourceManager class. This class allows one to point to files
by relative path in aircraft source files and other places. The resource
manager queries a set of providers, some of which look inside aircraft
paths (starting with the current aircraft), others inside scenery paths,
others under $FG_ROOT, etc. The first file that matches the specified
resource path is used.

One of these providers only handles resource paths with a very specific
syntax, which is:

  [addon=ADDON_ID]path/relative/to/the/addon/directory

  (for instance, [addon=user.joe.FlyingTurtle]images/eject-button.png)

When you use such a syntax in a place that is expected to contain a
resource path, it will only find the specified file under the directory
of the add-on whose identifier is ADDON_ID. This allows one to
specifically target a particular file inside a particular add-on,
instead of crossing fingers and hoping that the specified resource won't
be found by coincidence in another place such as an aircraft directory,
a scenery directory or inside $FG_ROOT (such mistakes can easily happen
when unrelated places use files with rather generic names, such as
button.png, system.xml, etc.).

The [addon=ADDON_ID]relative/path syntax is useful where resources are
specified inside non-Nasal files (e.g., in property-rule configuration
files, which use the XML format). For the particular case of Nasal code,
there is a better way that is explained below (see Nasal API): the
resourcePath() method of addons.Addon objects returns a string like
"[addon=ADDON_ID]relative/path" when you pass it the string
"relative/path". This is a good thing to use, because then your Nasal
code doesn't need to know about the particular syntax for
add-on-specific resources and, more interestingly, doesn't have to
hardcode the add-on identifier every time you need to access a resource
inside the add-on directory.

4.1 Resources extending $FG_ROOT
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add-ons can options supply a special sub-directory which is searched when
FlightGear looks for files normally residing in $FG_ROOT. For example input
configurations, network protocols and other non-aircraft resources. Since
these files cannot use the scheme above, a different approach is used. If
an add-on defines a subdirectory called 'FGData', this is becomes an
additional data directory to be searched for any such standard files. For
security reasons, add-on FGData extensions are searched after the main
$FG_ROOT location, so that an addon cannot maliciously replace a core resource.

Only some files currently support being added via this mechanism, so if you
find a non-working case which would be useful, please request it via the
developer mailing list.


5. Persistent storage location for add-ons
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If an add-on needs to store data that persists across FlightGear
sessions, it can use a specific directory tree whose path is obtained
with addon.storagePath, where 'addon' is an addons.Addon instance. This
corresponds to $FG_HOME/Export/Addons/ADDON_ID, however it is simpler
and better to use addon.storagePath instead of hardcoding and manually
assembling this path in each add-on. Since the directory is likely not
to exist until the add-on creates it, the recommended usage pattern is
the following:

  1) Create the add-on-specific storage directory if it doesn't already
     exist, and optionally get its path at the same time:

       storageDir = addon.createStorageDir();

     Typically, you'll run this in the add-on main() function (at least,
     early enough) if your add-on uses the storage directory. Note that
     there is no need to check yourself whether the directory already
     exists: addon.createStorageDir() does that for you.

  2) At any time, you can get a path to the add-on-specific storage
     directory with:

       storageDir = addon.storagePath

     Accessing addon.storagePath doesn't check for the existence nor the
     type of $FG_HOME/Export/Addons/ADDON_ID, thus it is a bit faster
     than addon.createStorageDir(). Use addon.storagePath whenever you
     know that the directory has already been created.

The features described in this section were added in FlightGear 2018.2.


6. Add-on-specific menus and dialogs
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

a) Add-on-specific menus
   ^^^^^^^^^^^^^^^^^^^^^

Add-ons can easily provide their own menus. If an add-on is loaded that
has a file named 'addon-menubar-items.xml' in its base directory, the
menus described in this file are added to the FlightGear menu bar. The
file should look like this:

<?xml version="1.0" encoding="UTF-8"?>

<PropertyList>
  <meta>
    <file-type type="string">FlightGear add-on menu bar items</file-type>
    <format-version type="int">1</format-version>
  </meta>

  <menubar-items>
    <menu>
      ...
    </menu>

    ...

    <menu>
      ...
    </menu>
  </menubar-items>
</PropertyList>

In this file, each <menu> element must be a valid menu description for
the FlightGear menu system (the FlightGear standard menubar in
$FG_ROOT/gui/menubar.xml provides good examples). Here is an example
that adds one menu with an entry for running some Nasal code and another
entry for opening a custom dialog (see below for add-on-specific dialogs):

    <menu>
      <label>My Menu</label>
      <enabled type="bool">true</enabled>

      <item>
        <label>Run Foobar Nasal</label>
        <binding>
          <command>nasal</command>
          <script>foobar.doBaz();</script>
        </binding>
      </item>

      <item>
        <label>My Foobar Dialog</label>
        <binding>
          <command>dialog-show</command>
          <dialog-name>my-foobar-dialog</dialog-name>
        </binding>
      </item>
    </menu>

This feature was added in FlightGear 2018.2.

  For older versions, one can add menus via addon-config.xml, but it's a
  bit hackish because of the menu index problem.


b) Add-on-specific dialogs
   ^^^^^^^^^^^^^^^^^^^^^^^

As is the case for aircraft, add-ons can provide their own dialogs by
shipping the corresponding XML files in the subfolder gui/dialogs of the
add-on base directory. In other words, with a file like

  <addon-base-path>/gui/dialogs/my-foobar-dialog.xml

starting with:

  <?xml version="1.0" encoding="UTF-8"?>
  <PropertyList>
    <name>my-foobar-dialog</name>

  ...

the following <item> element inside 'addon-menubar-items.xml' (see
above) describes a valid menu entry for showing the custom dialog.

      <item>
        <label>My Foobar Dialog</label>
        <binding>
          <command>dialog-show</command>
          <dialog-name>my-foobar-dialog</dialog-name>
        </binding>
      </item>

See $FG_ROOT/gui/dialogs to get inspiration from FlightGear's standard
dialogs.

This feature was added in FlightGear 2018.2.


7. How to run code after an add-on is loaded
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may want to set up Nasal code to be run after an add-on is loaded;
here is how to do that:

  var addonId = "user.joe.FlyingTurtle";
  var loadedFlagNode = props.globals.getNode("/addons")
                                    .getChild("by-id", 0, 1)
                                    .getChild(addonId, 0, 1)
                                    .getChild("loaded", 0, 1);

  if (loadedFlagNode.getBoolValue()) {
    logprint(5, addonId ~ " is already loaded");
  } else {
    # Define a function to be called after the add-on is loaded
    var id = setlistener(
      loadedFlagNode,
      func(changedNode, listenedNode) {
        if (listenedNode.getBoolValue()) {
          removelistener(id);
          logprint(5, addonId ~ " is loaded");
        };
      },
      0, 0);
  }


8. Overview of the C++ API
   ~~~~~~~~~~~~~~~~~~~~~~~

The add-on C++ infrastructure mainly relies on the following classes:
AddonManager, Addon and AddonVersion. AddonManager is used to register
add-ons, which later leads to their loading. AddonManager relies on an
std::map<std::string, AddonRef>, where keys are add-on identifiers and
AddonRef is SGSharedPtr<Addon> at the time of this writing (changing it
to another kind of smart pointer should be a mere one-line change). This
map holds the metadata of each registered add-on. Accessor methods are
available for:

  - retrieving the lists of registered and loaded add-ons;

  - checking if a particular add-on has already been registered or
    loaded;

  - for each add-on, obtaining an Addon instance which can be queried
    for its identifier, its name, identifier, version, base path, the
    minimum and maximum FlightGear versions it requires, its base node
    in the Property Tree, its order in the load sequence...

The AddonVersion class handles everything about add-on version numbers:
  - initialization from the individual components or from a string;
  - conversion to a string and output to an std::ostream;
  - access to every component;
  - comparisons using the standard operators: ==, !=, <, <=, >, >=.

Registering an add-on using AddonManager::registerAddon() ensures
uniqueness of the add-on identifier and makes its name, identifier, base
path, version (converted to a string), loaded status (boolean) and load
sequence number (int) available in the Property Tree as
/addons/by-id/ADDON_ID/{name,id,path,version,loaded,load-seq-num}.

Note: if C++ code needs to use the add-on base path, better use
      AddonManager::addonBasePath() or Addon::getBasePath(), whose
      return values can't be tampered with by Nasal code.

AddonManager::registerAddon() fails with a specific exception if the
running FlightGear instance doesn't match the min-FG-version and
max-FG-version requirements declared in the addon-metadata.xml file, as
well as in the obvious other cases (required files such as
addon-metadata.xml not found, invalid syntax in such files, etc.). The
code in options.cxx (fgOptAddon()) catches such exceptions and displays
the appropriate error message with SG_LOG() and
fatalMessageBoxThenExit().


9. Nasal API
   ~~~~~~~~~

The Nasal add-on API all lives in the 'addons' namespace. It gives Nasal
code easy access to add-on metadata, for instance like this:

  var myAddon = addons.getAddon("user.joe.FlyingTurtle");
  print(myAddon.id);
  print(myAddon.name);
  print(myAddon.version.str());

  foreach (var author; myAddon.authors) {
    print(author.name, " ", author.email, " ", author.url);
  }

  foreach (var maintainer; myAddon.maintainers) {
    print(maintainer.name, " ", maintainer.email, " ", maintainer.url);
  }

  print(myAddon.shortDescription);
  print(myAddon.longDescription);
  print(myAddon.licenseDesignation);
  print(myAddon.licenseFile);
  print(myAddon.licenseUrl);
  print(myAddon.basePath);
  print(myAddon.minFGVersionRequired);
  print(myAddon.maxFGVersionRequired);
  print(myAddon.homePage);
  print(myAddon.downloadUrl);
  print(myAddon.supportUrl);
  print(myAddon.codeRepositoryUrl);

  foreach (var tag; myAddon.tags) {
    print(tag);
  }

  print(myAddon.loadSequenceNumber);
  # myAddon.node is a props.Node object for /addons/by-id/ADDON_ID
  print(myAddon.node.getPath());

Among other things, the Nasal add-on API allows one to get the version
of any registered add-on as a ghost and reliably compare it to another
instance of addons.AddonVersion:

  var myAddon = addons.getAddon("user.joe.FlyingTurtle");
  var firstVersionOK = addons.AddonVersion.new("2.12.5rc1");
  # Or alternatively:
  #   var firstVersionOK = addons.AddonVersion.new(2, 12, 5, "rc1");

  if (myAddon.version.lowerThan(firstVersionOK)) {
    ...

Here follows the complete Nasal add-on API, at the time of this writing.
All strings are encoded in UTF-8.

Queries to the AddonManager:

  addons.isAddonRegistered(string addonId) -> bool (1 or 0)
  addons.registeredAddons()                -> vector<addons.Addon>
                                              (in registration/load order)
  addons.isAddonLoaded(string addonId)     -> bool (1 or 0)
  addons.loadedAddons()                    -> vector<addons.Addon>
                                              (in lexicographic order)
  addons.getAddon(string addonId)          -> addons.Addon instance (ghost)

Read-only data members (attributes) of addons.Addon objects:

  id                    the add-on identifier, in reverse DNS style (string)
  name                  the add-on pretty name (string)
  version               the add-on version (instance of addons.AddonVersion,
                        ghost)
  authors               the add-on authors (vector of addons.Author ghosts)
  maintainers           the add-on maintainers (vector of addons.Maintainer
                        ghosts)
  shortDescription      the add-on short description (string)
  longDescription       the add-on long description (string)
  licenseDesignation    licensing terms: "GNU GPL version 2 or later",
                        "CC0 1.0 Universal", etc. (string)
  licenseFile           relative, slash-separated path to a file under
                        the add-on base directory containing the license
                        text (string)
  licenseUrl            stable, official URL for the add-on license text
                        (string)
  basePath              path to the add-on base directory (string)
  storagePath           path to the add-on storage directory (string)
                        This is $FG_HOME/Export/Addons/ADDON_ID.
                        [added in FlightGear 2018.2]
  minFGVersionRequired  minimum required FG version for the add-on (string)
  maxFGVersionRequired  max. required FG version... or "none" (string)
  homePage              add-on home page (string)
  downloadUrl           add-on download URL (string)
  supportUrl            add-on support URL (string)
  codeRepositoryUrl     URL pointing to the development repository of
                        the add-on (Git, Subversion, etc.; string)
  tags                  vector containing the add-on tags used to help
                        users find add-ons (vector of strings)
  node                  base node for the add-on in the Property Tree:
                        /addons/by-id/ADDON_ID (props.Node object)
  loadSequenceNumber    0 for the first registered add-on, 1 for the
                        second one, etc. (integer)

Member functions (methods) of addons.Addon objects:

  createStorageDir() -> string
                        Create the add-on storage directory if it
                        doesn't already exist (that is,
                        $FG_HOME/Export/Addons/ADDON_ID). Return its
                        path as a string.
                        [added in FlightGear 2018.2]
  resourcePath(string relPath) -> string
                        Return a resource path suitable for use with the
                        simgear::ResourceManager. 'relPath' must be
                        relative to the add-on base directory, and
                        mustn't start with a '/'. You can use this
                        method for instance to specify an image file for
                        display in a Canvas widget.

                        In you want a full path to the resource file
                        (e.g., for troubleshooting), call resolvepath()
                        with the return value of addons.Addon.resourcePath().

Read-only data members (attributes) of addons.AddonVersion objects:

  majorNumber           non-negative integer
  minorNumber           non-negative integer
  patchLevel            non-negative integer
  suffix                string such as "", "a1", "b2.dev45", "rc12"...

Member functions (methods) of addons.AddonVersion objects:

  new(string version)                           | construct from string

  new(int major, int minor=0, int patchLevel=0, | construct
      string suffix="")                         | from components

  str()                                         | string representation

  equal(addons.AddonVersion other)              |
  nonEqual(addons.AddonVersion other)           | compare to another
  lowerThan(addons.AddonVersion other)          | addons.AddonVersion
  lowerThanOrEqual(addons.AddonVersion other)   | instance
  greaterThan(addons.AddonVersion other)        |
  greaterThanOrEqual(addons.AddonVersion other) |

Read-only data members (attributes) of addons.Author objects:

  name                  author name (non-empty string)
  email                 email address of the author (string)
  url                   home page of the author (string)

Read-only data members (attributes) of addons.Maintainer objects:

  name                  maintainer name (non-empty string)
  email                 email address of the maintainer (string)
  url                   home page of the maintainer, if a person; if the
                        maintainer is a mailing-list, the URL can point
                        to a web page from which people can subscribe to
                        that mailing-list (string)


10. Add-on development; in-sim reload of Nasal code
---------------------------------------------------

!!! WARNING:
!!! The reload feature is meant for developers only, it should not be made
!!! visible to end users. Unexpected side effects may occur due to reload,
!!! if not implemented correctly.
!!! We really don't want users to send bug reports due to reload going wrong.

To make development of add-ons less time consuming, you can reload the
Nasal part of your add-on without having to restart FlightGear. When an
add-on is loaded, setlistener() and maketimer() wrappers are installed
in the add-on's own namespace; these wrappers shadow and call themselves
the standard setlistener() and maketimer() functions. The setlistener()
and maketimer() wrapper functions keep track of every listener and timer
they create. When the add-on is removed (e.g., as part of its reload
sequence), removelistener() is called for each of these listeners, and
each timer has its stop() method called.
_
For the time being, you have to track any other resources outside the
namespace of your add-on by yourself and clean them up in the unload()
function, e.g. delete canvas or close any files you opened.

You can define this unload() function in the addon-main.nas file. When
your add-on is reloaded, its unload() function, if defined, will be
called with one argument: the addons.Addon object (a Nasal ghost)
corresponding to your add-on. unload() is run in the add-on's own
namespace.

In FlightGear Versions before 2020.1 the reload is triggered by setting the 
property /addon/by-id/ADDON_ID/reload to true (replace ADDON_ID with your
particular add-on identifier). 

!!! Since version 2020.1 reload should be done like this: 
!!! fgcommand("addon-reload", props.Node.new({'id': 'ADDON_ID'}));

You can add a menu item to trigger the reload easily, but it should be removed 
before publishing your add-on to endusers (see the above warning).

Please have a look at the skeleton add-on at
https://sourceforge.net/p/flightgear/fgaddon/HEAD/tree/trunk/Addons/Skeleton/


Footnotes
---------

[1] \n represents end-of-line in string literals of languages such as C,
    C++, Python and many others. We use this convention here to
    represent the end-of-line character sequence in the XML data.

[2] MAJOR.MINOR.PATCHLEVEL[{a|b|rc}N1][.devN2] where MAJOR, MINOR and
    PATCHLEVEL are non-negative integers, and N1 and N2 are positive
    integers.

--- End of README.add-ons ---


--- Start of README.airspeed-indicator ---

The airspeed indicator can be initialized in an instrumentation.xml file.
If not specified, the generic indicator will be loaded 
from the Aircraft/Generic/generic-instrumentation.xml.

The normal setup is :

  <airspeed-indicator>
    <name>airspeed-indicator</name>
    <number>0</number>
    <total-pressure>/systems/pitot/total-pressure-inhg</total-pressure>
    <static-pressure>/systems/static/pressure-inhg</static-pressure>
    <has-overspeed-indicator>1</has-overspeed-indicator>
  </airspeed-indicator>

Of course the total and static pressure may be sourced from any other 
pitot and static system when defined:

  <airspeed-indicator>
    <name>airspeed-indicator</name>
    <number>1</number>
    <total-pressure>/systems/pitot[1]/total-pressure-inhg</total-pressure>
    <static-pressure>/systems/static[1]/pressure-inhg</static-pressure>
    <has-overspeed-indicator>0</has-overspeed-indicator>
  </airspeed-indicator>

Note that the Aircraft/Generic/generic-systems.xml only initiates one 
pitot and one static system, see also README.systems

<total-pressure> is optional --- defaults to "/systems/pitot/total-pressure-inhg"
For supersonic aircraft with an airspeed indicator NOT compensating for 
a shockwave in front of the pitot tube (most probably the case), use:
<total-pressure>/systems/pitot/measured-total-pressure-inhg</total-pressure>

<static-pressure> is optional --- defaults to "/systems/static/pressure-inhg"
<has-overspeed-indicator> is optional --- defaults to 0 / off

The <has-overspeed-indicator> provides a property for "barber-pole" animation,
 and is set to 0 / false by default ,

If enabled , these properties should be added in the aircraft -set file,
with that aircraft's correct figures.

    <airspeed-indicator>
        <ias-limit>248.0</ias-limit>
        <mach-limit>0.48</mach-limit>
        <alt-threshold>13200.0</alt-threshold>
    </airspeed-indicator>


The default values are for a Beechcraft B1900D .

<ias-limit> is the aircraft's VNE (never exceed speed) in KIAS

<mach-limit> Mach speed limit.

<alt-threshold> altitude at which these figures were calculated.

Note : <mach-limit> is the mach limit at <alt-threshold>
This was designed for indicated airspeed limits, but could probably be extended 
for mach limits.


To initiate additional airspeed indicators, add in your instrumentation 
file (for airspeed indicator index 1):

  <airspeed-indicator>
    <name>airspeed-indicator</name>
    <number>1</number>
    <total-pressure>/systems/pitot[1]/total-pressure-inhg</total-pressure>
    <static-pressure>/systems/static[1]/pressure-inhg</static-pressure>
    <has-overspeed-indicator>0</has-overspeed-indicator>
  </airspeed-indicator>

Note: this airspeed indicator sources its pressures from the second 
pitot and static system (with index 1).
and in the aircraft -set file:

    <airspeed-indicator n="1">
	  <serviceable type="bool" archive="y">true</serviceable>
    </airspeed-indicator>

And if "has-overspeed-indicator" = 1, the appropriate limits as explained
above in the airspeed-indicator brackets.

--- End of README.airspeed-indicator ---


--- Start of README.autopush ---

AUTOMATIC PUSHBACK FOR FLIGHTGEAR
http://gitlab.com/mdanil/flightgear-autopush

Version 2.0.1

Copyright (c) 2018 Autopush authors:
 Michael Danilov <mike.d.ft402 -eh- gmail.com>
 Joshua Davidson http://github.com/Octal450
 Merspieler http://gitlab.com/merspieler
Some of the code (c) FlightGear
Distribute under the terms of GPLv2.


This project aims to develop a generic pushback for JSBSim and YASim
aircraft, with the following characteristics.

1. Do the pushback procedure automatically.
2. Scale to different aircraft with minimum changes to their logic.
3. Use no computer resources in flight.


INSTALLATION

Minimum FlightGear version: 2018.0

NOTE: these steps cover the minimal testing setup. To get the most
realism out of Autopush, you will have to add logic aircraft-side as
described in the last step.

1. Copy the autopush.config.xml.template into your aircraft directory
and the Goldhofert.xml into <your-airfraft>/Models/Autopush/

2. Set up the pushback logic.

Add the following line under <sim><model> of your set.xml

<autopush include="autopush-config.xml"/>

Rename autopush-config.xml.template to autopush-config.xml and edit
the file as described below.

Alternatively, you can copy the contents of
autopush-config.xml.template to under <sim><model><autopush> of your
set.xml and make these modifications there.

Change the aliases to point to the following data:

steer-cmd-norm   nose wheel steering command norm
yaw              nose wheel steering output norm or angle (see below)
chocks           chocks command bool (or leave it until step 7)
available        pushback availability bool (or leave it until step 7)

Replace the MULTIPLIER in yaw-mult with:

max steering angle  if yaw is norm
1.0                 if yaw is degrees
57.3                if yaw is radians

Replace PITCH with the pushback's pitch relative to aircraft. If your
aircraft's ground pitch varies greatly, you can make an alias to
property with calculated relative pitch.

Replace MIN_RADIUS with the minimum allowed turning radius in m of the
center of the aircraft during pushback procedure.

NOTE: on some aircraft the turning radius is different for taxi and
pushback. Please check the aircraft's literature.

Replace STOP_DIST with the stopping distance in m from pushback speed.

Add under <nasal> of your set.xml:

 <autopush>
  <file>Nasal/Autopush/autopush.nas</file>
 </autopush>
 <autopush_driver>
  <file>Nasal/Autopush/driver.nas</file>
 </autopush_driver>
 <dynarr>
  <file>Nasal/Autopush/dynarr.nas</file>
 </dynarr>
 <autopush_route>
  <file>Nasal/Autopush/route.nas</file>
 </autopush_route>

Add under <sim><aircraft-data> of your set.xml:

 <path>/sim/model/autopush/route/show</path>
 <path>/sim/model/autopush/route/show-wingtip</path>

3. Connect the force to FDM.

 3.a. JSBSim:

  3.a.1. Add the following under <external_reactions> of your JSBSim
         XML.

 <force name="tractor" frame="BODY">
  <location unit="M">
   <x>FRONT-X</x>
   <y>FRONT-Y</y>
   <z>FRONT-Z</z>
  </location>
  <direction>
   <x>1.0</x>
   <y>0.0</y>
   <z>0.0</z>
  </direction>
 </force>

Replace FRONT-X, FRONT-Y, FRONT-Z with coordinates of your front
bogey.

  3.a.2. Add the following under <fdm><jsbsim><external_reactions> of
         your set.xml.

   <tractor>
    <magnitude alias="/sim/model/autopush/force-lbf"/>
    <x alias="/sim/model/autopush/force-x"/>
    <y alias="/sim/model/autopush/force-y"/>
    <z alias="/sim/model/autopush/force-z"/>
   </tractor>

 3.b. YASim. Add the following under <airplane> of your YASim xml.

 <thruster x="FRONT-X" y="FRONT-Y" z="FRONT-Z" vx="1" vy="0" vz="0" thrust="100000.0">
  <control-input axis="/sim/model/autopush/force-x-yasim" control="THROTTLE" src0="-1" src1="1" dst0="-1" dst1="1"/>
 </thruster>
 <thruster x="FRONT-X" y="FRONT-Y" z="FRONT-Z" vx="0" vy="1" vz="0" thrust="100000.0">
  <control-input axis="/sim/model/autopush/force-y-yasim" control="THROTTLE" src0="-1" src1="1" dst0="-1" dst1="1"/>
 </thruster>
 <thruster x="FRONT-X" y="FRONT-Y" z="FRONT-Z" vx="0" vy="0" vz="1" thrust="100000.0">
  <control-input axis="/sim/model/autopush/force-z-yasim" control="THROTTLE" src0="-1" src1="1" dst0="-1" dst1="1"/>
 </thruster>

Replace FRONT-X, FRONT-Y, FRONT-Z with coordinates of your front
bogey.

4. Add the pushback model to your Model XML:

 <model>
  <name>Pushback</name>
  <path>MODEL</path>
  <offsets>
   <x-m>FRONT-X</x-m>
   <y-m>FRONT-Y</y-m>
   <z-m>FRONT-Z</z-m>
  </offsets>
 </model>

Replace FRONT-X, FRONT-Y, FRONT-Z with coordinates of your front
bogey. Replace MODEL with one of the following file names:

Autopush/Goldhofert.xml  for Goldhofer towbarless pushback

Edit the "SETTINGS" part in the beginning of the Goldhofert.xml to match
your setup.

5. Add gui/dialogs/autopush.xml to your aircraft's menu (see
   FlightGear documentation for editing the menu).

6. If you have a bug tracker, please add a note, that autopush related
   bugs should be reported here:

https://gitlab.com/mdanil/flightgear-autopush/issues

7. Launch the simulator and try Autopush. After making sure it works,
   complete the support by implementing some logic in your aircraft
   and connecting the rest of the interface.

CAUTION.
1. Make sure to HAVE A BACK-UP COPY of your work.
2. If anything is not clear in the instruction below, do not guess --
   contact the authors.

 7.1. When pushback is connected ("/sim/model/autopush/connected"),
      nose wheel steering must actuate at different speed, depending
      on its rollspeed. The exact dependency is different per aircraft
      and used pushback visual, and for most aircraft the only way to
      find it is trial and error until it "looks right":
      - the input must be taken from pushback steering command norm
        (set by autopush-config.xml, default:
        "/controls/flight/rudder");
      - the output must be written to pushback orientation in degrees,
        radians or norm (set by autopush-config.xml, default:
        "/gear/gear[0]/steering-norm").

 7.2. Set or alias (in autopush-config.xml) the availability property
      "/sim/model/autopush/available". It must be false if e.g. the
      aircraft is moving too fast, the front wheel is not touching
      the ground, the aircraft is damaged or is outside of an airport
      etc.

 7.3. Make Autopush remove wheel chocks by setting the alias in
      autopush-config.xml to the chocks property. (default:
      "/controls/gear/wheel-chocks").

 7.4. Optionally, Autopush may be made visible in multiplayer by
      duplicating the properties used in its model.xml into some
      unused MP properties. See the list in

https://sourceforge.net/p/flightgear/flightgear/ci/next/tree/src/MultiPlayer/multiplaymgr.cxx

      around line 215, and then using those properties in the
      "SETTINGS" part of Autopush model.xml.

   After making these changes check the Autopush model.xml's settings
   and make sure they match the setup. Launch the simulator and try
   Autopush.


TUNING

There should normally be no need to change the coefficients, because
the inertia of different aircraft is already taken into account. But
the gear setup may differ enough to require some tuning.

If these settings are changed during simulation, they take effect
after disconnecting and reconnecting the pushback.

Pushback (/sim/model/autopush):

Coefficient  Unit                    Description

K_p          ((km/h)/s)/(km/h)       Proportional coefficient of PID.
                                     Defines the start/stop throttle
                                     and immediate response to speed
                                     difference deltaV = V_set - V.

F_p          (km/h)/s                Proportional clipping.

K_i          ((km/h)/s)/((km/h)*s)   Integral coefficient of PID.
                                     Defines how fast the steady
                                     throttle is ramped during the
                                     push.

F_i          (km/h)/s                Integral clipping.

K_d          -((km/h)/s)/((km/h)/s)  Differential coefficient of PID.
                                     Stabilizes the approaching of
                                     steady throttle.

F_d          (km/h)/s                Differential clipping.

Pushback driver (/sim/model/autopush/driver):

Coefficient  Unit        Description

F_V          km/h        Max towing speed in auto mode.
K_psi        1/deg       Amount of steering per heading correction.
F_psi        1/deg       Max steering per heading correction.
K_deltapsi   -1/(deg/s)  Amount of steering compensation per heading
                         derivative.
F_psi        1/(deg/s)   Max amount of steering compensation per
                         heading derivative.

--- End of README.autopush ---


--- Start of README.checklists ---

CHECKLISTS

You can create one or more checklist for an aircraft under /sim/checklists. These
are intended to mimic the checklists of aircraft themselves, and can be found under
the Help->Checklists menu within the simulator.

Tutorials are automatically generated from checklists on startup.

Each checklist is defined as a property tree under /sim/checklists/checklist[n]
or /sim/checklists/group[n]/checklist[m]

with the following tags

<title>       - Name of the checklist
<auto-tutorial> - Whether a tutorial should be automatically generated (true, default)
                  or not (false).
<page>        - Zero or more pages for the checklist containing:
 <item>       - One or more checklist items containing:
  <name>      - name of the checklist item (e.g. Carb Heat), to appear on the left
  <value>     - One or more values for the checklist item, to appear on the right
                hand side
  <marker>    - A tutorial marker (displayed when the user presses the ? button)
                This can be easily placed using the Help->Display Tutorial Marker.
                Contains x-m, y-m, z-m and scale tag.
  <condition> - Optional standard FlightGear condition node that evaluates when the
                checklist item has been completed.
  <binding>   - Zero or more bindings to execute the checklist item.  Allows the user
                to have their virtual co-pilot perform the action if they select the
                ">" button next to the checklist item.

The <page> tag may be omitted for single-page checklists, with the <item> tags
immediately under the <checklist[n]> node.

Tutorial auto-generation of all checklists can be disabled by setting
/sim/checklists/auto-tutorials=false.

Checklists may be grouped under <group> nodes with a <name> tag decribing the
group.  For example

<group>
 <name>Emergency</name>
 <auto-tutorial>false</auto-tutorial>
 <checklist>...
 <checklist>...
</group>
<group>
 <name>Normal</name>
 <auto-tutorial>true</auto-tutorial>
 <checklist>...
 <checklist>...
</group>

See the c172p for an example of this in action (Aircraft/c172p/c172-checklists.xml).

--- End of README.checklists ---


--- Start of README.commands ---

FlightGear Commands Mini-HOWTO

David Megginson
Started: 2002-10-25
Last revised: 2007-12-01


In FlightGear, a *command* represents an action, while a *property*
represents a state.  The trigger for a command can be any kind of user
input, including the keyboard, mouse, joystick, GUI, instrument panel,
or a remote network client.


XML Command Binding Markup
--------------------------

Most of the command-binding in FlightGear is handled through static
XML configuration files such as $FG_ROOT/keyboard.xml for the
keyboard, $FG_ROOT/mice.xml for the mouse, and
$FG_ROOT/gui/menubar.xml for the menubar.  In all of these files, you
reference a command through a binding.  This binding advances the
first throttle by 1%, up to a maximum value of 1.0:

  <binding>
   <command>property-adjust</command>
   <property>/controls/throttle[0]</property>
   <step type="double">0.01</step>
   <max>1.0</max>
  </binding>

A command binding always consists of the XML 'binding' element, with
one subelement named 'command' containing the command name (such as
'property-adjust').  All other subelements are named parameters to the
command: in this case, the parameters are 'property', 'step', and
'max'.  Here is a simpler binding, with no parameters:

  <binding>
   <command>exit</command>
  </binding>

Bindings always appear inside some other kind of markup, depending on
the input type.  For example, here is the binding from keyboard.xml
that links the ESC key to the 'exit' command:

 <key n="27">
  <name>ESC</name>
  <desc>Prompt and quit FlightGear.</desc>
  <binding>
    <command>exit</command>
  </binding>
 </key>

Usually, more than one binding is allowed for a single input trigger,
and bindings are executed in order from first to last. Bindings support
conditions (see README.conditions):

 <key n="113">
  <name>q</name>
  <desc>Test</desc>

  <binding>
   <condition>
    <property>/devices/status/mice/mouse/button[0]</property>
   </condition>
   <command>nasal</command>
   <script>print("mouse button 0 pressed")</script>
  </binding>
 </key>

Keyboard definitions can embed bindings in tags <mod-up> (key released),
<mod-shift>, <mod-ctrl>, <mod-alt>, <mod-meta>, <mod-super>, and <mod-hyper>.
Nesting is supported. Meta, Super, and Hyper modifier tags are for local
use only, and must be supported by the operating system to work.

 <key n="113">
  <name>q</name>
  <desc>Test</desc>
  <binding>
   <command>nasal</command>
   <script>print("q pressed")</script>
  </binding>

  <mod-alt>
   <binding>
    <command>nasal</command>
    <script>print("Alt-q pressed")</script>
   </binding>

   <mod-super>
    <binding>
     <command>nasal</command>
     <script>print("Alt-Super-q pressed")</script>
    </binding>

    <mod-meta>
     <binding>
      <command>nasal</command>
      <script>print("Alt-Super-Meta-q pressed")</script>
     </binding>

    </mod-meta>
   </mod-super>
  </mod-alt>
 </key>



Built-in Commands
-----------------

As of the last revision date, the following commands were available
from inside FlightGear; the most commonly-used ones are the commands
that operate on property values (FlightGear's internal state):


null - do nothing

script - execute a PSL script
  script: the PSL script to execute

exit - prompt and quit FlightGear

pause - pause/resume the simulation

load - load properties from an XML file
  file: the name of the file to load, relative to the current
    directory (defaults to "fgfs.sav")

save - save properties to an XML file
  file: the name of the file to save, relative to the current
    directory (defaults to "fgfs.sav").

loadxml - load XML file into property tree
  filename: the path & filename of the file to load
  targetnode: the target node within the property tree where to store the XML
  file's structure. If targetnode isn't defined, then the data will be stored
  in a node "data" under the argument branch.

savexml - save property tree node to XML file
  filename: the path & filename for the file to be saved
  sourcenode: the source node within the property tree where the XML file's
  structure is assembled from. If sourcenode isn't defined, then savexml will
  try to save data stored in a node "data" in the argument branch.

panel-load - (re)load the 2D instrument panel
  path: the path of the XML panel file, relative to $FG_ROOT (defaults
    to the value of /sim/panel/path if specified, or
    "Panels/Default/default.xml" as a last resort.

panel-mouse-click - pass a mouse click to the instrument panel
  button: the number of the mouse button (0-based)
  is-down: true if the button is down, false if it is up
  x-pos: the x position of the mouse click
  y-pos: the y position of the mouse click

preferences-load - (re)load preferences
  path: the file name to load preferences from, relative to $FG_ROOT.
    Defaults to "preferences.xml".

view-cycle - cycle to the next viewpoint

screen-capture - capture the screen to a file

tile-cache-reload - reload the scenery tile cache

lighting-update - update FlightGear's lighting

property-toggle - swap a property value between true and false
  property: the name of the property to toggle

property-assign - assign a value to a property
  property[0]: the name of the property that will get the new value.
  value: the new value for the property; or
  property[1]: the name of the property holding the new value.

property-interpolate - assign a value to a property, interpolated 
                       over time
  property[0]: the name of the property that will get the new value
               and defines the starting point of the interpolation
  value:       the new value for the property; or
  property[1]: the name of the property holding the new value.
  time:        the time in seconds it takes for the transition from the
               old value to the new value of property[0]; or
  rate:        the ammount of change per second the value of property[0] changes
               to transition to the new value

property-adjust - adjust the value of a property
  property: the name of the property to increment or decrement
  step: the amount of the increment or decrement (defaults to 0)
  offset: input offset distance (used for the mouse; multiplied by
    factor)
  factor: factor for multiplying offset distance (used for the mouse;
    defaults to 1)
  min: the minimum allowed value (default: no minimum)
  max: the maximum allowed value (default: no maximum)
  mask: 'integer' to apply only to the left of the decimal point;
    'decimal' to apply only to the right of the decimal point; 'all'
    to apply to the full value (defaults to 'all')
  wrap: true if the value should be wrapped when it passes min or max;
    both min and max must be specified (defaults to false)

property-multiply - multiply the value of a property
  property: the name of the property to multiply
  factor: the amount by which to multiply (defaults to 1.0)
  min: the minimum allowed value (default: no minimum)
  max: the maximum allowed value (default: no maximum)
  mask: 'integer' to apply only to the left of the decimal point;
    'decimal' to apply only to the right of the decimal point; 'all'
    to apply to the full value (defaults to 'all')
  wrap: true if the value should be wrapped when it passes min or max;
    both min and max must be specified (defaults to false)

property-swap - swap the values of two properties
  property[0]: the name of the first property
  property[1]: the name of the second property

property-scale - set the value of a property based on an axis
  property: the name of the property to set
  setting: the current input setting (usually a joystick axis from -1
    or 0 to 1)
  offset: the offset to shift by, before applying the factor (defaults
    to 0)
  factor: the factor to multiply by (use negative to reverse; defaults
    to 1.0)
  squared: if true will square the resulting value (same as power=2)
  power: the resulting value will be taken to the power of this integer
    value (overrides squared; default=1)

property-cycle - cycle a property through a set of values
  property: the name of the property to cycle
  value[*]: all of the allowed values

dialog-new - create new dialog from the argument branch

dialog-show - show an XML-configured dialog box
  dialog-name - the name of the dialog to show

dialog-close - close the active dialog box

dialog-update - copy values from FlightGear to the active dialog box
  object-name: the name of the GUI object to update (defaults to all
    objects)

dialog-apply - copy values from the active dialog box to FlightGear
  object-name: the name of the GUI object to apply (defaults to all
    objects)

presets-commit - commit preset values from /sim/presets

open-browser - open the web browser and show given file
   path: name of the local file to be opened.
   url: URL to be opened (http://..., ftp://...).

The following commands are temporary, and will soon disappear or be
renamed; do NOT rely on them:

old-save-dialog - offer to save a flight

old-load-dialog - offer to load a flight

old-reinit-dialog - offer to reinit FlightGear

old-hires-snapshot-dialog - save a hires screen shot

old-snapshot-dialog - save a screenshot

old-print-dialog - print the screen (Windows only)

old-pilot-offset-dialog - set pilot offsets graphically

old-hud-alpha-dialog - set the alpha value for the HUD

old-properties-dialog - display the property browser

old-preset-airport-dialog - set the default airport

old-preset-runway-dialog - set the default runway

old-preset-offset-distance-dialog - set the default offset distance

old-preset-altitude-dialog - set the default altitude

old-preset-glidescope-dialog - set the default glidescope

old-preset-airspeed-dialog - set the default airspeed

old-preset-commit-dialog - commit preset values

old-ap-add-waypoint-dialog - add a waypoint to the current route

old-ap-pop-waypoint-dialog - remove a waypoint from the current route

old-ap-clear-dialog - clear the current route

old-ap-adjust-dialog - adjust the autopilot settings

old-lat-lon-format-dialog - toggle the lat/lon format in the HUD


Adding New Commands in C++
--------------------------


To add a new command to FlightGear, you first need to create a
function that takes a single SGPropertyNode const pointer as an
argument:

  void
  do_something (SGPropertyNode * arg)
  {
    something();
  }

Next, you need to register it with the command manager:

  globals->get_commands()->addCommand("something", do_something);

Now, the command "something" is available to any mouse, joystick,
panel, or keyboard bindings.  If the bindings pass any arguments, they
will be children of the SGPropertyNode passed in:

  void
  do_something (const SGPropertyNode * arg)
  {
    something(arg->getStringValue("foo"), arg->getDoubleValue("bar"));
  }

That's pretty-much it.  Apologies in advance for not making things any
more complicated.



--- End of README.commands ---


--- Start of README.conditions ---

CONDITIONS IN FLIGHTGEAR PROPERTY FILES

Written by David Megginson, david@megginson.com
Last modified: $Date$

This document is in the Public Domain and comes with NO WARRANTY!


1. Introduction
---------------

Some FlightGear property files contain conditions, affecting whether
bindings or animations are applied.  For example, the following
binding will apply only when the /sim/input/selected/engine[0]
property is true:

  <binding>
   <condition>
    <property>/sim/input/selected/engine[0]</property>
   </condition>
   <command>property-assign</command>
   <property>/controls/starter[0]</property>
   <value type="bool">true</value>
  </binding>

Conditions always occur within a property subtree named "condition",
which is equivalent to an "and" condition.


2. Comparison Operators
-----------------------

The simplest condition is "property".  It resolves as true when the
specified property has a boolean value of true (i.e. non-zero, etc.)
and false otherwise.  Here is an example:

  <condition>
   <property>/sim/input/selected/engine[0]</property>
  </condition>

For more sophisticated tests, you can use the "less-than",
"less-than-equals", "greater-than", "greater-than-equals", "equals",
and "not-equals" comparison operators.  These all take two operands,
either two "property" operands or one "property" and one "value"
operand, and return true or false depending on the result of the
comparison.  The value of the second operand is always forced to the
type of the first; for example, if you compare a string and a double,
the double will be forced to a string and lexically compared.  If one
of the operands is a property, it is always assumed to be first.  Here
is an example of a comparison that is true only if the RPM of the
engine is less than 1500:

  <condition>
   <less-than>
    <property>/engines/engine[0]/rpm</property>
    <value>1500</value>
   </less-than>
  </condition>


3. Boolean Operators
--------------------

Finally, there are the regular boolean operators "and", "or", and
"not".  Each one surrounds a group of other conditions, and these can
be nested to arbitrary depths.  Here is an example:

  <condition>
   <and>
    <or>
     <less-than>
      <property>/engines/engine[0]/rpm</property>
      <value>1500</value>
     </less-than>
     <greater-than>
      <property>/engines/engine[0]/rpm</property>
      <value>2500</value>
     </greater-than>
    </or>
    <property>/engines/engine[0]/running</property>
   </and>
  </condition>

The top-level "condition" is an implicit "and".


4. Approximating if...else
--------------------------

There is no equivalent to the regular programming 'else' statement in
FlightGear conditions; instead, each condition separately must take
the others into account.  For example, the equivalent of

  if (x == 3) ... else if (y == 5) ... else ...

in FlightGear conditions is

  <condition>
   <equals>
    <property>/x</property>
    <value>3</value>
   </equals>
   <not>
    <equals>
     <property>/y</property>
     <value>5</value>
    </equals>
   </not>
  </condition>

and then

  <condition>
   <equals>
    <property>/y</property>
    <value>5</value>
   </equals>
   <not>
    <equals>
     <property>/x</property>
     <value>3</value>
    </equals>
   </not>
  </condition>

and then

  <condition>
   <not>
    <equals>
     <property>/x</property>
     <value>3</value>
    </equals>
   </not>
   <not>
    <equals>
     <property>/y</property>
     <value>5</value>
    </equals>
   </not>
  </condition>

It's verbose, but it works nicely within existing property-based
formats and provides a lot of flexiblity.


5. Syntax Summary
-----------------

Here's a quick syntax summary:

* <and>...</and>

  Contains one or more subconditions, all of which must be true.

* <condition>...</condition>

  The top-level container for conditions, equivalent to an "and" group

* <equals>...</equals>

  Contains two properties or a property and value, and is true if the
  properties have equivalent values.

* <not-equals>...</not-equals>

  Contains two properties or a property and value, and is true if the
  properties have different values.

* <greater-than>...</greater-than>

  Contains two properties or a property and a value, and is true if
  the second property or the value has a value greater than the first
  property.

* <greater-than-equals>...</greater-than-equals>

  Contains two properties or a property and a value, and is true if
  the second property or the value has a value greater than or equal
  to the first property.

* <less-than>...</less-than>

  Contains two properties or a property and a value, and is true if
  the second property or the value has a value less than the first
  property.

* <less-than-equals>...</less-than-equals>

  Contains two properties or a property and a value, and is true if
  the second property or the value has a value less than or equal
  to the first property.

* <not>...</not>

  Contains one subcondition, which must not be true.

* <not-equals>...</not-equals>

  Contains two properties or a property and value, and is true if the
  properties do not have equivalent values.

* <or>...</or>

  Contains one or more subconditions, at least one of which must be
  true.

* <property>...</property>

  The name of a property to test.

* <value>...</value>

  A literal value in a comparison.

--- End of README.conditions ---


--- Start of README.digitalfilters ---

COMMON SETTINGS
==============================================================================

Currently four types of digital filter implementations are supported. They all 
serve an individual purpose or are individual implementations of a specific 
filter type. Each filter implementation uses the same set of basic configuration 
tags and individual configuration elements. These individual elements are 
described in the section of the filter. 

The InputValue
==============================================================================
Each filter has several driving values, like the input value itself, sometimes 
a reference value, a gain value and others. Most of these input values can be
either a constant value or the value of a property. They all use the same syntax 
and will be referred to as InputValue in the remaining document.

The complete XML syntax for a InputValue is

<some-element>
  <condition>
    <!-- any condition as defined in README.conditions -->
  </condition>
  <property>/some/property/name</property>
  <value>0.0</value>
  <scale>1.0</value>
  <offset>0.0</offset>
  <max>infinity</max>
  <min>-infinity<min>
  <abs>false</abs>
  <period>
    <min>-180.0</min>
    <max>-180.0</max>
  </period>
</some-element>

The enclosing element <some-element> is the element defined in each filter, like 
<input>, <u_min>, <reference> etc. These elements will be described later.
The value of the input is calculated based on the given value, scale and offset as
value * scale + offset 
and the result is clipped to min/max, if given.
With the full set of given elements, the InputValue will initialize the named 
property to the value given, reduced by the given offset and reverse scaled by 
the given scale.

Example:
<input>
  <property>/controls/flight/rudder</property>
  <value>0.0</value>
  <scale>0.5</scale>
  <offset>0.5</offset>
</input>

Will use the property /controls/flight/rudder as the input of the filter. The 
property will be initialized at a value of zero and since the property usually is
in the range [-1..+1], the the value of <input> will be in the range 
(-1)*0.5+0.5 to (+1)*0.5+0.5 which is [0..1].

The default values for elements not given are:
<value/> : 0.0
<scale/> : 1.0
<offset/>: 0.0
<property/> : none
<min/>   : unclipped
<max/>   : unclipped
<abs/>   : false

Some examples:
<input>
  <property>/position/altitude-ft</property>
  <scale>0.3048</scale>
</input>
Gives the altitude in meters. No initialization of the property is performed, no 
offset applied.

<reference>
  <value>0.0</value>
</reference>
A constant reference of zero.

A abbreviated method of defining values exist for using a just constant or a 
property. The above example may be written as
<reference>0.0</reference>
Or if the reference is defined in a property
<reference>/some/property/name</reference>
No initialization, scaling or offsetting is performed here.
The logic behind this is: If the text node in the element (the text between the 
opening and closing tag) can be converted to a double value, it will be interpreted 
as a double value. Otherwise the text will
be interpreted as a property name.
Examples:
<reference>3.1415927</reference>             - The constant of PI (roughly)
<reference>/position/altitude-ft</reference> - The property /position/altitude-ft
<reference>3kings</reference>                - The constant 3. The word kings is 
                                               ignored
<reference>food4less</reference>             - The property food4less

The <property> element may also be written as <prop> for backward compatibility.

There may be one or more InputValues for the same input of a filter which may be 
bound to conditions. Each InputValue will have its condition checked in the order 
of InputValues given in the configuration file. The first InputValue that returns 
true for its condition will be evaluated. Chaining a number of InputValues with 
conditions and an unconditioned InputValue works like the C language equivalent
if( condition ) {
  // compute value of first element
} else if( condition2 ) {
  // compute value of second element
} else if( condition3 ) {
  // compute value of third element
} else {
  // compute value of last element
}

Example: Set the gain to 3.0 if /autopilot/locks/heading equals dg-heading-hold or
2.0 otherwise.
<digital-filter>
  <gain>
    <condition>
      <equals>
        <property>/autopilot/locks/heading</property>
        <value>dg-heading-hold</value>
      </equals>
    </condition>
    <value>3.0</value>
  <gain>
  <!-- Hint: omit a condition here as a fallthru else condition -->
  </gain>
    <value>2.0</value>
  <gain>
<digital-filter>

If the element <abs> is used and set to the value "true", only the absolute 
value of the input (the positive part) is used for further computations. The 
abs function is applied after all other computations are completed.
    
OutputValue           
==============================================================================
Each filter drives one to many output properties. No scaling or offsetting is 
implemented for the output value, these should be done in the filter itself.
The output properties are defined in the <output/> element by adding <property/> 
elements within the <output/> element. For just a single output property, the 
<property/> element may be ommited. For backward compatibility, <property/> may 
be replaced by <prop/>.  Non-existing properties will be created with type double.

Example: (Multiple output properties)
<output>
  <property>/some/output/property</property>
  <property>/some/other/output/property</property>
  <property>/and/another/output/property</property>
</output>

Example: a single output property
<output>/just/a/single/property</output>

Other Common Settings
==============================================================================
<name>        String      The name of the filter. Used for debug purpose.
Example:
<name>pressure rate filter</name>

<debug>       Boolean     If true, this filter puts out debug information when 
                          updated. Example: <debug>false</debug>

<input>       InputValue  The input property driving the filter. 
                          Refer to InputValue for details.

<reference>   InputValue  The reference property for filter that need one. 
                          Refer to InputValue for details.

<output>      Complex     Each filter can drive one to many output properties. 
                          Refer to OutputValue for details.

<u_min>       InputValue  This defines the optional minimum and maximum value the 
<u_max>                   output is clamped to. If neither <u_min> nor <u_max> 
                          exists, the output is only limited by the internal limit 
                          of double precision float computation.  If either <u_min> 
                          or <u_max> is given, clamping is activated. A missing min 
                          or max value defaults to 0 (zero).
                          Note: <u_min> and <u_max> may also occour within a <config> 
                          element. <min> and <max> may be used as a substitude for 
                          the corresponding u_xxx element.
<period>      Complex     Define a periodical input or output value. The phase width 
                          is defined by the child elements <min> and <max> which are 
                          of type InputValue

Example: Limit the pilot's body temperature to a constant minimum of 36 and a 
maximum defined in /pilots/max-body-temperature-degc, initialized to 40.0
<u_max>
  <prop>/pilots/max-body-temperature-degc</prop>
  <value>40.0</
</u_max>
<min>
  <value>36.0</value>
</min

Implicit definition of the minimum value of 0 (zero) and defining a maximum of 100.0
<config>
  <u_max>100.0</u_max>
</config>

This defines the input or output as a periodic value with a phase width of 360, like 
the compass rose.  Any value reaching the filter's input or leaving the filter at the 
output will be transformed to fit into the given range by adding or substracting one 
phase width of 360. Values of -270, 90 or 450 applied to this periodical element will 
always result in +90. A value of 630, 270 or -90 will be normalized to -90 in the 
given example.
<period>
  <min>-180.0</min>
  <max>180.0</max>
</period>


<enable>      Complex     Define a condition to enable or disable the filter. For 
                          disabled filters, no output computations are performed. 
                          Only enabled filters fill the output properties. The 
                          default for undefined conditions is enabled.
                          Several way exist to define a condition. The most simple 
                          case is checking a boolean property. For this, just a 
                          <prop> element naming this boolean property is needed. 
                          The boolean value of the named property defines the 
                          enabled state of the filter. To compare the value of a 
                          property with a constant, a <prop> and a <value> element 
                          define the property name and the value to be compared. 
                          The filter is enabled, if the value of the property equals 
                          the given value. A case sensitive string compare is 
                          performed here.
                          To define more complex conditions, a <condition> element 
                          may be used to define any condition described in 
                          README.conditions.  If a <condition> element is present 
                          and if it contains a valid condition, this conditions has 
                          precedence over a given <prop>/<value> condition.
                          The child element <honor-passive>, a boolean flag, may be 
                          present within the <enable> element. If this element is 
                          true, the property /autopilot/locks/passive-mode is checked
                          and if it is true, the filter output is computed, but the 
                          output properties are not set.  The default for 
                          honor-passive is false
Example: Check a boolean property, only compute this filter if gear-down is true and 
         /autopilot/locks/passive-mode is false
<enable>
  <prop>/gear/gear-down</prop>
  <honor-passive>true</honor-passive>
</enable>

Check a property for equality, only compute this filter if the autopilot is locked 
in heading mode.
<enable>
  <prop>/autopilot/locks/heading</prop>
  <value>dg-heading-hold</value>
</enable>

Use a complex condition, only compute this filter if the autopilot is serviceable 
and the lock is either dg-heading-hold or nav1-heading-hold
<enable>
  <condition>
    <property>/autopilo/serviceable</property>
    <or>
      <equals>
        <property>/autopilot/locks/heading</property>
        <value>dg-heading-hold</value>
      </equals>
      <equals>
        <property>/autopilot/locks/heading</property>
        <value>nav1-heading-hold</value>
      </equals>
    </or>
  </condition>
</enable>

INDIVIDUAL FILTER CONFIGURATION
==============================================================================

Digital Filter                          

Six different types of digital filter can be configured inside the autopilot
configuration file. There are four low-pass filter types and two gain filter
types.

The low-pass filter types are:

* Exponential
* Double exponential
* Moving average
* Noise spike filter

The gain filter types are:

* gain
* reciprocal

To add a digital filter, place a <filter> element under the root element. Next to 
the global configuration elements described above, the following elements configure
the digital filter:
<filter-time> InputValue  This tag is only applicable for the exponential and
                          double-exponential filter types. It controls the 
                          bandwidth  of the filter. The bandwidth in Hz of the 
                          filter is: 1/filter-time. So a low-pass filter with a 
                          bandwidth of 10Hz would have a filter time of 1/10 = 0.1

<samples>     InputValue  This tag only makes sense for the moving-average filter. 
                          It says how many past samples to average.

<max-rate-of-change> 
              InputValue  This tag is applicable for the noise-spike filter. 
                          It says how much the value is allowed to change per 
                          second.

<gain>        InputValue  This is only applicable to the gain and reciprocal filter
                          types. The output for gain filter is computed as input*gain 
                          while  the reciprocal filter computes output as gain/input 
                          for input values != 0 (zero). Gain may be a constant, a 
                          property name defined by a <prop> element within the <gain> 
                          element or a  property name initialized to a value by using 
                          a <prop> and <value> element.
          
Example: a pressure-rate-filter implemented as a double exponential low pass filter
         with a bandwith of 10Hz

  <filter>
    <name>pressure-rate-filter</name>
    <debug>false</debug>
    <type>double-exponential</type>
    <enable>
      <prop>/autopilot/locks/pressure-rate-filter</prop>
      <value>true</value>
    </enable>
    <input>/autopilot/internal/pressure-rate</input>
    <output>/autopilot/internal/filtered-pressure-rate</output>
    <filter-time>0.1</filter-time>
  </filter>

This will filter the pressure-rate property. The output will be to a new
property called filtered-pressure-rate. You can select any numerical property
from the property tree. The input property will not be affected by the filter,
it will stay the same as it would if no filter was configured.

Example 2:

  <filter>
    <name>airspeed elevator-trim gain reciprocal filter</name>
    <debug>false</debug>
    <enable>
      <prop>/autopilot/locks/airspeed-elevator-trim-gain</prop>
      <value>true</value>
    </enable>
    <type>reciprocal</type>
    <gain>
      <prop>/autopilot/settings/elevator-trim-airspeed-reciprocal-gain</prop>
      <value>7</value>
    </gain>
    <input>/velocities/airspeed-kt</input>
    <output>/autopilot/internal/elevator-trim-gain</output>
    <u_min>0.005</u_min>
    <u_max>0.02</u_max>
  </filter>

This will use the /velocities/airspeed-kt property to produce a gain factor
that reduces as airspeed increases.  At airspeeds up to 350kt the gain will
be clamped to 0.02, at 700kt the gain will be 0.01 and at 1400kt the gain will
be 0.005.  The gain will be clamped to 0.005 for airspeeds > 1400kt.

The output from this filter could then be used to control the gain in a PID
controller:

  <pid-controller>
    <name>Pitch hold</name>
    <debug>false</debug>
    <enable>
      <prop>/autopilot/locks/pitch</prop>
      <value>true</value>
    </enable>
    <input>
      <prop>/orientation/pitch-deg</prop>
    </input>
    <reference>
      <prop>/autopilot/settings/target-pitch-deg</prop>
    </reference>
    <output>
      <prop>/autopilot/internal/target-elevator-trim-norm</prop>
    </output>
    <config>
      <Ts>0.05</Ts>
      <Kp>
        <prop>/autopilot/internal/elevator-trim-gain</prop>
        <value>0.02</value>
      </Kp>
      <beta>1.0</beta>
      <alpha>0.1</alpha>
      <gamma>0.0</gamma>
      <Ti>2.0</Ti>
      <Td>0.2</Td>
      <u_min>-1.0</u_min>
      <u_max>1.0</u_max>
    </config>
  </pid-controller>

IMPORTANT NOTE: The <Kp> tag in PID controllers has been revised to operate in
the same way as the <gain> elements in filters.  However, the original format
of <Kp> will continue to function as before i.e. <Kp>0.02</Kp> will specify a
fixed and unalterable gain factor, but a warning message will be output.

The gain type filter is similar to the reciprocal filter except that the gain
is applied as a simple factor to the input.
-------------------------------------------------------------------------------
Parameters

<name> The name of the filter. Give it a sensible name!

<debug> If this tag is set to true debugging info will be printed on the
console.

<enable> Encloses the <prop> and <value> tags which are used to enable or
disable the filter. Instead of the <prop> and <value> tags, a <condition>
tag may be used to define a condition. Check README.conditions for more
details about conditions.  Defaults to enabled if unspecified.

<type> The type of filter. This can be exponential, double-exponential,
moving-average, noise-spike, gain or reciprocal.

<input> The input property to be filtered. This should of course be a
numerical property, filtering a text string or a boolean value does not make
sense.

<output> The filtered value. You can make up any new property.

<u_min> The minimum output value from the filter.  Defaults to -infinity.

<u_max> The maximum output value from the filter.  Defaults to +infinity.

These are the tags that are applicable to all filter types. The following tags
are filter specific.

<filter-time> This tag is only applicable for the exponential and
double-exponential filter types. It controls the bandwidth of the filter. The
bandwidth in Hz of the filter is: 1/filter-time. So a low-pass filter with a
bandwidth of 10Hz would have a filter time of 1/10 = 0.1

<samples> This tag only makes sense for the moving-average filter. It says how
many past samples to average.

<max-rate-of-change> This tag is applicable for the noise-spike filter. Is
says how much the value is allowed to change per second.

<gain>  This, and it's enclosed <prop> and <value> tags, are only applicable to
the gain and reciprocal filter types.  The <prop> tag specifies a property node
to hold the gain value and the <value> tag specifies an initial default value.
The gain defaults to 1.0 if unspecified.

The output from the gain filter type is: input * gain.
The output from the reciprocal filter type is: gain / input.

The gain can be changed during run-time by updating the value in the property
node.

--- End of README.digitalfilters ---


--- Start of README.effects ---

Effects
-------

Effects describe the graphical appearance of 3d objects and scenery in
FlightGear. The main motivation for effects is to support OpenGL
shaders and to provide different implementations for graphics hardware
of varying capabilities. Effects are similar to DirectX effects files
and Ogre3D material scripts.

An effect is a property list. The property list syntax is extended
with new "vec3d" and "vec4d" types to support common computer graphics
values. Effects are read from files with a ".eff" extension or can be
created on-the-fly by FlightGear at runtime.  An effect consists of a
"parameters" section followed by "technique" descriptions.  The
"parameters" section is a tree of values that describe, abstractly,
the graphical characteristics of objects that use the effect. Techniques
refer to these parameters and use them to set OpenGL state or to set
parameters for shader programs. The names of properties in the
parameter section can be whatever the effects author chooses, although
some standard parameters  are set by FlightGear itself. On the other
hand, the properties in the techniques section are all defined by the
FlightGear.

Techniques
----------

A technique can contain a predicate that describes the OpenGL
functionality required to support the technique. The first
technique with a valid predicate in the list of techniques is used
to set up the graphics state of the effect. A technique with no
predicate is always assumed to be valid. The predicate is written in a
little expression language that supports the following primitives:

and, or, equal, less, less-equal
glversion - returns the version number of OpenGL
extension-supported - returns true if an OpenGL extension is supported
property - returns the boolean value of a property
float-property - returns the float value of a property, useful inside equal, less
                or less-equal nodes
shader-language - returns the version of GLSL supported, or 0 if there is none.

The proper way to test whether to enable a shader-based technique is:
  <predicate>
    <and>
    <property>/sim/rendering/shader-effects</property>
    <less-equal>
      <value type="float">1.0</value>
      <shader-language/>
    </less-equal>
    </and>
  </predicate>

There is also a property set by the user to indicate what is the level
of quality desired. This level of quality can be checked in the predicate
like this :
    <predicate>
      <and>
        <property>/sim/rendering/shader-effects</property>
  <less-equal>
    <value type="float">2.0</value>
    <float-property>/sim/rendering/quality-level</float-property>
  </less-equal>
  <!-- other predicate conditions -->
      </and>
    </predicate>

The range of /sim/rendering/quality-level is [0..5]
 * 2.0 is the threshold for relief mapping effects,
 * 4.0 is the threshold for geometry shader usage.

A technique can consist of several passes. A pass is basically an Open
Scene Graph StateSet. Ultimately all OpenGL and OSG modes and state
attributes  will be accessable in techniques. State attributes -- that
is, technique properties that have children and are not just boolean
modes -- have an <active> parameter which enables or disables the
attribute. In this way a technique can declare parameters it needs,
but not enable the attribute at all if it is not needed; the decision
can be based on a parameter in the parameters section of the
effect. For example, effects that support transparent and opaque
geometry could have as part of a technique:

    <blend>
    <active><use>blend/active</use></active>
    <source>src-alpha</source>
    <destination>one-minus-src-alpha</destination>
    </blend>

So if the blend/active parameter is true blending will be activated
using the usual blending equation; otherwise blending is disabled.

Values of Technique Attributes
------------------------------

Values are assigned to technique properties in several ways:

  * They can appear directly in the techniques section as a
    constant. For example:
    <uniform>
      <name>ColorsTex</name>
      <type>sampler-1d</type>
      <value type="int">2</value>
    </uniform>
    * The name of a property in the parameters section can be
    referenced using a "use" clause. For example, in the technique
    section:
    <material>
      <ambient><use>material/ambient</use></ambient>
    </material>
    Then, in the parameters section of the effect:
    <parameters>
      <material>
        <ambient type="vec4d">0.2 0.2 0.2 1.0</ambient>
      </material>
    </parameters>

    It's worth pointing out that the "material" property in a
    technique specifies part of OpenGL's state, whereas "material"
    in the parameters section is just a name, part of a
    hierarchical namespace.

    * A property in the parameters section doesn't need to contain
    a constant value; it can also contain a "use" property. Here
    the value of the use clause is the name of a node in an
    external property tree which will be used as the source of a
    value. If the name begins with '/', the node is in
    FlightGear's global property tree; otherwise, it is in a local
    property tree, usually belonging to a model [NOT IMPLEMENTED
    YET]. For example:
    <parameters>
      <chrome-light><use>/rendering/scene/chrome-light</use></chrome-light>
    </parameters>
    The type is determined by what is expected by the technique
    attribute that will ultimately receive the value. [There is
    no way to get vector values out of the main property system
    yet; this will be fixed shortly.] Values that are declared
    this way are dynamically updated if the property node
    changes.

OpenGL Attributes
-----------------

The following attributes are currently implemented in techiques:
alpha-test - children: active, comparison, reference
     Valid values for comparision:
       never, less, equal, lequal, greater, notequal, gequal,
       always

alpha-to-coverage - true, false

blend - children: active, source, destination, source-rgb,
     source-alpha, destination-rgb, destination-alpha
     Each operand can have the following values:
       dst-alpha, dst-color, one, one-minus-dst-alpha,
       one-minus-dst-color, one-minus-src-alpha,
       one-minus-src-color, src-alpha, src-alpha-saturate,
       src-color, constant-color, one-minus-constant-color,
       constant-alpha, one-minus-constant-alpha, zero

cull-face - front, back, front-back

lighting - true, false

material - children: active, ambient, ambient-front, ambient-back, diffuse,
     diffuse-front, diffuse-back, specular, specular-front,
     specular-back, emissive, emissive-front, emissive-back, shininess,
     shininess-front, shininess-back, color-mode

polygon-mode - children: front, back
    Valid values:
        fill, line, point

program
    vertex-shader
    geometry-shader
    fragment-shader
    attribute
    geometry-vertices-out - integer, max number of vertices emitted by geometry
                            shader
    geometry-input-type - points, lines, lines-adjacency, triangles,
                          triangles-adjacency
    geometry-output-type - points, line-strip, triangle-strip

render-bin - (OSG) children: bin-number, bin-name

rendering-hint - (OSG) opaque, transparent

shade-model - flat, smooth

texture-unit - has several child properties:
  unit - The number of an OpenGL texture unit
  point-sprite - true, false - Whether this should rendered as a point-sprite
  type - This is either an OpenGL texture type or the name of a
    builtin texture. Currently supported OpenGL types are 1d, 2d,
    3d which have the following common parameters:
      image (file name)
      filter - nearest, linear, [nearest|linear]-mipmap-[nearest|linear]
      mag-filter - nearest, linear, [nearest|linear]-mipmap-[nearest|linear]
      wrap-s - clamp, clamp-to-border, clamp-to-edge, mirror, repeat
      wrap-t - clamp, clamp-to-border, clamp-to-edge, mirror, repeat
      wrap-r - clamp, clamp-to-border, clamp-to-edge, mirror, repeat
      mipmap-control - control the mipmap on a per-channel basis.  Children:
        function-r - auto, average, sum, product, min, max
        function-g - auto, average, sum, product, min, max
        function-b - auto, average, sum, product, min, max
        function-a - auto, average, sum, product, min, max

    The following built-in types are supported:
      white - 1 pixel white texture
      noise - a 3d noise texture. (size parameter defines size of texture)
      light-sprite - a procedurally generated sprite suitable for point lights
      cubemap - build a cube-map.  Children:
        images - build from 6 images. Children: [positive|negative]-[x|y|z]
        image - build from a single cross-image

  environment
    mode - add, blend, decal, modulate, replace
    color

  texenv-combine
    combine-[rgb|alpha] - replace, modulate, add, add-signed, interpolate, subtract, dot3-rgb, dot3-rgba
    source[0|1|2]-[rgb|alpha] - constant, primary_color, previous, texture, texture[0-7]
    operand[0|1|2]-[rgb|alpha] -src-color, one-minus-src-color, src-alpha, one-minus-src-alpha
    scale-[rgb|alpha]
    constant-color

  texgen
    mode - object-linear, eye-linear, sphere-map, normal-map, reflection-map
    planes - s, t, r, q

uniform
    name
    type - float, float-vec3, float-vec4, sampler-1d, sampler-2d,
    sampler-3d

vertex-program-two-side - true, false

vertex-program-point-size - true, false

Inheritance
-----------

One feature not fully illustrated in the sample below is that
effects can inherit from each other. The parent effect is listed in
the "inherits-from" form. The child effect's property tree is
overlaid over that of the parent. Nodes that have the same name and
property index -- set by the "n=" attribute in the property tag --
are recursively merged. Leaf property nodes from the child have
precedence.  This means that effects that inherit from the example
effect below could be very short, listing just new
parameters and adding nothing to the techniques section;
alternatively, a technique could be altered or customized in a
child, listing (for example) a different shader program. An example
showing inheritance Effects/crop.eff, which inherits some if its
values from Effects/terrain-default.eff.

FlightGear directly uses effects inheritance to assign effects to 3D
models and terrain. As described below, at runtime small effects are
created that contain material and texture values in a "parameters"
section. These effects inherit from another effect which references
those parameters in its "techniques" section. The derived effect
overrides any default values that might be in the base effect's
parameters section.

Generate
--------

Often shader effects need tangent vectors to work properly. These
tangent vectors, usually called tangent and binormal, are computed
on the CPU and given to the shader as vertex attributes. These
vectors are computed on demand on the geometry using the effect if
the 'generate' clause is present in the effect file. Exemple :

  <generate>
    <tangent type="int">6</tangent>
    <binormal type="int">7</binormal>
    <normal type="int">8</normal>
  </generate>

Valid subnodes of 'generate' are 'tangent', 'binormal' or 'normal'.
The integer value of these subnode is the index of the attribute
that will hold the value of the vec3 vector.

The generate clause is located under PropertyList in the xml file.

In order to be available for the vertex shader, these data should
be bound to an attribute in the program clause, like this :

  <program>
    <vertex-shader>my_vertex_shader</vertex-shader>
    <attribute>
      <name>my_tangent_attribute</name>
      <index>6</index>
    </attribute>
    <attribute>
      <name>my_binormal_attribute</name>
      <index>7</index>
    </attribute>
  </program>

attribute names are whatever the shader use. The index is the one
declared in the 'generate' clause. So because generate/tangent has
value 6 and my_tangent_attribute has index 6, my_tangent_attribute
holds the tangent value for the vertex.

Default Effects in Terrain Materials and Models
-----------------------------------------------

Effects for terrain work in this way: for each material type in
materials.xml an effect is created that inherits from a single default
terrain effect, Effects/terrain-default.eff. The parameters section of
the effect is filled in using the ambient, diffuse, specular,
emissive, shininess, and transparent fields of the material. The
parameters image, filter, wrap-s, and wrap-t are also initialized from
the material xml. Seperate effects are created for each texture
variant of a material.

Model effects are created by walking the OpenSceneGraph scene graph
for a model and replacing nodes (osg::Geode) that have state sets with
node that uses an effect instead. Again, a small effect is created
with parameters extracted from OSG objects; this effect inherits, by
default, from Effects/model-default.eff. A larger set of parameters is
created for model effects than for terrain because there is more
variation possible from the OSG model loaders than from the terrain
system. The parameters created are:

  * material active, ambient, diffuse, specular, emissive,
    shininess, color mode
    * blend active, source, destination
    * shade-model
    * cull-face
  * rendering-hint
  * texture type, image, filter, wrap-s, wrap-t

Specifying Custom Effects
-------------------------

You can specify the effects that will be used by FlightGear as the
base effect when it creates terrain and model effects.

In the terrain materials.xml, an "effect" property specifies the name
of the model to use.

In model .xml files, A richer syntax is supported. [TO BE DETERMINED]

Material animations will be implemented by creating a new effect
that inherits from one in a model, overriding the parameters that
will be animated.

Examples
--------

The Effects directory contains the effects definitions; look there for
examples. Effects/crop.eff is a good example of a complex effect.

Application
-----------

To apply an effect to a model or part of a model use:

  <effect>
    <inherits-from>Effects/light-cone</inherits-from>
    <object-name>Cone</object-name>
  </effect>

where <inherits-from> </inherits-from> contains the path to the effect you want to
apply. The effect does not need the file extension.

NOTE:

Chrome, although now implemented as an effect, still retains the old method of
application:

  <animation>
      <type>shader</type>
      <shader>chrome</shader>
      <texture>glass_shader.png</texture>
      <object-name>windscreen</object-name>
  </animation>

in order to maintain backward compatibility.

Model Hierarchy
---------------

There are a large number of techniques used by the models, with complex
inheritance.  Here is a handy list of the techniques, what they are for, and
where the base technique is defined

Non-Compositor

# Where Defined                Summary
4 model-combined.xml           ALS, quality>0, model>0
5 model-defaults.xml           Base ALS
7 model-combined-deferred.xml  Rembrandt, model>0
9  model-combined.xml          quality>0, model>0
10 model-defaults.xml          Base Rembrandt
11 model-defaults.xml          Generic shaders, quality>0
13 model-defaults.xml          Fallback - no predicate


Compositor

# Where Defined                Summary
4 model-combined.xml          quality>0, model>0
7 model-combined.xml          ALS, quality>0, model>0
8 model-default.xml          generic>0, quality>0
9 model-default.xml          Fallback - no predicate
19 model-default.xml         ALS, basic


Scenery Hierarchy
-----------------

Compositor

# Where defined          Summary
8 terrain-default.xml    quality>0, generic>0
9 terrain-default.xml    Fallback - no predicate
17 terrain-default.xml   ALS, landmass=6, transition=6
18 terrain-default.xml   ALS, landmass>3, transition>2
19 terrain-default.xml   ALS, basic

--- End of README.effects ---


--- Start of README.electrical ---

Specifying and Configuring and Aircraft Electrical System
=========================================================

Written by Curtis L. Olson <curt@flightgear.org>

February 3, 2003 - Initial revision.


Introduction
============

The FlightGear electrical system model is an approximation.  We don't
model down to the level of individual electrons, but we do try to
model a rich enough subset of components so that a realistic (from the
pilot's perspective) electrical system may be implemented.  We try to
model enough of the general flow so that typical electrical system
failures can be implimented and so that the pilot can practice
realistic troubleshooting techniques and learn the basic structure and
relationships of the real aircraft electrical system.

An electrical system can be built from 4 major components: suppliers,
buses, outputs, and connectors.  Suppliers are things like batteries
and generators.  Buses collect input from multiple suppliers and feed
multiple outputs.  Outputs are not strictly necessary, but are
included so we can name generic output types and provide a consistent
naming scheme to other FlightGear subsystems.  Finally connectors
connect a supplier to a bus, or a bus to an output, and optionally can
specify a switch property (either a physical switch or a circuit
breaker.)

At run time, the structure specified in the electrical system config
file is parsed and a directional graph (in the computer science sense)
is built.  Each frame, the current is propagated through the system,
starting at the suppliers, flowing through the buses, and finally to
the outputs.  The system follows the path of connectors laid out in
the config file and honors the state of any connector switch.


Suppliers
=========

A supplier entry could look like the following:

  <supplier>
    <name>Battery 1</name>
    <prop>/systems/electrical/suppliers/battery[0]</prop>
    <kind>battery</kind>
    <volts>24</volts>
    <amps>60</amps>   <!-- WAG -->
  </supplier>

<name> can be anything you choose to call this entry.
<prop> is the name of a property that will be updated with the state
       of this supplier.
<kind> can be "battery", "alternator", or "external".
<volts> specifies the volts of the source
<amps> specifies the amps of the source

Currently <volts> and <amps> are not really modeled in detail.  This
is more of a place holder for the future.

For alternators, you must additionally specify:

    <rpm-source>/engines/engine[0]/rpm</rpm-source>

The value of the rpm source determines if the generator is able to
produce power or not.


Buses
=====

A bus entry could look like the following:

  <bus>
    <name>Essential/Cross Feed Bus</name>
    <prop>/systems/electrical/outputs/bus-essential</prop>
    <prop>/systems/electrical/outputs/annunciators</prop>
    <prop>/systems/electrical/outputs/master-switch</prop>
  </bus>

<name> is whatever you choose to call this bus

You can have an arbitrary number of <prop> entries.  Each entry is the
name of a property that will be updated with the value of the current
at that bus.  This allows you to wire devices directly to the bus but
does not allow you to insert a switch or circuit breaker in between.
See "Outputs" and "Connectors" if you want to do that.


Outputs
=======

An output entry could look like the following:

  <output>
    <name>Starter 1 Power</name>
    <prop>/systems/electrical/outputs/starter[0]</prop>
  </output>

An output isn't entirely unlike a bus, but it's nice conceptually to
have a separate entity type.  This enables us to specify a common set
of output property names so that other subsystems can automatically
work with any electrical system that follows the same conventions.  An
output lives on the other side of a switch, so this is how you can
wire in cockpit switches to model things like fuel pump power,
avionics master switch, or any other switch on the panel.

<name> is whatever you choose to call this bus

You can have an arbitrary number of <prop> entries.  Each entry is the
name of a property that will be updated with the value of the current
at that bus.  This allows you to wire devices directly to the bus but
does not allow you to insert a switch or circuit breaker in between.
See "Outputs" and "Connectors" if you want to do that.

Other FlightGear subsystems can monitor the property name associated
with the various outputs to decide how to render an instrument,
whether to run the fuel pump, whether to spin a gyro, or any other
subsystem that cares about electrical power.


Connectors
==========

An connector entry could look like the following:

  <connector>
    <input>Alternator 1</input>
    <output>Virtual Bus 1</output>
    <switch>/controls/switches/master-alt</switch>
    <initial-state>off</initial-state>  <!-- optional tag -->
  </connector>

A connector specifies and input, and output, and any number of
switches that are wired in series.  In other words, all switches need
to be true/on in order for current to get from the input to the output
of the connector.

<input> specifies the <name> of the input.  Typically you would
specify a "supplier" or a "bus".

<output> specifies the <name> of the output.  Typically you would
specify a bus or an output.

You can have an arbitrary number of <switch> entries.  The switches
are wired in series so all of them need to be on (i.e. true) in order
for current to pass to the output.

Note: by default the system forces any listed switches to be true.
The assumption is that not every aircraft or cockpit may impliment
every available switch, so rather than having systems be switched off,
with no way to turn them on, we default to switched on.

This is a problem however with the starter switch which we want to be
initialized to "off".  To solve this problem you can specify
<initial-state>off</initial-state> or
<initial-state>on</initial-state> Switches default to on, so you
really only need to specify this tag if you want the connector's
switch to default to off.


Summary
=======

The electrical system has a lot of power and flexibility to model a
variety of electrical systems.  However, it is not yet perfect or
finished.  One major weakness is that it doesn't yet model degraded
battery or generator power, and it doesn't model the "charge" of the
batteries in case of a generator failure.

--- End of README.electrical ---


--- Start of README.embedded-resources ---

-*- coding: utf-8; fill-column: 72; -*-

The Embedded Resources System
=============================

This document gives an overview of FlightGear's embedded resources
system and related classes. For specific information on the C++
functions, the reference documentation is in the corresponding header
files.


Contents
--------

1. The CharArrayStream and ZlibStream classes
2. The embedded resources system
3. About the XML resource declaration files
4. The EmbeddedResourceProxy class


Introduction
------------

The embedded resources system allows FlightGear to use data from files
without relying on FG_ROOT to be set. This can be used, for instance, to
grab the contents of XML files at FG build time, from any repository[1],
and use said contents in the C++ code. The term embedded is used to
avoid confusion with the ResourceProvider and ResourceManager classes
provided by SimGear, which have nothing to do with the system described
here.

The embedded resources system relies on classes present in
simgear/io/iostreams/{zlibstream.cxx,CharArrayStream.cxx}, which were
implemented as a way to address a concern that embedding a few XML files
in the fgfs binary could use precious memory. The resource compiler
(fgrcc) compresses resources before writing them in C++ form---except
for some extensions, and it's configurable on a per-resource basis
anyway. Then, the EmbeddedResourceManager instance, which lives in the
fgfs process, can decompress them on-the-fly, incrementally,
transparently. So, there is really no reason to worry about memory
consumption, even for several dozens of XML files.

fgrcc is the resource compiler: it turns arbitrary files into C++ code
the EmbeddedResourceManager can make use of, in order to serve the
files' contents at runtime. It is named this way, because it fulfills
the same role as Qt's rcc tool. It supports a thin superset of the
XML-based format used by rcc for declaring resources[2][3].
'fgrcc --help' gives a lot of info.


1) The CharArrayStream and ZlibStream classes
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The CharArrayStream* files in simgear/io/iostreams/ implement
CharArrayStreambuf and related IOStreams classes for working with char
arrays, namely:
  - CharArrayStreambuf    subclass of std::streambuf      stream buffer
  - ROCharArrayStreambuf  subclass of CharArrayStreambuf  stream buffer
  - CharArrayIStream      subclass of std::istream        input stream
  - CharArrayOStream      subclass of std::ostream        output stream
  - CharArrayIOStream     subclass of std::iostream       input/output stream

(in the 'simgear' namespace, of course)

CharArrayStreambuf is a stream buffer class allowing to read from, and
write to char arrays (std::strstream has been deprecated since C++98).
Contrary to std::strstream, this class does no dynamic allocation: it is
very simple, strictly staying for both reads and writes within the
bounds of the buffer specified in its constructor. Contrary to
std::stringstream, CharArrayStreambuf allows one to work on an array of
char (that could be static data, on the stack, whatever) without having
to make a whole copy of it.

ROCharArrayStreambuf is a read-only subclass of CharArrayStreambuf
(useful for const-correctness). CharArrayIStream, CharArrayOStream and
CharArrayIOStream are very simple convenience stream classes using
either CharArrayStreambuf or ROCharArrayStreambuf as their associated
stream buffer class.

While these classes can be of general-purpose usefulness, the particular
reason they have been written for is to make the embedded resources
system clean and memory-friendly. Concretely, this system supports both
compressed and uncompressed resources, all of which can be read from
their respective static arrays like this (think pipelines):

static char array
(uncompressed       --------------->      data available via an std::istream
 resource)          CharArrayIStream         or std::streambuf interface
                 or ROCharArrayStreambuf

static char array
(compressed       ---------------> compressed data ------------------->    ditto
 resource)        CharArrayIStream               ZlibDecompressorIStream
                                              or ZlibDecompressorIStreambuf

where ditto = uncompressed data available via an std::istream or
              std::streambuf interface

So, whether the resource data stored in static arrays by fgrcc is
compressed or not, end-user code can read it in uncompressed form using
an std::istream or std::streambuf interface, which means the resource
never needs to be copied in memory a second time. This is particularly
interesting with compressed resources, because:

  1) The in-memory static data is much smaller in general than the
     uncompressed contents, and it's the only one we really have to
     pay for if one uses these stream-based interfaces.

  2) The data is transparently decompressed on-demand as the end-user
     code reads from the ZlibDecompressorIStream or
     ZlibDecompressorIStreambuf instance.

In other words, these CharArrayStream classes complement the ones in
zlibstream.cxx and make it easy to implement all kinds of pipelines to
incrementally read or write, and possibly on-the-fly compress or
decompress data from or to in-memory buffers (cf.
writeCompressedDataToBuffer() in
simgear/simgear/embedded_resources/embedded_resources_test.cxx, or
ResourceCodeGenerator::writeEncodedResourceContents() in
flightgear/src/EmbeddedResources/fgrcc.cxx for examples).

Since all of these provide standard IOStreams interfaces, they can be
easily plugged into existing code. For instance, readXML() in
simgear/simgear/xml/easyxml.cxx and readProperties() in
simgear/props/props_io.cxx can incrementally read and parse data from an
std::istream instance, and thus are able to directly read from a
resource containing the compressed version of an XML file.

This incremental stuff is of course really interesting with large
resources... which probably won't be used in FlightGear, in order not to
waste RAM[4][5]. The EmbeddedResourceManager also has a getString()
method to simply get an std::string when you don't care about the fact
that this operation, by std::string design, will necessarily make a copy
of the whole resource contents (in uncompressed form in the case of a
compressed resource). This getString() method should be convenient and
quite acceptable for reasonably-sized resources.

Finally, all of these classes---CharArray*Stream*, the classes in
zlibstream.cxx, the EmbeddedResourceManager and related classes---can
handle text and binary data in exactly the same way (std::string doesn't
care, and neither do the other classes).


2) The embedded resources system
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The embedded resources system works this way:

  (1) The fgrcc resource compiler reads an XML file which has almost the
      same syntax[2] as Qt's .qrc files[3] and writes a .cxx file
      containing:
        - static char arrays initialized with resource contents
          (possibly compressed, this is automatic unless explicitly
          specified in the XML file);
        - a function definition containing calls to
          EmbeddedResourceManager::addResource() that register each of
          these resources with the EmbeddedResourceManager instance.

      If you pass the --output-header-file option to fgrcc, it also
      writes a header file that goes with the generated .cxx file. For
      other options, see the output of 'fgrcc --help'.

      It is quite possible to call fgrcc several times, each time with a
      different (XML input file, .cxx/.hxx output files) tuple: for
      instance, one call for resources present in the FlightGear repo,
      and possibly another call for resources in FGData. The point of
      this is that paths in the XML input file should be relative to
      avoid being system-dependent, and fgrcc accepts a --root option to
      indicate what you want them to be relative to, in order to let it
      find the real files. Thus, on a first invocation of fgrcc, one can
      make --root point to a path to the FlightGear repository when
      building, and on the second call use it to indicate a path to the
      FGData repository. Other variations are possible, of course.

      Notes:

        1) The example given here with FGData would *not* freeze the
           FGData location at FG compile time; this is only to allow
           files from FGData to be turned into generated .cxx files
           inside the FG source tree, that will make their contents
           available as embedded resources at runtime.

        2) At the time of this writing, resources from the FlightGear
           repository are compiled at build time, and resources from the
           FGData repository are compiled offline using the
           'rebuild-fgdata-embedded-resources' script[6] (a
           convenience wrapper for fgrcc), before being committed to the
           FlightGear repository.

  (2) SimGear contains an EmbeddedResourceManager class with, among
      others, createInstance() and instance() methods similar to the
      ones of NavDataCache. See [7] for the corresponding code.

      FlightGear creates an EmbeddedResourceManager instance at startup
      and calls the various init functions generated by fgrcc, each of
      which registers the resources present in its containing .cxx file
      (using EmbeddedResourceManager::addResource()).

      End-user FG code can then use EmbeddedResourceManager methods such
      as getResource(), getString(), getStreambuf() and getIStream()
      to access resource contents:
        - getResource() returns an
          std::shared_ptr<const AbstractEmbeddedResource>
        - getString() returns an std::string
        - getStreambuf() returns an std::unique_ptr<std::streambuf>
        - getIStream() returns an std::unique_ptr<std::istream>

      AbstractEmbeddedResource is an abstract base class that you can
      think of as a resource descriptor: it points to (not contains!)
      the resource data (which is normally of static storage class), and
      contains + gives access to metadata such as the compression type
      and resource size (compressed and uncompressed).

     AbstractEmbeddedResource currently has two derived concrete
     classes: RawEmbeddedResource for resources stored as-is
     (uncompressed) and ZlibEmbeddedResource for resources compressed by
     fgrcc. It's quite easy to add new subclasses if wanted, e.g. for
     LZMA compression or other things.

     Resource fetching requires two things:

       - an std::string key (fgrcc manipulates them with SGPath, but the
         EmbeddedResourceManager code in SimGear is so far completely
         agnostic of the kind of data stored in keys; this could be
         changed, though, if we wanted for example to be able to query
         at runtime all available resources in a given virtual
         directory);

       - a locale name, similar to what FlightGear's XML translation
         files and FGLocale use. We used double quotes here, because
         fgrcc and the EmbeddedResourceManager expect locale names to
         be of one of these forms:
           * empty string: default locale, typically but not necessarily
             English (it is engineering English in FlightGear, i.e.,
             English written by programmers in the code, before
             translators possibly fix it up :)
           * en, fr, de, es, it...
           * en_GB, en_US, fr_FR, fr_CA, de_DE, de_CH, it_IT...

         There is no encoding part, contrary to POSIX locales, hence the
         use of double quotes around the term locale in this context.

     The FGLocale::getPreferredLanguage() method returns the preferred
     locale in the form described above, according to user choice
     (from fgfs' --language option) and/or settings (system locale).
     This allows FG to tell the EmbeddedResourceManager the preferred
     locale for resource fetching (same syntax as in Qt's rcc tool for
     declaration in the XML file, using the 'lang' attribute on
     'qresource' elements).

     [ Regarding the default locale, the way things are currently set
       up, I would use no 'lang' attribute for resources suitable for
       English in the XML input file for fgrcc, except when a
       country-specific variant is desired (en_GB, en_US, en_AU...). In
       such a case, there should also be a generic variant with no
       'lang' attribute declared for the same resource virtual path.
       This matches what I did for FGLocale::getPreferredLanguage(),
       that maps unset locales and locales such as C and C.UTF-8 to the
       default locale for the EmbeddedResourceManager, which is the
       empty string. This is a matter of policy, of course, and could be
       changed if desired. ]

     The EmbeddedResourceManager class has getLocale() and
     selectLocale() methods to manage the _selected locale_. Each
     resource-fetching method of this class (getResourceOrNullPtr(),
     getResource(), getString(), getStreambuf() and getIStream()) has
     two overloads:
       - one taking only a virtual path (the key mentioned above);
       - one taking a virtual path and a locale name.

     (we'll write locale without enclosing double-quotes from now on,
     otherwise it gets too painful to read; but we're *not* talking
     about POSIX-style locales ending with an encoding part)

     The first kind of overload uses the selected locale to look up the
     resource, whereas the second kind uses the explicitly specified
     locale. Then resource lookup behaves as one could expect. For
     instance, assuming a resource is looked up for in the "fr_FR"
     locale, then the EmbeddedResourceManager tries in this order:
       - "fr_FR";
       - if no resource has been registered for "fr_FR" with the provided
         virtual path, it then tries with the "fr" locale;
       - if this is also unsuccessful, it finally tries with the default
         locale: "";
       - if this third attempt fails, the resource-fetching method
         throws an sg_exception, except for getResourceOrNullPtr(),
         which returns a null
         std::shared_ptr<const AbstractEmbeddedResource> instead.

     To see how this is used, you can look at
     simgear/simgear/embedded_resources/embedded_resources_test.cxx. The
     only difference with real use is that in this file, resource
     contents and registering calls with the EmbeddedResourceManager
     have been written manually instead of by fgrcc. Apart from
     embedded_resources_test.cxx, here are two examples of client usage
     of the EmbeddedResourceManager:

  (a) With EmbeddedResourceManager::getString():

      #include <simgear/embedded_resources/EmbeddedResourceManager.hxx>
      #include <simgear/debug/logstream.hxx>

      [...]

      const auto& resMgr = simgear::EmbeddedResourceManager::instance();
      SG_LOG(SG_GENERAL, SG_INFO,
             "Resource contents: '" <<
             resMgr->getString("/virtual/path/to/resource") << "'");

  (b) With EmbeddedResourceManager::getIStream():

      #include <cstddef>              // std::size_t
      #include <simgear/io/iostreams/sgstream.hxx>
      #include <simgear/embedded_resources/EmbeddedResourceManager.hxx>

      [...]

      sg_ofstream outFile(SGPath("/tmp/whatever"));
      if (!outFile) {
        <handle open error>
      }

      const auto& resMgr = simgear::EmbeddedResourceManager::instance();
      auto resStream = resMgr->getIStream("/virtual/path/to/resource");
      // One possible way of handling errors from resStream[8]:
      // resStream->exceptions(std::ios_base::badbit);

      constexpr std::size_t bufSize = 4096;
      std::unique_ptr<char[]> buf(new char[bufSize]); // intermediate buffer

      do {
        resStream->read(buf.get(), bufSize);
        outFile.write(buf.get(), resStream->gcount());
      } while (*resStream && outFile); // resStream *points* to an std::istream

      <handle possible errors that might have caused to loop to stop
      prematurely>


3) About the XML resource declaration files
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may want to read the output of 'fgrcc --help', which explains a few
things, in particular how to write an XML resource declaration file that
fgrcc can use. At the time of this writing, such files are already
present as flightgear/src/EmbeddedResources/FlightGear-resources.xml and
flightgear/src/EmbeddedResources/FGData-resources.xml in the FlightGear
repository. In case you need resources from elsewhere, it's easy to add
other XML resource declaration files:

  1) If you want the .cxx/.hxx resource files to be automatically
     generated as part of the FlightGear build:

     Copy and adapt the add_custom_command() call in
     flightgear/src/Main/CMakeLists.txt[9] that invokes fgrcc on
     flightgear/src/EmbeddedResources/FlightGear-resources.xml.

  2) In flightgear/src/Main/CMakeLists.txt, add paths for your new
     fgrcc-generated .cxx and .hxx files to the SOURCES and HEADERS
     CMake variables for the 'fgfs' target.

  3) Assuming you passed for instance
     --init-func-name=initFoobarEmbeddedResources in step 1, add a call
     to initFoobarEmbeddedResources() after this code in fgMainInit()
     (flightgear/src/Main/main.cxx):

      simgear::EmbeddedResourceManager::createInstance();
      initFlightGearEmbeddedResources();


4) The EmbeddedResourceProxy class
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SimGear contains an EmbeddedResourceProxy class that allows one to
access real files or embedded resources in a unified way. When using it,
one can switch from one data source to the other with minimal code
changes, possibly even at runtime (in which case there is obviously no
code change at all).

Sample usage (from FlightGear):

  simgear::EmbeddedResourceProxy proxy(globals->get_fg_root(), "/FGData");
  proxy.setUseEmbeddedResources(false); // can also be set via the constructor

  std::string s = proxy.getString("/some/path");
  std::unique_ptr<std::istream> streamp = proxy.getIStream("/some/path");

This example would retrieve contents from the real file
$FG_ROOT/some/path. If true had been passed in the
proxy.setUseEmbeddedResources() call, it would instead have used the
default-locale version of the embedded resource whose virtual path is
/FGData/some/path.

For more information about this class, see [10] and [11].


Footnotes
=========

[1] E.g., FlightGear or FGData, as long as the path to the latter is
    provided to the FG build system, which is currently possible but not
    required (passing '-D FG_DATA_DIR:PATH=...' to CMake when
    configuring the FlightGear build).

[2] The differences with the QRC format[3] are explained in the output
    of 'fgrcc --help'. Here is the relevant excerpt:

,----
| 1. The <!DOCTYPE RCC> declaration at the beginning should be omitted (or
|    replaced with <!DOCTYPE FGRCC>, however such a DTD currently doesn't
|    exist). I suggest to add an XML declaration instead, for instance:
|
|      <?xml version="1.0" encoding="UTF-8"?>
|
| 2. <RCC> and </RCC> must be replaced with <FGRCC> and </FGRCC>,
|    respectively.
|
| 3. The FGRCC format supports a 'compression' attribute for each 'file'
|    element. At the time of this writing, the allowed values for this
|    attribute are 'none', 'zlib' and 'auto'. When set to a value that is
|    not 'auto', this attribute of course bypasses the algorithm for
|    determining whether and how to compress a given resource (algorithm
|    which relies on the file extension).
|
| 4. Resource paths (paths to the real files, not virtual paths) are
|    interpreted relatively to the directory specified with the --root
|    option. If this option is not passed to 'fgrcc', then the default root
|    directory is the one containing INFILE, which matches the behavior of
|    Qt's 'rcc' tool.
`----

[3] http://doc.qt.io/qt-5/resources.html

[4] The main reason why I wrote the classes in
    simgear/simgear/io/iostreams/{CharArrayStream,zlibstream}.cxx is
    thus not to maximize memory-efficiency with very large resources;
    rather, it is to make the implementation of the following parts
    simple, clean and modular:
      - the resource compiler (fgrcc);
      - the EmbeddedResourceManager.

[5] The EmbeddedResourceManager architecture would make it quite easy to
    also support runtime loading of resources from files (a thing the Qt
    resource system supports), but it is not very clear how interesting
    this would be, compared to having the files loaded from $FG_ROOT.
    Well, maybe for large files [apt.dat.gz & Co] that we would want to
    load but not see in the FGData repository at all. But then there
    would be the requirement, of course, that something puts the files
    in a clearly-defined, platform-dependent location known to the
    EmbeddedResourceManager.

[6] https://sourceforge.net/p/flightgear/fgmeta/ci/next/tree/python3-flightgear/rebuild-fgdata-embedded-resources

[7] https://sourceforge.net/p/flightgear/simgear/ci/next/tree/simgear/embedded_resources/

[8] We know that in some buggy C++ implementations, the
    std::ios_base::failure exception can't be caught, at least not under
    its name, due to some ABI compatibility mess:

      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66145

    However, it stills causes the program to abort, and since this
    error handling technique makes for much more readable and less
    error-prone code, I think it's still a good way to handle IOStreams
    errors even now, unless you really need to *catch* the
    std::ios_base::failure exception.

[9] flightgear/CMakeModules/GenerateFlightgearResources.cmake in my
    'i18n-and-init-work-v2' branch (not merged into 'next' at the time
    of this writing).

[10] https://sourceforge.net/p/flightgear/simgear/ci/next/tree/simgear/embedded_resources/EmbeddedResourceProxy.hxx

[11] https://sourceforge.net/p/flightgear/simgear/ci/next/tree/simgear/embedded_resources/embedded_resources_test.cxx

--- End of README.embedded-resources ---


--- Start of README.expressions ---

Expressions (or SGExpressions) are a feature of the SimGear library
and provide a nice way of implementing complex math formulas using XML
syntax. They are supported in many systems within the FlightGear code.

Caution: Expressions do not check if your math creates floating point
exceptions (like division by zero conditions, taking the square root
of a negative number, etc.). This can cause undefined behavior and may
result in NaNs or even Cascading NaNs.  Usage

Expressions are supported in

* Autopilot configuration files
* Particle system configuration files
* Animations (translate, rotate, scale, range, blend)
* The shader technique

Sample Expressions

This is a sample expression for the euation c = sqrt(a*a + b^2). 

Children/arguments are parsed in the order they appear in in the file
(or the order in which they are set via property methods).

<expression>
  <sqrt>
    <sum>
      <product>
        <property>/value/a</property>
        <property>/value/a</property>
      </product>
      <pow>
        <property>/value/b</property>
        <value>2</value>
      </pow>
    </sum>
  </sqrt>
</expression>

Supported elements

NOTE: #c in the table below is the number of child nodes required.

+-------------------+----+--------------------------------------------------+
| Function          | #c | Notes                                            |
+-------------------+----+--------------------------------------------------+
| <abs> <fabs>      | 1  |                                                  |
| <acos>            | 1  |                                                  |
| <asin>            | 1  |                                                  |
| <atan2>           | 2  |                                                  |
| <atan>            | 1  |                                                  |
| <ceil>            | 1  |                                                  |
| <clip>            | 3  | clipMin, clipMax, expression                     |
| <cos>             | 1  |                                                  |
| <cosh>            | 1  |                                                  |
| <deg2rad>         | 1  |                                                  |
| <difference> <dif>| 1+ |                                                  |
| <div>             | 2  |                                                  |
| <exp>             | 1  |                                                  |
| <floor>           | 1  |                                                  |
| <log10>           | 1  |                                                  |
| <log>             | 1  |                                                  |
| <max>             | 1+ |                                                  |
| <min>             | 1+ |                                                  |
| <mod>             | 2  |                                                  |
| <pow>             | 2  |                                                  |
| <product> <prod>  | 1+ |                                                  |
| <property>        | 0  | Property name e.g.<property>node/value</property>|
| <rad2deg>         | 1  |                                                  |
| <sin>             | 1  |                                                  |
| <sinh>            | 1  |                                                  |
| <sqr>             | 1  |                                                  |
| <sqrt>            | 1  |                                                  |
| <sum>             | 1+ |                                                  |
| <table>           | 2+ | <entry><ind> 0.0 </ind><dep> 10 </dep></entry>   |
| <tan>             | 1  |                                                  |
| <tanh>            | 1  |                                                  |
| <value>           | 0  | Constant Value e.g. <value>0</value>             |
+-------------------+----+--------------------------------------------------+

Hints and tips
--------------

1. There is no function for rounding, hwoever "Round half up" can be
   achieved as follows

  <expression>
    <floor>
      <sum>
        <property>your/property/here</property>
        <value>0.5</value>
      </sum>
    </floor>
  </expression>

2. Interpolation tables can be useful when a formula cannot be found,
   In the example below <ind> is the indepdendant variable and
   <dep> is the dependant variable. What this table does is as follows
   - values below 0.2 will be 10
   - values above 0.2 and between 1.0 will be interpolated between 10
     and 0
   - values above 1.0 will be 0

    <table>
      <entry><ind> 0.0 </ind><dep> 10 </dep></entry>
      <entry><ind> 0.2 </ind><dep> 10 </dep></entry>
      <entry><ind> 1.0 </ind><dep>  0 </dep></entry>
    </table>

--- End of README.expressions ---


--- Start of README.fgjs ---

fgjs -- a small program for creating a basic FlightGear joystick 
        configuration
        
fgjs requires plib to be installed on your system.  If you've 
successfully installed and built FlightGear then you should be
all set

Build instructions
At this point, fgjs has only been built and tested under Linux, 
so the makefile is a simple one. cd into the directory in which
the fgjs source resides and type 'make' and, if you are lucky,
all will go well.  You can e-mail me (apeden@earthlink.net) any
changes needed to make it work on other systems.  It's quite 
possible that this program will become part of the regular 
FlightGear package so 

Running
Set up your joystick and make sure it works with js_demo from the 
FlightGear distribution.  Upon executing fgjs, it will prompt you
to move the control you wish to use for elevator, ailerons, etc.
Note that when being prompted for an analog control, you can skip
the current one by pressing any button and vice-versa when being
prompted for a button.  You may want to do this if for, as an
example, rudder if you have only one joystick or your joystick
doesn't have as many analog axes as FlightGear supports.

Once you've run with this configuration, you may wish to tune
the dead-band a bit (see fgfsrc.js) as the default, 0.02, may 
be too narrow for your particular hardware/taste.


And last, but not least, this thing needs a GUI!!!!  Hopefully,
the joystick handling code and interface code are separate 
enough that using that a GUI version could be built using this
source as a starting point.



 




   
        

--- End of README.fgjs ---


--- Start of README.flightrecorder ---

FlightGear Flight Recorder Mini-HOWTO

Thorsten Brehm
Started in August 2011
Last revised: 2011-09-26


FlightGear provides a customizable flight recorder capable of capturing
any selection of properties described via XML configuration files.
The recorder is currently used for the replay system.


Feature Brief
-------------
* Generic recording system, adaptable to any aircraft/data, provided that
  data is accessible via the property tree. No hard-coded selections or
  assumptions on properties to be recorded.
* Configuration read from XML files or the property tree itself.
* Interpolation method configurable per recorded/replayed signal.
* Adaptable recording resolution per signal.
* Multiple configurations supported.


Quick Start: Basic Configuration
--------------------------------
To configure and adapt the flight recorder, add a "/sim/flight-recorder"
section to your aircraft -set.xml file.

Example:

<sim>

  <!-- ... -->

  <flight-recorder>
    <replay-config type="int">0</replay-config>
    <config n="0" 
        include="/Aircraft/Generic/flightrecorder/generic-piston-propeller-1.xml">
      <name type="string">My Aircraft's Flight Recorder</name>
      <!-- Custom properties -->
      <signal>
        <type>float</type>
        <property type="string">/controls/gear/nosegear-steering-cmd-norm</property>
        <interpolation>linear</interpolation>
      </signal>
      <!-- More custom signals here -->
    </config>
  </flight-recorder>

      <!-- ... -->

</sim>

Default type for each signal is "float". Default "interpolation" method
is "linear" (for float/double). Default values may be omitted. See
configuration details below.


Generic Configuration Files
---------------------------
Select one of the default configuration files to specify the basic
properties to be recorded. It's not recommended to specify all
properties to be recorded individually.
The following generic files are provided:

* /Aircraft/Generic/flightrecorder/generic-piston-propeller-4.xml
  Matches propeller aircraft with 4 piston engines, 4 tanks,
  3 retractable gear.
  It is the same configuration that was hard-coded for the replay system
  up to FlightGear 2.4.0. To provide backward compatibility this
  configuration is loaded by default, unless an aircraft provides a
  specific flight recorder configuration.

* /Aircraft/Generic/flightrecorder/generic-piston-propeller-1.xml
  Matches propeller aircraft with 1 piston engines, 2 tanks, 3 fixed
  gear.

* /Aircraft/Generic/flightrecorder/generic-turboprop-2.xml
  Matches turboprop aircraft with 2 turbines/propellers, 4 tanks,
  3 retractable gear.

* /Aircraft/Generic/flightrecorder/generic-jet.xml
  Matches jet aircraft with 2 jet engines, 4 tanks.

* /Aircraft/Generic/flightrecorder/generic-glider.xml
  Matches gliders (no engines, no tanks, single fixed gear).

* /Aircraft/Generic/flightrecorder/generic-helicopter.xml
  Matches helicopters with main and tail rotor (tested with YASim).

If none of the generic files matches your aircraft, simply use a
configuration which covers more than you need. Alternatively, copy the
contents of one of these generic files to your aircraft, and adapt as
needed (see below).

FDM experts are welcome to add more generic configuration files to
/Aircraft/Generic/flightrecorder - such as YASim-/JSBSim-specific
configurations, and configurations for other types of aircraft
(balloons, airships, ...).


Generic Components
-----------------
The generic configuration files in turn include a set of generic
components. If you copy the contents of a generic file to your aircraft,
you can adapt the components to your needs. See examples.
It is not recommended to copy the contents of the _component_ files to
an aircraft though (causes too much hassle and dependencies).

Engine Selection:
 * /Aircraft/Generic/flightrecorder/components/engine-jet.xml
   Records properties of a single jet engine.
   For multiple jet engines, use "count". Example for 4 jets:
     <signals include="/Aircraft/Generic/flightrecorder/components/engine-jet.xml">
       <count>4</count>
     </signals>

 * /Aircraft/Generic/flightrecorder/components/engine-piston.xml
   Records properties of a single piston engine and propeller.
   For multiple piston engines, use "count" (see "jet" example).

 * /Aircraft/Generic/flightrecorder/components/rotor.xml
   Records properties of a single helicopter rotor (tested with YASim).
   To use this, provide the base property path to the rotor as "prefix".
   Example recording the rotor below "/rotors/main":
     <signals include="/Aircraft/Generic/flightrecorder/components/rotor.xml">
         <prefix type="string">/rotors/main</prefix>
     </signals>

Gear Selection:
 * /Aircraft/Generic/flightrecorder/components/gear-fixed.xml
   Records properties of a single non-retractable gear.
   For multiple fixed gear, use "count" (see "jet" example).

 * /Aircraft/Generic/flightrecorder/components/gear-retractable.xml
   Records properties of a single retractable gear.
   For multiple retractable gear, use "count" (see "jet" example).

Tanks:
 * /Aircraft/Generic/flightrecorder/components/tanks.xml
   Records properties of a single fuel tank.
   For multiple fuel tanks, use "count" (see "jet" example).

Other:
 * /Aircraft/Generic/flightrecorder/components/surfaces.xml
   Records properties of flight control surfaces. Include this
   for aircraft (with wings). Not useful for helicopters,
   balloons, ...

 * /Aircraft/Generic/flightrecorder/components/faults-engines.xml
   Records fault properties of a single engine. Only include this
   if your aircraft supports fault simulation.
   For multiple engines, use "count" (see "jet" example). If used,
   it should be compined with piston or jet engine.

 * /Aircraft/Generic/flightrecorder/components/environment.xml
   Records properties of environment/weather (visibility,
   temperature - but _not_ cloud position...).

 * /Aircraft/Generic/flightrecorder/components/position.xml
   Records properties of a the aircrafts main position (latitude,
   longitude, velocities, ...).
   This is the most important component. Always include this.

 * /Aircraft/Generic/flightrecorder/components/controls.xml
   Records most important flight controls (rudder, aileron,
   elevator, ...). Always include this.


Custom Properties
-----------------
When the generic or component files are not be sufficient to record or
replay aircraft-specific effects, you can add custom properties (signals
to be recorded) to the configuration.
Each signal consits of a recording type/resolution (which does _not_
need to match the actual type in the property tree!), the path to the
property and interpolation type.

Example recording some additional custom properties:
  <sim>
    <flight-recorder>
      <config n="0" 
        include="/Aircraft/Generic/flightrecorder/generic-piston-propeller-1.xml">
        <!-- Add custom properties here -->
        <signal>
          <type>float</type>
          <property type="string">/controls/gear/nosegear-steering-cmd-norm</property>
        </signal>
        <signal>
          <type>double</type>
          <interpolation>rotational-deg</interpolation>
          <property type="string">/ai/model/carrier/alpha-angle-deg</property>
        </signal>
        <signal>
          <type>bool</type>
          <property type="string">/controls/panel/custom-switch</property>
        </signal>
      </config>
    </flight-recorder>
  </sim>


Signal Configuration
--------------------
Template:
  <signal>
    <type>bool</type>
    <interpolation>angular-deg</interpolation>
    <property type="string">/controls/panel/custom-switch</property>
  </signal>

* type: The signal's type specifies the recording resolution - not the
  type of the original property. The following types are supported:

  - double: 8 byte/sample
  - float:  4 byte/sample (default)
  - int:    4 byte/sample, integer
  - int16:  2 byte/sample, integer
  - int8:   1 byte/sample, integer
  - bool:   1 bit/sample (yes, 1 bit. 8 bools per byte).
  
  String type is unsupported (too expensive).

* interpolation: Specifies how values are interpolated during replay, i.e.
  when replay is in slow-motion mode and more frames/second are required
  than recorded, or when replaying data from the medium/long term memory.
  Supported methods:
    - discrete: No interpolation. Default for integer/bool types.
    - linear: Standard linear interpolation. Default for float/double.
    - angular-rad (or angular): Angular values in radians (0-2pi).
    - angular-deg: Angular values in degrees (0-360).

* property: Path to the property to be recorded.


Advanced Configuration
----------------------
- Multipe recorder configurations for a single aircraft are supported
  (multiple "<config n=..>" sections for n=0,1,...).
  Active configuration to be used for the replay system is selected via
     /sim/flight-recorder/replay-config (= 0,1,...).
  This can be useful for specific recorders for specific scenarios,
  which should not be used by default. For example, a specific recorder
  configuration could be provided which also records the position of
  an aircraft carrier, of other AI aircraft, ...
  This may also be useful for future use, i.e. to select another flight
  recorded configuration for a different purpose, such as for the
  multiplayer system.

- Flight recorder configuration can be adapted during run-time
  (configuration is visible in the property browser below
  /sim/flight-recorder). However it is necessary to reset (reinit) the
  replay subsystem first - which also erases earlier recordings. It is
  not possible to mix recordings of different configurations on to a
  single "tape".

- Each configuration should be given a name. Useful for a (future)
  selection GUI, when multiple configurations are available.


Optimizing Performance
----------------------
- Recording properties consumes memory and also CPU time. A few
  additional properties don't matter much, but avoid execessive numbers.
  Reduce the resolution (type) of signals to the minimum necessary to
  save space.
- Use "bool" types where possible, they are most efficient.
- Avoid recording with "double" resolution (type "double"). Use "float"
  instead - even if the original property in the property tree is a
  "double" (almost all of them do). "float" precision is almost always
  sufficient for recording/replay purposes, with few exceptions (like
  latitude/longitude properties).
- Use int16/int8 for "small" integer values.


Recording/Replay Limits
-----------------------
- All properties can be recorded, however, only writable properties can
  be replayed. Properties marked as read-only, or tied properties not
  implementing the "set" method cannot be replayed.
- Replaying a property overwrites the property's value. However, other
  sources may also write to the same property - such as Nasal code,
  autopilot rules etc. When multiple sources "fight" over a property's
  value then the last update "wins" - resulting in a dependency to an
  unknown/random sequence. Hence, during deplay, try to disable other
  sources writing to properties which were recorded and should be
  replayed.
  If the other source cannot be disabled, check if you're recording the
  right property. It may be better to record the input properties of the
  other source instead (i.e. the inputs processed by the Nasal or
  autopilot rule).

__end__


--- End of README.flightrecorder ---


--- Start of README.gui ---

FlightGear GUI Mini-HOWTO

David Megginson
Started: 2003-01-20
Last revised: 2003-01-20


FlightGear creates its drop-down menubar and dialog boxes from XML
configuration files under $FG_ROOT/gui.  This document gives a quick
explanation of how to create or modify the menubar and dialogs.  The
toolkit for the FlightGear GUI is PUI, which is part of plib.

All of the XML files use the standard FlightGear PropertyList format.


MENUBAR
-------

FlightGear reads the configuration for its menubar from
$FG_ROOT/gui/menubar.xml.  The file consists of a series of top-level
elements named "menu", each of which defines on of the drop-down
menus, from left to right.  Each menu contains a series of items,
representing the actual items a user can select from the menu, and
each item has a series of bindings that FlightGear will activate when
the user selects the item.

Here's a simplified grammar:

  [menubar] : menu*

  menu : label, item*

  item : label, enabled, binding*

The bindings are standard FlightGear bindings, the same as the ones
used for the keyboard, mouse, joysticks, and the instrument panel.
Any commands allowed in those bindings are allowed here as well.

Here's an example of a simple menubar with a "File" drop-down menu and
a single "Quit" item:

  <PropertyList>

   <menu>
    <label>File</label>
 
    <item>
     <label>Quit</label>
     <binding>
      <command>exit</command>
     </binding>
    </item>

  </PropertyList>

PUI menus do not allow advanced features like submenus or checkmarks.
The most common command to include in a menu item binding is the
'dialog-show' command, which will open a user-defined dialog box as
described in the next section.


DIALOGS
-------

The configuration files for XML dialogs use a nested structure to set
up dialog boxes.  The top-level always describes a dialog box, and the
lower levels describe the groups and widgets that make it up.  Here is
a simple, "hello world" dialog:

  <PropertyList>

   <name>hello</name>

   <width>150</width>
   <height>100</height>
   <modal>false</modal>
   <draggable>true</draggable>
   <resizable>true</resizable>

   <text>
    <x>10</x>
    <y>50</y>
    <label>Hello, world</label>
    <color>
     <red>1.0</red>
     <green>0.0</green>
     <blue>0.0</blue>
    </color>
   </text>

   <button>
    <x>40</x>
    <y>10</y>
    <legend>Close</legend>
    <binding>
     <command>dialog-close</command>
    </binding>
   </button>

  </PropertyList>

The dialog contains two sub-objects: a text field and a button.  The
button contains one binding, which closes the active dialog when the
user clicks on the button.

Coordinates are pseudo-pixels.  The screen is always assumed to be
1024x768, no matter what the actual resolution is.  The origin is the
bottom left corner of the screen (or parent dialog or group); x goes
from left to right, and y goes from bottom to top.

All objects, including the top-level dialog, accept the following
properties, though they will ignore any that are not relevant:

 x - the X position of the bottom left corner of the object, in
   pseudo-pixels.  The default is to center the dialog.

 y - the Y position of the bottom left corner of the object, in
   pseudo-pixels.  The default is to center the dialog.

 width - the width of the object, in pseudo-pixels.  The default is
   the width of the parent container.

 height - the height of the object, in pseudo-pixels.  The default is
   the width of the parent container.

 border - the border thickness, in pseudo-pixels.  The default is 2.

 color - a subgroup to specify the dialogs color:
  red   - specify the red color component of the color scheme.
  green - specify the green color component of the color scheme.
  blue  - specify the blue color component of the color scheme.
  alpha - specify the alpha color component of the color scheme.

 font - a subgroup to specify a specific font type
  name - the name of the font (excluding it's .txf extension)
  size - size of the font
  slant -  the slant of the font (in pseudo-pixels)

 legend - the text legend to display in the object.

 label - the text label to display near the object.

 property - the name of the FlightGear property whose value will
   be displayed in the object (and possibly modified through it).

 binding - a FlightGear command binding that will be fired when the
   user activates this object (more than one allowed).

 keynum - the key code of a key that can be used to trigger the
   widget bindings via keyboard (e.g. <keynum>97</keynum> for
   the "a" key.

 key - like "keynum", but takes a character ("a", "A", "Shift-a",
   "Shift-A", "Ctrl-a", "%", etc.), or symbolic key name ("Tab",
   "Return" = "Enter", "Esc" = "Escape", "Space", "&amp;" = "and",
   "&lt;", "&gt;", "F1" -- "F12", "Left", "Up", "Right", "Down",
   "PageUp", "PageDn", "Home", "End", "Insert"). Note that you
   can't use "<", ">", and "&" directly.

 default - true if this is the default object for when the user
   presses the [RETURN] key.

 visible - if set to false, hides the whole widget that it is used
   in, along with its children. There's no empty space reserved
   for such widgets. The "visible" property can also be used to hide
   other XML groups from the layouter.

Objects may appear nested within the top-level dialog or a "group"
or a "frame" object.  Here are all the object types allowed, with their
special properties:


dialog
------

The top-level dialog box; the name does not actually appear in the
file, since the root element is named PropertyList.

  name - (REQUIRED) the unique name of the dialog for use with the
    "dialog-show" command.

  modal - true if the dialog is modal (it blocks the rest of the
    program), false otherwise.  The default is false.

  draggable - false if the dialog is not draggable. The default is true.

  resizable - false if the dialog is not resizable. The default is false.

  nasal - Nasal definition block
    open - Nasal script to be executed on dialog open
    close - Nasal script to be executed on dialog close

All Nasal code runs in a dialog namespace. Nasal bindings can
directly access variables and functions defined in an <open> block.
settimer() and setlistener() functions have to be removed manually
in the <close> block if they shouldn't remain active.


Example:

<PropertyList>

 <name>sample</name>
 <width>500</width>
 <height>210</height>
 <modal>false</modal>

 <text>
  ...
 </text>

 <button>
  ...
 </button>

</PropertyList>


group and frame
---------------

A group of subobjects.  This object does not draw anything on the
screen, but all of its children specify their coordinates relative to
the group; using groups makes it easy to move parts of a dialog
around.

A frame is a visual representation of a group and has  a border and an
adjustable background color.

Example:

  <group>
   <x>0</x>
   <y>50</y>

   <text>
    ...
   </text>

   <input>
    ...
   </input>

   <button>
    ...
   </button>

  </group>


input
-----

A simple editable text field.

Example:

  <input>
   <x>10</x>
   <y>60</y>
   <width>200</width>
   <height>25</height>
   <label>sea-level temperature (degC)</label>
   <property>/environment/temperature-sea-level-degc</property>
  </input>


text
----

A non-editable text label.

Example:

  <text>
   <x>10</x>
   <y>200</y>
   <label>Heading</label>
  </text>

  <text>
   <x>10</x>
   <y>200</y>
   <label>-9.9999</label> <!-- placeholder for width -->
   <format>%-0.4f m</format>
   <property>/foo/altitude</property>
  </text>


checkbox
--------

A checkbox, useful for linking to boolean properties.

Example:

  <checkbox>
   <x>150</x>
   <y>200</y>
   <width>12</width>
   <height>12</height>
   <property>/autopilot/locks/heading</property>
  </checkbox>



button
------

A push button, useful for firing command bindings.

  one-shot - true if the button should pop up again after it is
    pushed, false otherwise.  The default is true.

  <button>
   <x>0</x>
   <y>0</y>
   <legend>OK</legend>
   <binding>
    <command>dialog-apply</command>
   </binding>
   <binding>
    <command>dialog-close</command>
   </binding>
   <default>true</default>
  </button>



combo
-----

A pop-up list of selections.

  value - one of the selections available for the combo.  There may be
  any number of "value" fields.

Example:

  <combo>
   <x>10</x>
   <y>50</y>
   <width>200</width>
   <height>25</height>
   <property>/environment/clouds/layer[0]/type</property>
   <value>clear</value>
   <value>mostly-sunny</value>
   <value>mostly-cloudy</value>
   <value>overcast</value>
   <value>cirrus</value>
  </combo>



list
----

like "combo", but displays all values in a scrollable list box with
slider on the right side. Updates the <property> to the selected
entry. On <dialog-update> re-scans the <value> nodes and updates
the list.



airport-list
------------

like "list", but fills the list automatically with all airports known
to FlightGear. Calls bindings on airport selection and returns the
selected entry in <property> on dialog-apply. Interprets <property>
as search term on dialog-update.



property-list
-------------

like "list", but shows a list of properties from the global property
tree. The widget handles navigation in the property tree. It calls its
bindings on property selection and returns the path of the selected
property in <property> on dialog-apply. It's up to the caller to check
if the path belongs to a dir node or a value node. The widget shows
the contents of the dir property given in <property> on dialog-apply.
It does *not* handle setting of property values! Clicking on some
entries with the "control" or "shift" key pressed has a special meaning:

Ctrl +
  "."     ->  toggle verbose mode (shows flags, listeners, dir-values)
  ".."    ->  go to root node
  (bool)  ->  toggle bool value

Shift +
  "."     ->  dump contents of that tree level to the terminal

The flags printed after the node type have the following meaning:

  r       ->  read protected
  w       ->  write protected
  R       ->  trace read operations    (in the terminal window)
  W       ->  trace write operations
  A       ->  archive bit set
  U       ->  user archive bit set
  P       ->  preserved bit set (value is preserved on sim-reset)
  T       ->  property is "tied"

  Ln      ->  number of listeners attached to this node



select
------

A box with arrow buttons that cycle through a list of values.

Example:

  <select>
   <x>10</x>
   <y>50</y>
   <width>200</width>
   <height>25</height>
   <property>/sim/aircraft</property>
   <value>bo105</value>
   <value>ufo</value>
  </select>



slider
------

A horizontal or vertical slider for setting a value.

  vertical - true if the slider should be vertical, false if it should
    be horizontal.  The default is false.

  min - the minimum value for the slider.  The default is 0.0.

  max - the maximum value for the slider.  The default is 1.0.

  step - set to non-null if slider should move in steps.  The default is 0.0 (off).

  pagestep - set to non-null to enable page-stepping.  The default is 0.0 (off).

  fraction - size of the slider handle. Range: 0..1.  The default is 0.0 (minimum).

Example:

  <slider>
   <x>10</x>
   <y>50</y>
   <width>200</width>
   <property>/environment/visibility-m</property>
   <min>5</min>
   <max>50000</max>
  </slider>


dial
----

A circular dial for choosing a direction.

  wrap - true if the dial should wrap around, false otherwise.  The
    default is true.

  min - the minimum value for the dial.  The default is 0.0.

  max - the maximum value for the dial.  The default is 1.0.

Example:

  <dial>
   <x>10</x>
   <y>50</y>
   <width>20</width>
   <property>/environment/wind-from-direction-deg</property>
   <min>0</min>
   <max>360</max>
  </dial>


textbox
-------

The text will be retrieved/buffered from/within a specified
property tree, like:

<textbox>
    <!-- position -->
    <x>100</x>
    <y>100</y>

    <!-- dimensions -->
    <width>200</width>
    <height>400</height>

    <property>/gui/path-to-text-node/contents</property>

    <slider>15</slider> <!--width for slider -->
    <wrap>false</wrap> <!-- don't wrap text; default: true -->
    <top-line>0</top-line <!-- line to show at top, -ve numbers: show last line -->

    <editable>true</editable> <!-- if the puLargeInput is supposed to be editable -->
</textbox>


hrule/vrule
-----------

Draws a horizontal/vertical line that, by default, expands to full width/height.
Its thickness can be set with <pref-height>/<pref-width>.

  <hrule>
    <color>
      <red>1.0</red>
      <green>0.0</green>
      <blue>0.0</blue>
    </color>
    <pref-height>2</pref-height>
  </hrule>




GLOBAL SETTINGS ("THEMES")
--------------------------

FlightGear reads GUI style information from /sim/gui/, which is by default
loaded from file $FG_ROOT/gui/style.xml.  This file contains one <font> and
one <colors> group:


global font settings
--------------------

  <sim>
    <gui>
      <font>
        <name type="string">Helvetica.txf</name>
        <size type="float">15</size>
        <slant type="float">0</slant>
      </font>
    </gui>
  <sim>

<name> can either be the name of a built-in bitmap font (one of:
"FIXED_8x13", "FIXED_9x15", "TIMES_10", "TIMES_24", "HELVETICA_10",
"HELVETICA_12", "HELVETICA_14", "HELVETICA_18", "SANS_12B"), or the
name of a texture font in the $FG_FONT directory. $FG_FONT is by
default set to $FG_ROOT/Fonts/. Properties <size> and <slant> are
only applied to texture fonts, and otherwise ignored.


global color settings
---------------------

These define the color of the splash screen font, and the color of the
GUI elements. All colors are in /sim/gui/colors/ and follow the same
pattern:

  <sim>
    <gui>
      <colors>
        <!-- splash screen font color; ignores <alpha> value -->
        <splash>
          <red type="float">1.0</red>
          <green type="float">0.9</green>
          <blue type="float">0.0</blue>
        </splash>
      </colors>
    </gui>
  </sim>



As listed above, FlightGear implements several GUI elements:

(1)    "dialog"      "group"         "frame"       "hrule"      "vrule"
       "list"        "airport-list"  "input"       "text"       "checkbox"
       "radio"       "button"        "combo"       "slider"     "dial"
       "textbox"     "select"


The underlying plib library uses six colors for each GUI element.
These are:

(2)    "background"  "foreground"    "highlight"
       "label"       "legend"        "misc"


"button", for example, uses the first four colors from (2), while it
ignores "legend" and "misc" color. "text" only uses "label", and ignores
the rest. In some cases the use of colors isn't obvious and you have to
try or look up the plib sources to be sure. GUI colors can be defined
for each of the categories from (1) and (2), and for combinations of
them:

(3)    "button-legend"   "input-misc"    etc.


FlightGear has default colors for (2) built-in. Let's call them (0).
And this is how colors for individual GUI elements are determined,
if, for example, a button is to be drawn:

  For the button's background:
  a. read the hard-coded default "background" color from (0) as base
  b. merge the global "background" color from (2) in (if defined)
  c. merge a global color "button-background" from (3) in (if defined)
  d. merge a specific <color> from the dialog's XML file in (if defined)

  Repeat the four steps for the button's "foreground", "highlight",
  etc. color.




If you write a style file, you'll most likely start with the colors
from (2):

 <sim>
   <gui>
     <colors>
       <background>
         <red type="float">0.6</red>
         <green type="float">0.0</green>
         <blue type="float">0.0</blue>
         <alpha type="float">1.0</alpha>
       </background>

       <foreground>
       ...

This makes all dialogs dark red. But you don't, for example, want buttons
to be red, but yellow. So you define another color for buttons:

       <button>
         <red type="float">1.0</red>
         <green type="float">0.9</green>
         <blue type="float">0.0</blue>
         <alpha type="float">1.0</alpha>
       </button>
       ...

This sets all of a button's six colors (2) to some shades of red. plib
does this automatically. The lower and right border ("foreground") will
be darker, the upper and left border will be lighter ("highlight").
If you aren't happy with plib's choice, you can set each of the colors
explicitly. Let's say, we want the text on the button blue (3):

       <button-legend>
         <red type="float">0.3</red>
         <green type="float">0.3</green>
         <blue type="float">1.0</blue>
         <alpha type="float">1.0</alpha>
       </button-legend>
       ...

To set the cursor color from input fields, you'd define "input-misc",
etc.


You can change colors and font at runtime. Just open the property
browser, go to /sim/gui/colors and change whatever you like. The
new color will only take effect, though, if you re-init the GUI.
There's a menu entry for that, and you can define a key binding
for it:

  <key n="99">
    <name>c</name>
    <desc>Re-init GUI</desc>
    <binding>
      <command>reinit</command>
      <subsystem>gui</subsystem>
    </binding>
  </key>

Note that this will currently close all open dialogs!


__end__

--- End of README.gui ---


--- Start of README.hud ---

This document describes the *new* HUD system that will be first released
with fgfs >0.9.10. For the old system see $FG_ROOT/Docs/README.xmlhud.
Note that the old system is scheduled for removal, and that the new system
is work in progress. So it's up to you to choose the lower risk.  :-)






###############################################################################


A HUD configuration file may contain 3 types of information:

  (1) global settings
  (2) HUD instrument definitions
  (3) imports of further HUD config files





(1) global settings ===========================================================

These can be used to override settings in the global property tree. Currently
only bool <enbale-3d> is supported. It allows a HUD to define itself if it is
a 2D HUD (false) or a 3D HUD (true). 2D HUDs always remain in the screen plane,
while 3D HUDs always remain in a position relative to the aircraft.

Example:

    <enable-3d>true</enable-3d>





(2) HUD instrument definitions ================================================

These define one single HUD "item" (instrument or label), and consist of several
properties. Some of those are standardized property groups that can be used
in many places. These shall be explained first.



(2.1) standardized property groups --------------------------------------------

  1. <condition> group
  2. input channel group
  3. <option>s



(2.1.1) <condition> ...........................................................

These define conditions that are either "true" or "false". They are used to
hide/unhide whole items, or to set other item states (blinking on/off) etc.
You find detailed documentation about them in $FG_ROOT/Docs/README.conditions.



(2.1.2) input channel groups .................................................

These define an input channel to the HUD instrument and serve as interface
between property system and the instrument. A complete channel definition
looks like this (defaults in comments):

  <input>
      <property>/position/altitude-agl-ft</property>  <!-- no default -->
      <factor>0.3048</factor>                         <!-- 1.0 -->
      <offset>2.0</offset>                            <!-- 0.0 -->
      <damp>1.5</damp>                                <!-- 0.0 (no damping) -->
      <min>0.0</min>                                  <!-- -infinity -->
      <max>10000</max>                                <!-- +infinity -->
  </input>

Input channels are only called <input> for instruments that only have one
channel. Other instruments may have two or more channels, called <bank-input>,
<pitch-input> etc. All of them will have the same member properties and behave
the same.

An input channel will preprocess the raw property value for the HUD instrument.
The property may be of any type (bool, int, long, float, double, string), but
not all types will make sense in every situation. The HUD instrument will only
see the final value, which is calculated as:


  v = <property> * <factor> + <offset>
  if (<damp>)     v = EWMA_lowpass(v, <damp>)
  if (v < <min>)  v = <min>
  if (v > <max>)  v = <max>


The EWMA_lowpass filter (Exponentially Weighted Moving Average) is calculated
like so:


  coeff = 1.0 - 1.0 / 10^<damp>
  v = average = (average * coeff) + (v * (1.0 - coeff))


That is, a <damp> value of 0 will cause no damping. A damping value of 1 will
make a coefficient of 0.9, which means that the resulting value will be 9/10
of the average plus 1/10 of the new value. A damping value of 2 will make
a coefficient of 0.99 and hence result in a value of 99/100 the average plus
1/100 the new value etc. The higher the <damp> value, the more damped will
the output value be.




2.1.3 <option> ................................................................

Most HUD instruments accept one or more options from a common set. It will be
explaind in the respective intrument descriptions which options are actually
used by that instrument. Possible values are:

  <option> autoticks </option>
  <option> vertical </option>   \___orientation of <tape>
  <option> horizontal </option> /
  <option> top </option>          \
  <option> left </option>         |___place of numbers in <tape>, <gauge>
  <option> bottom </option>       |   top/bottom for turn-bank-indicator, etc.
  <option> right </option>        /
  <option> both </option>           _left/right for vert. and top/bottom for hor.
  <option> noticks </option>
  <option> arithtic </option>
  <option> decitics </option>
  <option> notext </option>       ___no numbers on <tape>


Example:

  <tape>
      <option>left</option>
      <option>vertical</option>
      ...
  </tape>






(2.1) properties common to all instruments ------------------------------------

All HUD instruments will accept the following common properties (shown on
a <tape> instrument):


  <tape>
      <name>foo tape</name>
      <x>-100</x>                        <!-- 0 == center -->
      <y>-60</y>                         <!-- 0 == center -->
      <width>20</width>                  <!-- 0 -->
      <height>120</height>               <!-- 0 -->
      <condition>...</condition>         <!-- see section 2.1.1; default: true -->
      ...
  </tape>

The <name> is only a description for the instrument to make reading the config
easier. It's output in --log-level=info, but not otherwise used. The coordinates
define the place and size of the instrument. They are relative to the origin of
their parent, which is the middle of the HUD/screen by default. Positive <x> are
on the right, positive <y> in the upper half. The <condition> hides/reveals the
whole instrument.






(2.2) HUD instruments ---------------------------------------------------------




(2.2.1) <label> ...............................................................

Draws a formatted string or number.

Text:
  <format>   ... printf-style format with only one % item.  Example:  "%2.3lf ft"
  <prefix>   ... prefix text  \___ in addition to the <format>
  <postfix>  ... postfix text /
  <halign>   ... one of "left", "center" (default), "right".

Box:
  <box>      ... draw box around label (default: false)
  <option>   ... one of (left|right|top|bottom)  ... draw arrow on this side
  <pointer-width>  ... size of pointer base
  <pointer-lenfth> ... distance of base--peak

  <blinking>
      <interval>                  ... on/off-time in seconds (default: -1 == off)
      <condition>...</condition>  ... see secion 2.1.1       (default: true)
  </blinking>

TODO:
  <digit>    ... number of insignificant digits (those will be printed smaller)



Example:

  <label>
      <name>G Load</name>
      <x>-40</x>
      <y>25.5</y>
      <width>1</width>
      <height>1</height>

      <input>
          <property>/accelerations/pilot/z-accel-fps_sec</property>
          <factor>-0.03108095</factor>
          <damp>1.3</damp>
      </input>

      <format>%2.1f</format>
      <halign>right</halign>
      <box>true</box>
      <option>bottom</option>    <!-- pointer on the lower edge -->

      <blinking>
          <interval>0.25</interval>
          <condition>
              <or>
                  <less-than>      <!-- G load > 2.0 -->
                      <property>/accelerations/pilot/z-accel-fps_sec</property>
                      <value>-64.3481</value>
                  </less-than>

                  <greater-than>   <!-- G load < -1.0 -->
                      <property>/accelerations/pilot/z-accel-fps_sec</property>
                      <value>31.17405</value>
                  </greater-than>
              </or>
          </condition>
      </blinking>
  </label>









(2.2.2) <tape> ................................................................
SCALE:
    input
    major-divisions
    minor-divisions
    modulo
    display-span

TAPE:
    tick-bottom
    tick-top
    tick-right
    tick-left
    cap-bottom
    cap-top
    cap-right
    cap-left
    marker-offset
    enable-pointer
    zoom

    pointer-type   (moving|fixed)
    tick-type      (circle|line)
    tick-length    (constant|variable)









(2.2.3) <dial> ................................................................
SCALE:
    input
    major-divisions
    minor-divisions
    modulo
    display-span

TAPE:
    radius
    divisions








(2.2.4) <gauge> ...............................................................
SCALE:
    input
    major-divisions
    minor-divisions
    modulo
    display-span






(2.2.5) <turn-bank-indicator> .................................................
    bank-input
    sideslip-input
    gap-width
    bank-scale








(2.2.6) <ladder> ..............................................................
    pitch-input
    roll-input
    display-span
    divisions
    screen-hole
    compression-factor
    enable-fuselage-ref-line
    enable-target-spot
    enable-velocity-vector
    enable-drift-marker
    enable-alpha-bracket
    enable-energy-marker
    enable-climb-dive-marker
    enable-glide-slope-marker
    glide-slope
    enable-energy-marker
    enable-waypoint-marker
    enable-zenith
    enable-nadir
    enable-hat
    type       (pitch|climb-dive)









(2.2.7) <runway> ..............................................................
    arrow-scale
    arrow-radius
    line-scale
    scale-dist-nm
    outer_stipple
    center-stipple
    arrow-always

reads directly:
    /position/altitude-agl-ft,
    /sim/view[0]/config/pitch-pitch-deg
    /sim/view[0]/config/pitch-heading-deg





(2.2.8) <aiming-reticle> ......................................................

Draws MIL-STD-1787B aiming reticle. Size of bullet and inner circle are
determined from <width>. The outer circle radius is changeable at runtime.

  <active-condition> ... true:  stadiametric (4.2.4.4)  (default)
                         false: standby (4.2.4.5)
  <diameter-input>   ... input channel: diameter of outer circle relative to
                         inner circle; default: 2.0 (= twice as big)







(3) <import> ==================================================================

Imports another HUD config into the current one. This can be a file defining
a single instrument ($FG_ROOT/Huds/Instruments/*.xml), a set of instruments
($FG_ROOT/Huds/Sets/*.xml) or a mixture of both (for example a complete HUD
on its own). The x/y offets moves the reference point for the included items
relative to the current reference point.

    <import>
        <path>Huds/Sets/controls.xml</path>
        <x-offset>-100</x-offset>
        <y-offset>70</y-offset>
    </import>

Imported files can import further files. This is allowed for up to 10 levels.
This is an arbitrary number and can easily be changed in the code if necessary.

When fgfs is called with --log-level=info, then it outputs a graphical trees
of all loaded/imported files, with the instruments shown as leafs.


--- End of README.hud ---


--- Start of README.introduction ---


Internals
---------

The core of FlightGear is the property system. This is a tree like internal
representation of global variables. The property system is explained more
in detail later on.

FlightGear' way of doing things is breaking it up into small pieces. There is
(for example) animation code that reacts on property changes. There is also a
Flight Dynamics model (FDM) that (amongst other things) updates properties.
There is a menu system that can display and alter properties. Then we have
sound code that plays sound based on ... properties.

Maybe you see a pattern evolve by now.

All subsystems are almost self containing. Most of the time they only read the
values of some properties, and sometimes they alter other properties. This is
the basic way of communicating between subsystems.


Property System
---------------

The property system is best described as an in-memory LDAP database which holds
the state of global variables. The system has a tree like hierarchy (like a
file system) and has a root node, sub nodes (like subdirectories) and end-nodes
(variables).

All variables are kept internally as raw values and can be converted to any
other supported type (boolean, int, float double and string).

Like a file system, every node can be accessed relative to the current node, or
absolute to the root node.

The property system also allows aliasing nodes to other nodes (like symbolic
linking files or directories to other files or directories) and may be assigned
read-only or read-write.

If necessary it would be possible for parts of the program to hold it's own
property tree, which is inaccessible from the global property tree, by keeping
track of it's own root-node.

Property I/O code allows one to easily read the tree from, or write the tree to
an XML file.


Subsystems
----------

To add a new subsystem you would have to create a derived class from
SGSubsystem and define at least a small set of functions:

    class FGFX : public SGSubsystem
    {
    public:

      FGFX ();
      virtual ~FGFX ();

      virtual void init ();
      virtual void reinit ();
      virtual void bind ();
      virtual void unbind ();
      virtual void update (double dt);
    }

The init() functions should make sure everything is set and ready so the
update() function can be run by the main loop. The reinit() function handles
everything in case of a reset by the user.

The bind() and unbind() functions can be used to tie and untie properties.

After that you can register this class at the subsystem manager:

    globals->add_subsystem("fx", new FGFX);

Now the subsystem manager calls the update() function of this class every
frame. dt is the time (in seconds) elapsed since the last call.


Scripting
---------

The scripting langage Nasal can also read and modify properties but it can also
be incorporated into the menu system. The documentation for Nasal can be found
here:  http://www.plausible.org/nasal/flightgear.html


--- End of README.introduction ---


--- Start of README.jsclient ---

Start flightgear with
fgfs --jsclient=socket,in,<hz>,,<port>,udp \
     --prop:/jsclient/axis[i]="/property/you/want/to/control" \
     --prop:/jsclient/axis[i+1]="/another/property/you/want/to/control" ...
eg:
# fgfs --aircraft=yf23-yasim --airport=KEMT --jsclient=socket,in,5,,16759,udp \
  --prop:/jsclient/axis[0]="/controls/flight/spoilers" \
  --prop:/jsclient/axis[1]="/radios/comm/volume"

Start the server on the machine with the remote gameport:
JsServer <host> <port>
eg: 
# JsServer 192.168.1.1 16759

(JsServer can be started before or after fgfs)

--- End of README.jsclient ---


--- Start of README.kln89.html ---

<h1>The KLN89 GPS unit in FlightGear</h1>

FlightGear includes a simulation of the KLN89B GPS unit.  This is an IFR en-route, terminal and non-precision approach capable GPS (FAA TSO-C129 level A1) introduced around 1994.  The majority of the display is text based, but there is a fairly rudimentary moving map display.
<br>
<br>
The user-interface and capabilities of this unit are extremely complex, and as far as possible the simulation is a faithful reproduction of the behaviour of the original.  The best documentation is therefore the original manual, which is readily available on the web.  A working link at the time of writing can be found <a href="http://www.buffaloairways.com/manuals/manuals.htm">here</a>.  Owners of the old <i>Fly!</i> flight simulator will also find a useful section on the KLN89 in the accompanying manual.  Various other relevant iterature on the web may be found by searching.
<br>
<br>
The KLN89B may currently be found in FlightGear only on the 2D C172p panel:
<pre>fgfs --aircraft=c172p-2dpanel</pre>
The display is clearest at a FG area size of 1024x768, since at that geometry there is a 1:1 mapping between screen and KLN89 display pixels:
<pre>fgfs --aircraft=c172p-2dpanel --geometry=1024x768</pre>
At higher resolutions the display is readable but slightly blurred, at lower resolutions the display may be largely unreadable.  Advanced note: One possible way around this is to make up a custom mini-panel containing only the KLN89B at the correct resolution.  Check out the KLN90 mini-panel on the b1900d for a template to get started.
<br>
<br>
The unit is currently functional for en-route navigation and non-precision approaches, but is not yet fully complete, and is missing a number of features.  The duplicate waypoint page is not available, so some waypoints (particularly NDBs) which have duplicated IDs worldwide may be unselectable.  There is no provision for altitude input.  The moving map page only displays the active flightplan, not airports or navaids not on the flightplan.  Only a couple of non-precision approaches are available in the database, at KHWD and C83.  It is not possible to enter user-defined waypoints.  Most of the OTH (auxiliary) and CAL (calculator) pages are unimplemented (info such as satellite position and status, fuel calculator etc).  The nearest search functions don't work yet.  Waypoint scan with the inner-knob out only works on the NAV4 (moving map) page.  There is no turn anticipation.  Only some user settings are changable in the SET pages, and these are not persistent between FG sessions.  That list sounds long, but the unit is still under active development, and hopefully it gives some indication of how much *has* been implemented so far!
<br>
<br>
The rest of this documentation is a short introduction to using the unit, and a description of the specific peculiarities of using the unit within FlightGear.
<br>
<br>
<h2>Getting Started with the Unit</h2>
<b><i>Input</b></i>
<br>
Input to a complex instrument is unfortunately somewhat more awkward in a simulator than on the real-life unit.  Input to the unit in FlightGear is via the mouse, although key-bindings could be configured by the user.  At the right-hand side of the unit is a double knob, composed of an inner and outer knob.  Both knobs may be turned in either direction by clicking with the mouse (left mouse button): press Ctrl-C to see where the hot-spots are, and practice clicking the correct knob on the ground before commencing an approach.  The inner knob may be pulled out - the middle mouse button is used to pull out and push in the middle knob.  The left mouse button is used to turn the inner knob when pulled out in the same manner as before.
<br>
<br>
<b><i>Basics</b></i>
<br>
The unit is organised in pages, eg. APT (airport data), NAV (navigation display).  Most pages are composed of several subpages, eg. NAV1 (CDI and basic nav info), NAV4 (moving map page).  Moving between pages is done using the outer knob, moving between subpages is done using the inner knob.  Most pages have several editable or changable data fields.  Press the CRSR button to enter or exit edit mode.  In edit mode, the outer knob moves between editable items, and the inner knob changes items, except for cyclic fields (indicated by '>'), which require the CLR button to cycle through the choices.  Sometimes a specific choice may require confirmation to set it; in this case the unit will flash 'ENT', and the ENT button must be pressed to confirm (or generally either the CLR or CRSR button to reject).  The DTO button allows navigation direct to a selectable waypoint.  The OBS button allows navigation relative to a radial to or from a given waypoint, in a similar manner to VOR navigation.
<br>
<br>
<b><i>Flight planning</b></i>
<br>
Central to operation of the unit is the concept of the active flightplan, which is a path connecting a set of waypoints that the user intends to follow.  By default the unit operates in LEG mode, whereby navigation is provided along each leg (great-circle path between waypoints) of the flightplan.  Several flightplans are programmed into the FPL pages at startup for convienience.  Other flightplans may be entered into any of the FPL pages (except FPL0, the active flightplan) as per the manual instructions (or trial-and-error for the adventurous!).  Any flightplan can be made active, at which point it is copied to the FPL0 page.  Currently flightplans can not be entered on the command line, loaded from file, nor are entered flightplans in the unit saved between sessions.  This will come eventually...
<br>
<br>
<b><i>Navigation</b></i>
<br>
The NAV1 page contains a CDI-type display.  The scale may be changed.  NAV4 contains the moving map display, which currently shows only the active flightplan.  Press the CRSR button to access the map scale change, or the CRSR button, then left-outer-knob, then ENT button (!) to access the map menu.  Note that if you select heading-up display then the map will blank out at speeds less than about 2 knots unless the unit is interfaced to a heading source (not currently done in FG) - this is consistent with the real-life unit.  The waypoints of the active flightplan may be 'scanned' on this page by pulling the inner knob out (middle mouse button) and turning it (left mouse button).  This allows the default direct-to waypoint to be changed (to the one displayed in the bottom-right of the screen), which can be very useful when under ATC control on an IFR flight-plan.
<br>
<br>
<b><i>Approaches</b></i>
<br>
The KLN89B is classed as TSO-C129 level A1 by the FAA, which among other things means it is suitable for non-precision IFR approaches if mounted in a suitable installation.  The FG installation currently doesn't quite comply, since there is no altitude input, but this is a sim so we won't worry too much for now!  How to fly non-precision approaches is beyond the scope of this document - see Charles Wood's excellent pages at <a href="http://www.navfltsm.addr.com/">www.navfltsm.com</a> for a thorough grounding.  The FAA GPS regulations state that the waypoints for a given approach must be stored in a database in the correct order, and must not be editable by the user!  Approaches for a given airport may be selected from the APT8 page, but only if that airport is in the active flightplan.  If there is a choice of IAF (initial approach fix), then this is chosen on the APT8 page as well.  The approach will be added to the active flightplan, but will be removed if the unit is power-cycled (another FAA reg. I believe).  Hence there are is no approach in the active flight-plan at FG startup.  Currently only 3 approaches are available, two at KHWD (Hayward Executive) and one at C83 (Byron), both of which are in the FG base package.  These are hardwired into the code at present, but it is hoped to move them to a file that the user can enter their favourite approaches into.
<br>
<br>
To fly an approach, make sure that the NAV1 CDI is slaved to the GPS by using the GPS/NAV switch on the annunciator unit near the top of the panel.  If everything is setup OK, the approach should arm about 30 miles or so from the destination, indicated on the annunciator, and the FSD of the CDI will change smoothly from 5 miles to 1 mile.  When 2nm from the final approach fix (FAF), if everything is OK then the unit will change to approach active mode, indicated by ACTV on the annunciator.  FSD will change from 1 to 0.3 miles.  If the status fails to change to ACTV by the time the FAF has been passed then a missed approach must be flown.
<br>
<br>
<b><i>Approach example: KLSN to C83</b></i>
<br>
An example flight with a non-precision approach flown entirely within the base-package scenery area is KLSN (Los Banos Muni) to C83 (Byron) in IFR conditions.  The approach chart for C83 GPS rwy 30 can be found online <a href="http://204.108.4.16/d-tpp/0602/09141G30.PDF">here</a>.  Start FlightGear with:
<pre>
fgfs --airport=KLSN --aircraft=c172p-2dpanel --geometry=1024x768 --ceiling=1000 --visibility=3000 --wind=300@5
</pre>
For the adventurous, increase the difficulty by adding turbulence, putting the wind across the runway with varying speed and direction, bringing the ceiling and visibility down to the approach minimums of 740ft and 1600m (1 mile), and leaving the autopilot switched off!
<br>
<br>
Before taking off from KLSN, set up the instruments for the flight.  Use the outer knob on the KLN89 to move to the FPL page.  Use the inner knob to move to FPL5, which contains KLSN -> C83.  Press the CRSR button, and the 'Use?' legend is underlined and starts to flash, along with the 'ENT' legend in the left-hand frame.  Press ENT to use the flightplan, and the flightplan is then copied to the FPL0 page, and becomes the active flightplan.
<br>
<br>
Now we must add the approach.  Approaches are selected from the APT8 page.  This would require C83 to be selected on the APT pages.  However, because C83 is the active waypoint, we can select the approach from the ACT pages, which are a straight copy of the appropriate data pages (APT, NDB, VOR etc) for the active waypoint.  Click left on the outer knob a couple of times to reach the ACT page.  Click left on the inner knob once (or right seven times!) to reach the ACT8 page.  Press the CRSR button and use the outer knob to select an approach (there is only one for this airport).  Press ENT to select the approach.  Use the outer knob to select an IAF (we want PATYY for this flight since that introduces a slight dog-leg into the flightplan that keeps us clear of high ground.  Use <a href="http://atlas.sourceforge.net">Atlas</a> to visulise this).  Press ENT to select the IAF.  Finally, press ENT once more to add the approach to the flightplan.  Press the NAV/GPS button on the annunciator to slave the NAV1 CDI to the GPS (the nav/gps flag on NAV1 won't change at the current state of development - you'll need to trust the annunciator indication instead), and tune NAV2 to Modesto VOR if desired (114.6) for a handy positional sanity check.
<br>
<br>
Take off and fly to PATYY.  It's quite a long flight (over 50nm total, about 25 to PATYY), so gain a bit of height.  Five to six thousand feet is probably appropriate, and gets us above the clouds.  Note that the published chart mandates arming the approach mode before reaching PATYY (PATYY is more than 30 miles from the airport, so it won't arm automatically by then), but currently this is not supported in the code, so we'll need to wait until it automatically arms between PATYY and TRACY.  Close to PATYY the waypoint alert will flash, and after waypoint sequencing occurs, the KLN89 will flash the message annunciation, indicating a message to view.  Press MSG to view the message, which will contain the new course to follow to the new active waypoint (TRACY), and MSG again to clear the message screen.
<br>
<br>
Shortly after PATYY is passed approach mode will arm.  The CDI scale smoothly changes from 5nm to 1nm deviation per dot, and a message is annunciated reminding the user to set the baro setting on the KLN89.  The ALT pages and altitude alerting are not currently implemented, so ignore that message for now.  Keep an eye on the distance to TRACY, and start decending at a suitable rate when appropriate, remembering that the chart shows a 2000ft minimum altitude at TRACY.
<br>
<br>
Once we reach TRACY things start to get exciting.  The next waypoint is the final approach fix (FAF), BABPI in this case.  BABPI is only 6.1nm from TRACY, with only a further 3.5nm to the missed approach point (MAP), AMOSY, located at the runway threshold.  You can descend no lower than 1300ft before passing BABPI, and should try to get down close to that height to avoid an alarming descent rate over the final leg.  Approaching the FAF (BABPI) the approach should activate, indicated by the ACTV annunciation on the MD41 unit (the annunciator panel above NAV1), and the CDI smoothly changing scale from 1nm to 0.3nm per dot.  If the approach fails to activate prior to passing the FAF then the missed approach procedure must be flown.  Assuming we have an ACTV approach passing BABPI, turn onto the final approach course to AMOSY, check gear, flaps and mixture setting (sure, it's a fixed gear plane, but it doesn't hurt to get into good habits!), and descend to minimum altitude, which is 740ft for the RWY30 straight-in approach that we are flying, or 880ft for this aircraft for a circling approach to another runway.  You need a positive visual fix on the runway prior to reaching the MAP in order to transition to visuals and land, otherwise the missed approach procedure must be flown.  No waypoint sequencing past the MAP occurs (another FAA reg) - it is necessary to fly the missed approach procedure and then use DTO or OBS mode to navigate to the missed approach holding point (MAHP) as appropriate.
<br>
<br>
<b><i>Miscellaneous</b></i>
<br>
Currently the GPS position is always correct, although in future a small random drift may be added.  No simulation of range ahead integrity monitoring (RAIM) is done.  At the time the units were introduced the GPS satellite constellation was less complete giving the possibility of unacceptable (but predicatable) navigation degradation due to poor satellite geometry.  I doubt that RAIM failure due to poor satellite geometry is an issue now, but would welcome an opinion one way or another from an IFR GPS-using pilot.  Report bugs to the FlightGear lists or to daveluff AT ntlworld DOT com.  Have fun :-)

--- End of README.kln89.html ---


--- Start of README.layout ---

I just commited an implementation of GUI layout management, ported
over from my game project last year*.  What this means is that you no
longer need to position your widgets manually in dialogs, and can
instead lay them out in tables and boxes like the pros do. :) I've
redone a few of the dialogs using the new scheme (I'm especially proud
of the autopilot dialog: http://plausible.org/andy/autopilot-new.png),
so you can see what the possibilities look like.

* FWIW, this is almost the last of my useful code from last spring.
  Nasal and the Plib vertex splitting code are two other bits that
  were useful in isolation.  I also had a terrain engine and stencil
  shadow implementation, but those weren't really production quality.
 
Basically, the implementation is a preprocessor on top of the existing
dialog properties, which sets x/y/width/height values based on
constraints.  The <group> objects, including the top-level one which
represents the whole dialog, can now have a <layout> property, which
can be "hbox", "vbox", or "table".

The boxes simply lay out their children in order, either top-to-bottom
or left-to-right.  The box name comes from Qt and Gtk, but this is
also the same thing that Java calls a "flow layout", or what the Tk
"packer" does.  You can set "constraint" properties on the children,
to give the layout manager hints as to how to place the children.  For
the boxes, these are:

  equal:   The box manager makes sure that all the widgets with this
           constraint set to true get equal sizes big enough to fit the
           largest one.  This is very useful for button boxes to make
           the "OK" and "Cancel" buttons match, for example.
  stretch: Cells with "stretch" set to true get all the extra space,
           if any, the box has to allocate.  These are useful for
           alignment purposes, especially when combined with <empty>
           "widgets" (which are ignored by the dialog creation code,
           but honored by the layout engine).

The table layout will be a little more familiar to anyone with HTML
experience.  Children of tables get the following constraints:

  row:     The row number containing the upper left corner of the widget.
           Table rows are zero-indexed.
  col:     The column number containing the upper left corner of the widget.
           Table columns are zero-indexed.
  rowspan: The number of rows spanned by the widget. Defaults to one.
  colspan: The number of columns spanned by the widget.  Defaults to
           one. 

Inside of each "cell", regardless of parent layout, there are some
constraints that are used to position the widget within the space
available:

  halign:      The horizontal alignment.  Can be "left", "right",
               "center", or "fill" (i.e. stretch to available space).
  valign:      The vertical alignment.  Can be "top", "bottom",
               "center", or "fill".
  padding:     The number of pixels to leave between the edge of the
               cell and the widget.
  pref-height:
  pref-width:  Overrides the default preferred size of the widget.
               Note that this is the size of the widget only, not the
               cell (which includes padding).

Also, the padding values for cells in a group can be set to a default
value with a <default-padding> property on the group widget.

Some will ask why didn't I implement this as part of Pui.  The problem
is the pui just isn't set up for it.  Not only is there no notion of
"preferred" size for a widget, there isn't anything remote like a
"constraint" system for attaching arbitrary values to widgets.  With
the property system, I have that for free (the original code was
written to work with Nasal objects, btw).  I can do the layout with
the properties and on the properties, and our existing dialog code
hardly needs to change at all.

Anyway, give it a try and see if I've broken anything.  Also, note
that some of these changes *do* modify the visual appearance of the
GUI.  I think it looks better, but opinions will no doubt vary.  Shout
if you hate it.

And finally, the text alignment doesn't quite look right with current
plib due to some minor rendering bugs.  Bug Steve to apply the patch I
submitted a week or so ago. :)

Andy


--- End of README.layout ---


--- Start of README.local_weather.html ---

<html>

<head>
<title>Local Weather </title>
</head>


<body>

<h1>Local Weather Package - v1.18</h1>

<h2>1. Introduction</h2>

The aim of a local weather system is to simulate weather phenomena tied to specific locations. Examples for this are a thunderstorm, a rainfront or thermal development. In the case of the thunderstorm, severe rain and turbulence occur in a location a few kilometers in scale, i.e. one can easily view it 'from outside' or fly in and out of this region. Similarly, the development of thermal convection clouds is strongly tied to features of the terrain - thermal development does not occur easily over open water or snow, but it is strong over rock or similar surfaces which heat in the sun. Finally, a rainfront is a phenomenon like a thunderstorm that divides the sky into two regions - one with essentially good visibility and clear sky, the other with severe clouds and rain, and both are visible at the same time.<p>

This is in contrast to the current (v.2.0.0) global weather system of Flightgear where weather changes affect the weather everywhere in the simulated world and are (with few exceptions) not tied to specific locations. In such a system, it is impossible to observe e.g. the approach of a rainfront while flying in sunshine.<p>

The local weather package aims to provide the functionality to simulate such local phenomena. In version 1.18, the package supplies various cloud placement algorithms, as well as local control over most major weather parameters (wind, visibility, pressure, temperature, rain, snow, thermal lift, turbulence...) through interpolation routines and effect volumes. The dynamics of the different systems is tied together - for instance clouds and weather effects drift in the specified wind field. The package also contains a fairly detailed algorithm to generate convective clouds and thermals with a realistic distribution over the various terrain types. There is a simulation of the interaction of the convective cloud system with the terrain as a function of time. Clouds drifting in the wind flow over obstacles, i.e. they change their altitude dynamically. Convection is implemented with a life cycle model of Cumulus clouds - they are generated, evolve for a given lifetime dependent on the underlying terrain and decay at the end of their life cycle. Thermals associated with the clouds follow the same pattern. In particular, in the presence of wind favourable spots for convection generate 'alleys' of dense cloud cover downwind, or thermals and clouds generated over land decay rapidly once they reach open water.<p>

For long-range flights, the system provides an offline weather system with plausible transitions between different large-scale weather patterns like fronts and low and high pressure areas, as well as the optional use of live METAR data. <p>


<h2>2. Installation</h2>

The package needs to be unpacked in the Flightgear root directory. It writes content into the <i>Nasal/local_weather/, gui/, gui/dialogs/, Shaders, Effects/, Docs/</i>, <i>Environment/</i> and <i>Models/Weather/</i> subdirectories. The package requires run-time loadable Nasal submodule functionality and is not compatible with 2.0.0.<p>

This adds the items <i>Local Weather</i> and <i>Local Weather Settings</i>  to the <i>Environment</i> and <i>Local Weather (test)</i> to the <i>Debug</i> menu when Flightgear is up. Most of the basic functionality is contained in <i>local_weather.nas</i> which is loaded at startup and identifies itself with a message. A compatibility layer (<i>compat_layer.nas</i>) tests for hard-coded support and ensures that, dependent on the version, hard-coded or Nasal-coded fallback functions are used.<p>

The Local Weather Nasal modules need to be loaded at runtime using the checkbox in <i>Environment/Local Weather Settings</i>, but once this is specified, the setting is remembered and the package will be automatically loaded upon startup. Unless asked to do so from the menu, Local Weather does <b>not</b> run any process in the background. Upon loading, the package does not set any properties already existing, but only generates properties necessary for the menu entries in its own subdirectory <i>/local-weather/</i> in the tree. The package also does a features check on startup if particular functions are available in hard-coded form. If the features are not present, the package will largely still function properly using slower Nasal fallback code.<p>



<h2>3. Functionality</h2>

The general rule is that the gui is not hardened against problematic user input, for example it will not reject meaningless input like negative windspeeds or unphysical windshear. It is recommended to watch the console, because some level of warnings and errors are passed to the console if the log option is on. Crucial warnings are also printed on-screen.<p>

Cloud placement calls may sometimes take a significant time to execute especially for large numbers of clouds tied in a complicated way to the terrain. Placing 500 barrier clouds against a small barrier may take a minute to compute. During this time, a reduced framerate is to be expected<p>

The menu item <i>Debug/Local Weather (Test) </i> contains the low level cloud placement functions. Its purpose is mainly for developing cloud patterns without having to resort to re-type the underlying Nasal code every time. Currently five options are supported: <i>Place a single cloud</i>, <i>Place a cloud streak</i>, <i>Start the convective system</i>, <i>Create barrier clouds</i> , <i>Place a cloud layer</i> and <i>Make a cloudbox</i>.<p>

<center>
<img src="img/menu1.jpg">
</center><p>

<h3>Single cloud placement</h3>

Single cloud placement is straightforward, it places a (randomly chosen) cloud model of specified type and subtype to a set location. The last parameter, direction of placement, is only relevant for static cloud models (Cirrus, Cirrocumulus) as it sets their orientation, it is overwritten for any rotated cloud models (Altocumulus, Cumulus, Cumulonimbus, Stratus, Nimbostratus).<p>

<h3>Streak placement</h3>

Cloud streak placement arranges multiple instances of clouds in a distortable and randomizable regular grid pattern. It is meant for the placement of high-altitude clouds, and acknowledges the fact that such clouds are often arranged in bands or patterns. In addition, it allows for the possibility to place larger clouds into the center of the pattern than on the edges, thus simulating stronger activity of the cloud-forming process in the center.<p>

The algorithm as called from the menu assumes that the streak center is the current position. x and y are the primary grid directions. <i>number x (y)</i> are the number of clouds to be placed in these directions, <i>Delta x (y)</i> the spacing between clouds along these directions. <i>x (y)</i> edge describes the fraction of the pattern to be taken by one border filled with small clouds. Since the pattern has borders from two sides, a fraction of 0 means that only large clouds are placed, a fraction of 0.5 that only small clouds are placed, anything inbetween corresponds to a transition. <i>Dir</i> is an angle by which the whole pattern is rotated. Finally, <i>Triang.</i> allows the distortion of the pattern into a trapezoid shape in which one side is by <i>Triang.</i> larger than the other.<p>

The pattern can then be randomized in x, y and altitude. Basically, specifying no grid spacing but large randomization scales corresponds to a random placement of clouds in the sky, whereas randomization scales lower than the grid spacing preserve the grid structure, and the algorithm allows to interpolate between these extremes.<p>

<h3>The convective system</h3>

The convective system places Cumulus clouds centered on the current position based on the underlying terrain. Currently it models daily variation of convective strength and the latitude variation based on a simple sinusoidal model (i.e. it produces different results when called in the morning than at noon), but it does not take into account seasonal variation (i.e. it assumes the date to be the equinox). The actual placement is chosen based on the type of the underlying terrain, with Cumulus development more likely over city areas than on water. Details of the algorithm are described in the appendix. The parameters for this need some fine-tuning and are currently rather rough, but they lead for example to pronounced differences between land and sea in coastal regions. The following picture shows the result of a call of the system in the afternoon over TNCM.<p>

<center>
<img src="img/clouds-cumulus_afternoon.jpg">
</center><p>

Unless 'Terrain presampling' is active, clouds are placed in a constant altitude <i>alt</i>  in a tile with given <i>size</i> where the size measures the distance to the tile border, i.e. a size parameter of 15 km corresponds to a 30x30 km region. When 'Terrain presampling' is selected, the distribution of clouds in altitude is determined by a more complicated algorithm described in the appendix. Clouds are placed with constant density for given terrain type, so be careful with large area placements! <i>strength</i> is an overall multiplicative factor to fine-tune the amount of cloud generation. 

<h3>The barrier cloud system</h3>

The barrier cloud system places a cloud at a random point within the region centered around the current position given by <i>size</i> with some probability if there is a terrain barrier downwind with the elevation <i>alt</i> within a distance <i>dist</i> or less. Cloud placement probability is larger for small distances to the barrier. The system tries to place <i>number</i> clouds and assumes that the wind comes from direction <i>wind</i>. If clouds cannot be placed (because there is no barrier within the specified altitude) the algorithm exits with a warning. The picture illustrates the result for the mountains above Las Vegas.<p>

<center>
<img src="img/barrier.jpg">
</center><p>

Currently, the algorithm does not check for a barrier upstream - this may change in future versions. The ufo is a good way to explore the results of the algorithm by simply flying to a suitable location and calling it there for a relatively small region. Due to its large performance use, the barrier cloud system is currently not part of the large-scale weather generating system.

<h3>The layer cloud system</h3>

The layer cloud placement is not drastically different from the streak placement in terms of what one can do with it - just its application philosophy is different. It randomly places cloudlets into an ellipsoid region given by the radii <i>rad x</i> and <i>rad y</i> which is rotated by <i>dir</i>, beginning at altitude <i>alt</i> up to thickness <i>thick</i> with a density controlled by <i>density</i>. The parameter <i>edge</i> specifies a boundary region in which smaller clouds are placed less densely. <p>

If <i>rainflag</i> is set to 1, the system will also place external precipitation models (i.e. visible rain layers), roughly at the transition between edge and core of the cloud placement region with a density given by <i>rain dens</i>. The system will however not place an effect volume which would lead to the actual simulation of rain below the layer - this must be done separately by the user.<p>

The picture illustrates the result of a layer generation call for Nimbostratus clouds with precipitation models. <p>

<center>
<img src="img/clouds-nimbostratus.jpg">
</center><p>

<h3>Cloudbox</h3>


The cloudbox placement is an experimental routine allowing to define a cloud core, border and bottom region and to place different texture types into these regions. The underlying idea is that this would generate better Cumulus clouds from small texture bits. However, currently the Cumulus clouds are generated by multiple layers of whole cloud photographs, creating a more realistic impression. Thus, the cloudbox is not actively developed further.<p>

<h3>Tile placement</h3>

The second menu <i>Environment/Local Weather</i> is used to place complete weather patterns based on low-level calls. It is intended for the user to automatically create the various weather development during flight. Unless stated otherwise, all parameters in this menu are parsed at startup time of Local Weather only (i.e. when the user selects the <i>OK</i> button, but not while the system runs.<p>

<center>
<img src="img/menu2.jpg">
</center><p>

Weather is created in a series of 40x40 km squares, called tiles. Tiles are classified by airmass, such that the sequence of tiles can describe for example the transition from a high pressure area to a low pressure area. The dropdown menu is used to select the type of weather tile to build initially and to determine the rules according to which subsequent tiles are generated. <p>

Below are entries for three parameters. The first two are the simplified version of wind direction and speed for the user who is not interested in specifying many different wind interpolation points or an altitude structure. 
The third parameter, the altitude offset, is to manually adjust the altitude level of clouds in the absence of terrain presampling. Cloud layer placement calls are then specified for absolute altitudes and calibrated at sea level. As a result, layers are placed too low in mountainous terrain, hence the need for an offset. If <i>aloft interpolated</i> or <i>aloft waypoints</i> are chosen as wind models or if tile selection mode is set to <i>METAR</i>, the first two fields are not parsed, if the option <i>terrain presampling</i> is selected the offset is not used.<p>

The three sliders below are used to control gusty winds. They are parsed at runtime and changes do not require a restart of local weather to be effective. The first slider controls how frequent gusts are, the second slider determines the strength relative to the base wind and the third slider their variation in direction. Gusts are, regardless of the wind model, only created in the atmospheric boundary layer close to the terrain surface. The rules for the gust model are described in the appendix in more detail. If the tile selection mode is set to <i>METAR</i>, user-specified values may be overwritten.<p>

The dropdown menu for the wind contains various models for how the windfield is specified which require a different amount of user-specified input. The options are described further down when the windfield modelling is described in more detail.<p>

The dropdown menu for the tile selection mode controls the long-range behaviour of weather. It specifies according to what rules tiles are automatically generated once the aircraft reaches the border of the original tile. The option <i>single tile</i> creates a single weather tile as specified without automatic generation of further tiles. The option <i>repeat tile</i> creates new tiles of the same type as the originally selected tile. This does not mean that weather will be unchanged during flight, as both parameters like pressure, temperature and visibility as well as the positioning of cloud banks are randomized to some degree. In addition, each tile typically contains typically 6-8 different cloud scenarios, so five repeated generations of <i>low-pressure-border</i> tiles may never result in the same arrangement of cloud layers. Nevertheless, the option will keep weather conditions roughly the same. This is different with the (somewhat optimistically named) <i>realistic weather</i>. This option allows transitions between different airmasses, thus one may select <i>low-pressure-core</i> initially, but as the flight goes on, eventually a region of high pressure and clear skies may be reached.  Currently, it does not cover transitions to arctic or tropical weather conditions - those will be covered in a future release. Note also that <i>repeat tile</i> does not work for any tile which is part of a weather front.<p>

The final option, <i>METAR</i>, generates weather according to parsed METAR information. This means that user-specified information for tile type and winds is overwritten by live data. The <i>METAR</i> mode is described in more detail below.<p>

Below the menu are six tickboxes. <i>Terrain presampling</i> finds the distribution of altitude in the terrain before placing a cloud layer. As a result, the layers or clouds are automatically placed at the correct altitude above ground in level terrain. In mountain regions, cloud placement is fairly tricky, and the algorithm analyzes quantities like the median altitude to determine what to do. The appendix contains a detailed description of the algorithm. If the box is ticked, the altitude offset specified above is not parsed.<p> 

<i>generate thermals</i> is an option intended primarily for soaring. It determines if thermals will be placed whenever a convective clouds is generated. Since managing a large number of thermals costs some amount of resources, it is recommended to generate thermals only if they are needed, i.e. definitely for soaring, possibly for added realism in small aircraft.<p>

<i>debug output</i> determines if the system writes status messages to the console. Unselecting the option suppresses normal status messages (warnings and errors will still be written). However, in many cases the log of status messages is needed to trace bugs, so if you switch it off and experience a problem, it is likely that the problem cannot be traced.<p>

<i>detailed clouds</i> will change the technique for generating Cumulus clouds from a multilayer model to multiple cloudlets filling a box. This improves the visual appearance of the clouds significantly, albeit at the expense of some loss of framerate. Rendering multiple tiles of dense Cumulus development with detailed clouds will quite possibly slow down even a powerful system. <p>

The option <i>dynamical weather</i> ties all clouds and weather effects to the windfield. If that option is not chosen, the wind is still generated according to the chosen model, but only felt by the aircraft. This makes e.g. soaring unrealistic, as the aircraft continuously drifts out of a static thermal below a static cap cloud. When <i>dynamical weather</i> is selected, aircraft, cloud and thermal are all displaced by the wind and follow elevation changes to some degree.<p>

The final option <i>dynamical convection</i> requires both <i>terrain presamling</i> and <i>dynamical weather</i> to be selected (if not, a warning is given and the system aborts). If this option is chosen, all convective clouds and thermals have a life cycle - clouds are continually spawned and decay after a while. This preserves realistic cloud configurations over islands even with wind drift on and improves the realism of the soaring experience as the properties of thermals change over time, but again uses somewhat more performance - switch it on if you need it, for fast planes the visual gain is almost non-existent.<p>

The slider <i>Thermal properties</i> is mainly relevant for soaring scenarios. It governs the rato of maximum lift to radius of a thermal. A setting close to <i>low convection</i> creates large thermals with relatively small lift and virtually no turbulence, a setting close to <i>rough day</i> creates very narrow, turbulent thermals with large lift. However, it also affects the Cumulus textures to be used. <i>low convection</i> creates well-formed, smooth Cumuli whereas <i>rough day</i> biases the texture selection towards more rugged and diffuse clouds.<p>

The difference is apparent from the following pictures: Smooth and well-formed clouds characteristic of a calm day:<p>

<center>
<img src="img/detailed_clouds04.jpg">
</center><p>

Rough clouds characteristic of windshear and more turbulent conditions:<p>

<center>
<img src="img/detailed_clouds05.jpg">
</center><p>

As for the buttons, <i>OK</i> starts the local weather system with the selected options (note that almost all options in this menu are startup-time options, they are read once and changing them without restarting the system will not affect the behaviour of the system). <i>Clear/End</i> clears all clouds and ends all local weather functionality - the button brings the system back into the state before it was started. No loops or other subroutines are executed after the button is pressed. <i>Close</i> closes the dialog without starting the system.<p>

The button <i>Show winds</i> brings up the detailed wind menu which is needed for the wind models <i>aloft interpolated</i> and <i>aloft waypoints</i> when not in <i>METAR</i> mode:<p>

<center>
<img src="img/menu3.jpg">
</center><p>

For <i>aloft interpolated</i>, the menu is used by inserting wind direction and speed for all given altitudes. After <i>OK</i>, the specified values are used. For <i>aloft waypoints</i>, the same info must be supplied for a series of waypoints. First, the latitude and longitude has to be inserted, afterwards the aloft winds for that point below. The button <i>Set waypoint</i> commits the windfield as specified in the menu for this position into memory. For orientation, the number of points inserted is counted on the lower right. <i>Clear Waypoints</i> removes all information entered so far. Note that <i>OK</i> does not commit the data for a waypoint. Entering a windfield in this way by hand is rather cumbersome, but may be useful occasionally - the main purpose of the wind model however is to work with live weather data.<p>




The following pictures show possible results of tile setups 'High-pressure-border' and 'Low-pressure':<p>

<center>
<img src="img/high_pressure_border.jpg">
</center><p>

<center>
<img src="img/low_pressure.jpg">
</center><p>

<h3>Performance settings</h3>


The performance setting menu is available from the main menubar. It controls the allocation of system resources to the various tasks, as well as the behaviour of the offline weather system.<p>

The upper checkbox determines if the Nasal modules corresponding to Local Weather are loaded. Unless this box is checked, no Local Weather code is available and the corresponding other menu items are not functional.<p>

<center>
<img src="img/menu4.jpg">
</center><p>

The first part controls the creation of new weather tiles, the second part controls the ranges up to which clouds inside a generated weather tile are shown as part of the scenery (clouds created but not shown are stored and processed in a buffer array). Clouds are visible if and only if they are 1) part of a created tile and 2) closer than the buffering range. This is illustrated in the following figure: Tiles are only created if their center is within range, clouds are only visible if the cloud model itself is within range, the resulting region  dependent on the two ranges in which clouds are displayed is shown in red.<p>

<center>
<img src="img/tiles.gif">
</center><p>

From this, it is apparent that the two ranges should not be drastically different. Setting tile creation range to 55 km implies lots of work trying to asses the properties of faraway terrain to generate suitable cloud distributions, setting the buffering range to 15 km means that most of these clouds are never visible. Note that in low visibility, a large tile creation range can be problematic, as Flightgear may not have loaded the terrain. Note also that setting the tile creation range above 40 km means a slow startup of the system, as it needs to create 5 tiles on startup instead of just a single one.<p> 

There are additional options to do asymmetric buffering, i.e. to 'cut' out a wedge in the rear of the aircraft in which the tile creation radius or the cloud visibility radius are lower.  For example, setting the buffering ratio to 0.2 and the angle to 180 degrees corresponds to a very agressive buffering in which clouds in the rear hemisphere of the aircraft are almost absent and shown only to 20% of the set distance. This may increase performance by 20-30%, but only in straight flight - in fast turns, lots of clouds have to be shuffled from the buffer into the scenery and back, which is actually slower than never trying to cut a wedge at all. Also, agressive asymmetric buffering is not nice in external views as the reference is always the aircraft course.<p>

The buffering control can also optionally be tied to a target framerate. In this case, the visible range set with the slider is ignored and a control loop tries to adjust the visible range instead such that a 5-second average of the framerate is within 10% of a specified target framerate. Currently, the subsystem <i>only</i> adjusts the visible range of buffering - asymmetric buffering and/or tile loading range still needs to be specified manually. Also, the system cannot respond to unsolvable problems - if the framerate in the absence of clouds falls below 30, then no setting for the cloud range will bring it to 35. <p>

The next option controls the amout of resources allocated to making clouds drift in the wind if dynamical weather is on. In order to avoid freezes, the weather dynamics system processes only a fixed number of clouds per frame inside the field of view. That means that faraway clouds do not necessarily move even with dynamical weather on. The slider indirectly controls the distance out to which clouds are being processed.<p>

All performance setting menu-options work at runtime, but are processed over time rather than instantaneously, i.e. it takes 10-20 seconds till the new balance between buffered clouds and active clouds is reached after the slider is moved.<p>

The final options, weather pattern scales, deal with the long-range behaviour of the offline weather system. They are not parsed when the tile selection mode is set to <i>METAR</i>. The first slider controls the transition between different airmasses. In the default setting, the typical distance to encounter a different airmass when one flies in a 'High-pressure-core' tile is 200 km. The airmass slider allows to vary this distance between 200 and 800 km. <p>

Inside each tile, there are typically 4-8 different basic cloud patterns (distribution of layers) modelled, with a random pattern selected for each new tile of the given airmass classification. The <i>cloud patterns</i> slider adjusts the probability that the same cloud configuration is kept as long as a tile of the same airmass type is generated. Selecting a large scale in essence means that the theme of clouds will remain similar within each airmass, a small scale allows for more variation.<p>

<h2>4. Cloud models</h2>

The package contains a number of different cloud models, both static ones for Cirrus and Cirrocumulus clouds as well as rotated ones for Altocumulus, Cirrostratus, Cumulus, Cumulonimbus, Stratus and Nimbostratus cloudlet models. Thin high-altitude haze such as characteristic for Cirrostratus or Altostratus clouds is approximated by colouring the skydome as a function of altitude. Neither the cloud textures, nor the models nor the transformations are perfected, and any aspect can be improved, albeit at the cost of performance consumption.<p>

Static clouds project textures onto curved sheets into the sky. The advantage of the technique is that cloud layers consisting of thousands of cloudlets with different sizes can be modelled. However, the sheets do not look equally well from all perspectives and somewhat unrealistic from close up.<p>

<center>
<img src="img/clouds-static.jpg">
</center><p>

Rotated cloud models have the advantage that they look much better from close up and hardly unrealistic from any perspective, but the size distribution of cloudlets is somewhat restricted and they use a lot more performance than static clouds.<p>


<center>
<img src="img/clouds-detailed01.jpg">
</center><p>

These are rendered by  different techniques. While the default Cumulus models consist of multiple layers rotated around the center of the model, the detailed Cumulus clouds consist of multiple (up to 24) individual cloudlets, rotating each around its own center, randomly distributed into a box with different texture types used for the cloud bottom. This not only improves the visual appearance, but also leads to a more realistic distribution of cloud sizes and shapes in the sky. In addition, when circling below the cloud (as done when soaring) the effect of the cloudlet rotation is less pronounced. The price to pay is that rendering detailed clouds costs more performance, so they may not be suitable for all systems.<p>

More complex clouds are rendered in sandwitched layers of several different textures. An example are Cumulonimbus towers, which use diffuse textures on the bottom, changing to more structured textures in the upper part of the cloud. With up to 2000 cloudlets, skies with multiple thunderstorms may not render with sufficient framerates on every system.<p>

<center>
<img src="img/clouds-tropical02.jpg">
</center><p>

The general problem is finding a good balance between spending a lot of CPU time to make a single cloud model appear perfect, and the performance degradation that occurs if hundreds of clouds are placed in the sky. The basic aim is to provide realistic appearance for clouds from a standard view position (in cockpit looking forward), to retain acceptable appearance from other positions and to allow large cloud layers.<p>



Currently all clouds which need to be rotated are treated in the shaders using a view-axis based rotation by two angles. This generally looks okay from a normal flight position, but rapid change of the view axis (looking around), especially straight up or down, causes unrealistic cloud movement. Any static picture of clouds however is (almost) guaranteed to look fine. This means that shader effects need to be 'on' in order to see most of the clouds.<p>

<h2>5. Local weather parameters</h2>

The local weather package provides three different ways to control the position dependence of weather parameters: 1) by interpolation between stations 2) by constant inside an effect volume and 3) by function inside an effect volume. This in principle allows to represent any 3-dim distribution of a parameter in a tile volume - but the user-input required to actually do that kind of micromanagement is substantial. However, the system is designed to run with good results and minimal user input.<p> 

The idea is that the interpolation system takes care of slow, large-distance scale changes of weather whereas the effect volume system models rapid, small-scale changes. Thus, the gradual drop in visibility when flying into a more humid air mass is dealt with by the interpolation system whereas the sudden drop in visibility when entering a cloud is modeled as an effect volume. It doesn't make sense to have both systems available for all weather parameters, for example pressure can't change suddenly and discontinuously. Consequently the effect volume system does not support pressure.

<h3>Determining weather parameters by interpolation</h3>

The interpolation system determines the weather parameters outside of special regions, i.e. possibly in the larger part of the tile volume. The weather is specified for an arbitrary number of stations. Each station is characterized by its position (latitude and longitude) and a set of surface weather observations (visibility, pressure, temperature, dew point, rain, snow). In flight, the interpolation system computes the distance to each station regularly, computes an average of the parameters weighted by the inverse distance to the station and sets this average as the current weather. This procedure makes the weather exactly as specified whenever the plane is above a station and changes smoothly as the plane is between stations. It may not yield the desired results when the plane is outside a grid of stations.<p>

While the station concept is designed to support easy connection with weather updates from real METAR stations, stations do not need to be real stations, and each weather tile creation call by default writes its own station at the center of the tile, so weather tiles can be different and the weather will change smoothly between them.<p>

Technically, the structure of the interpolation system means that while it is running, neither setting weather parameters in the GUI menu nor changing visibility using the <i>z</i>-key will have an effect - any setting made there will be overwritten by the interpolation loop periodically, and local weather needs to be stopped before such changes have an effect. <p>

In addition to true weather parameters, Local Weather 1.18 also has a model for the light propagation in the atmosphere which is handled by the same interpolation routines. This model determines the amount of light reaching the current altitude and the amount of thin haze above the current position. The first property affects to what color distant objects fade - when there is lots of light available, faraway objects appear white, however in the presence of cloud layers casting shadows, distant objects fade into dark shapes. The following screenshot illustrates the effect:

<center>
<img src="img/lightning-gloom.jpg">
</center><p>

The second property is used to simulate diffuse structureless Cirrostratus and Altostratus clouds. Details of the modelling are given in the appendix.

<h3>Weather parameters in effect volumes</h3>

Effect volumes are 3-dim regions in space in which the weather is not set by the interpolation system but by a specific prescription. This can be to either set a parameter to a constant value inside the volume, or to specify it as a function inside the volume. Effect volume settings always override information from the interpolation subsystem.<p>

Effect volumes may be nested, and they may overlap. The rules determining their behaviour can be summarized as follows: 1) there is no cross-talk between weather parameters, i.e. an effect volume specifying visibility is never influenced by one specifying pressure, regardless if they overlap or not. 2) when an effect volume is entered, its settings overwrite all previous settings 3) when an effect volume is left, the settings are restored to what the interpolation routine specifies if no other effect volumes influence the weather parameter, to the values as they were on entering the volume when the number of active volumes has not changed between entering and leaving the volume (i.e. when volumes are nested) or nothing happens if the number of active volumes has increased (i.e. when volumes form a chain). This is illustrated in the following figure:<p>

<center>
<img src="img/effect_nesting.gif">
</center><p>

Volumes 2 and 3 are nested inside volume 1, therefore all settings of 2 overwrite those of 1 when 2 is entered and are restored to 1 when region 2 is left directly into 1. Region 4 is a chain, and as such ill defined: When one leaves 2 into 4, the settings of volume 3 are used (because later definitions overwrite earlier ones). When one now leaves 4 into 3 (and hence leaves 2), it would be wrong to restore to the values on entry of 2 (i.e. the properties of 1), as 3 is still active. But the active volume count has changed, so leaving 4 into 3 does not lead to any changes. The reason why 4 is still ill-defined is that what weather is encountered in 4 depends on the direction from which it is entered - when it is entered from 2, it has the properties of 3, whereas when it is entered from 3, it has the properties of 2. <p>

Effect volumes are always specified between a minimum and a maximum altitude, and they can have a circular, elliptical and rectangular share (the last two rotated by an angle phi). Since it is quite difficult to set up event volumes without visual reference and also not realistic to use them without the context of a cloud or precipitation model, there is no low-level setup call available in the menu. Effect volumes can be created with a Nasal call <p>

<i>create_effect_volume(geometry, lat, lon, r1, r2, phi, alt_low, alt_high, vis, rain, snow, turb, lift, lift_flag, sat);</i><p>

 where <i>geometry</i> is a flag (1: circular, 2: elliptical and 3: rectangular), <i>lat</i> and <i>lon</i> are the latitude and longitude, <i>r1</i> and <i>r2</i> are the two size parameters for the elliptic or rectangular shape (for the circular shape, only the first is used), <i>phi</i> is the rotation angle of the shape (not used for circular shape), <i>alt_low</i> and <i>alt_high</i> are the altitude boundaries, <i>vis, rain, snow, turb</i> and <i>lift</i> are weather parameters which are either set to the value they should assume, or to -1 if they are not to be used, or to -2 if a function instead of a parameter is to be used and -3 if a function for wave lift is used. Since thermal lift can be set to negative values in a sink, a separate flag is provided in this case. <i>sat</i> finally determines the light saturation, a parameter between 0 (dark) and 1 (normal light) - it can be used to dim the light beneath cloud layers (which is not done automatically as objects don't cast shades in Flightgear, and given that most cloud models are rotated, their shade would look rather odd on any case).<p>

In version 1.18, thermal lift and wave lift are implemented by function (wave lift is not yet automatically placed, but can be easily from Nasal). There is no easy way to implement any weather parameter by function in an effect volume, as this requires some amount of Nasal coding.<p>

Both thermal lift and saturation require a more recent version of Flightgear than 2.0.0 in order to take effect.<p>

<h2>6. Wind models and dynamical weather</h2>

In reality, the wind is a vector field changing in space and time, subject to physical boundary conditions such as a continuity equation (there are no sources or sinks of air - air flowing out of a volume element must be balanced by air flowing into the volume element). This vector field has two horizontal and one vertical component. <p>

It is quite clear that the wind model within local weather has to be an approximation to the real situation. First, the windfield is assumed to always have horizontal components only - vertical air movement is simulated on top of the wind field by ridge lift generated from the Flightgear core and by thermals and turbulence as effect volumes.  <p>

In the horizontal windfield, aloft and bounday layers need to be distinguished. The aloft wind layers are high enough so that they do not interact with the terrain (and hence can be specified as a function of altitude above sea level), the low region where the aloft winds experience friction by interaction with the terrain and are slowed down constitutes the boundary layer. The boundary layer hence needs to be defined as a function of altitude above ground - it shifts as the elevation shifts. The size of the boundary layer, as well as its capacity to slow down aloft winds, depends on the roughness of the terrain. Over the open sea, the boundary layer is typically as small as 150 ft, while over rough terrain it can extend up to several hundred ft.<p>

When the option 'dynamical weather' is active, clouds and effect volumes move with the wind. Due to performance reasons, only clouds in the field of view are processed in each frame. As an efficient way to do this, a quadtree structure is used. However, this has the side effect that all clouds inside a tile need to be moved with the same windspeed (otherwise they would over time drift out of the position where the quadtree expects to find them). Since thermals and their cap clouds should not drift apart, also weather effects are moved with the same windspeed inside each tile. In the following, this is referred to as 'tile wind speed'. The tile wind speed always corresponds to the lowest aloft layer windspeed. The reason why this is considered acceptable is that at the same altitude for different positions inside a tile, the correct windspeed is at most a few kt different from the tile windspeed, and this is impossible to see visually. At high altitudes, the true wind is very different from the speed at which clouds are moved, but without reference and from fast-moving planes, the error is again very hard to see. However, with e.g. a hot air balloon, the fact that at high altitudes clouds are not moved with the high-altitude windspeed would be quite apparent.<p>

Dependent on how detailed the wind field should be specified, what the pilot aims to do and how much user control is desired, there are several options to model the wind outside the boundary layer:

<ul>
<li> <b>constant</b> sets the aloft wind to the same speed and direction as specified in the weather tile menu everywhere - at every spatial position and at every altitude. This is for the casual pilot who just wants some simple wind setting, or when it is mandatory that clouds, plane and weather effects all move with the same speed, such as for lighter-than-air aviation. Note that the wind set in the menu is not the wind seen on the runway, as the option sets the aloft wind, from which the boundary layer wind is computed using terrain information.<p>
<li> <b>constant in tile</b> keeps the wind equal to the tile windspeed, but allows to change randomly direction and strength a bit between tiles, so that the wind at the destination will not be equal to the wind at takeoff, but such that still the same wind is felt by aircraft, clouds and weather effects. The drawback of this option is that the wind changes discontinuously as a tile boundary is crossed (felt as a sudden gust) and that aloft winds do not change in altitude This model is suitable e.g. for gliders, when it is important that glider, thermal and cap cloud move with the same speed, high altitudes are out of reach anyway and a little variation in the wind is okay.<p>
<li> <b>aloft interoplated</b> requires the wind menu. Here, the wind is kept constant as a function of position, but is allowed to vary in altitude according to the information provided by the user for the different pressure altitudes. A linear interpolation in altitude is used. The option essentially provides the functionality of the default Flightgear weather conditions menu.<p>
<li> <b>aloft waypoints</b> finally allows to interpolate the windfield in altitude and in position according to the grid of interpolation points (or 'waypoints') entered by the user in the wind menu. The correct tile windspeed and direction is computed by the same interpolation. A linear interpolation in altitude and an inverse distance weighting for the interpolation in position are used. This is a suitable option for e.g. airliner operation when high altitude wind maps are available.<p>
</ul>


In all cases, the boundary layer is computed separately. Since the boundary layer effect depends on terrain, there is no direct way to set the wind as experienced on the runway (but of course changing the lowest aloft layer will lead to the desired result).

<h2>7. The METAR mode</h2>

The METAR mode allows to use live weather data together with the local weather package, which means that all user-defined weather parameters in the menu will not be parsed if this mode is selected. Some weather parameters (pressure, temperature, dewpoint) are straightforwardly passed on to the interpolation subsystem. For other parameters, the problem is more tricky.<p>

METAR information usually specifies cloud cover and altitude only, but does not mention the type of cloud to be placed. The purpose of the METAR heuristics subroutine is to decide what cloud patterns to place based on the available information. This routine for instance checks if there is an overcast layer above the lowest layer (which makes Cumulus development unlikely) or if the cloud cover is too strong for convective clouds given the time of the day. Once the heuristics has some idea of what the weather pattern indicated in the METAR string looks like, it starts to select cloud types to place into the individual layers. The heuristics is usually good, but certainly not perfect, it may occasionally go wrong and create implausible cloud configurations.<p>

The behaviour of winds depends on the selected wind model. In all cases, the wind in a METAR string is assumed to be the wind on the runway, i.e. the lowest aloft wind will be increased relative to the METAR info because the wind on the runway is subject to the boundary layer effect.<p>

<ul>
<li> <b>constant</b> uses the winds of the first METAR everywhere at all times
<li> <b>constant in tile</b> uses the winds of the first METAR in all tiles until the next METAR becomes available, then uses the new value for all tiles till yet another report becomes available. To maintain the internal coordinate system, intermediate tiles may be generated which do not immediately show the new wind
<li> <b>aloft interpolated</b> is not supported by the METAR mode - this makes no sense, as METAR does not report aloft winds
<li> <b>aloft waypoints</b> uses a plausible guess for the aloft winds based on the surface winds. In general, higher aloft winds become stronger and turn somewhat dependent on the Coriolis effect. Based on the interpolation points generated in this way, the windfield at each tile center determines the tile wind direction for the visual cloud movement.
</ul>

The METAR mode currently does not support all types of reported weather. The weather is not changed when the same station makes a different report, only if a new station comes in range. Note that the METAR mode cannot be used for Flightgear 2.0.0!<p>

<h2>8. Program and property tree structure</h2>

The program runs in a number of loops which operate at different timescales - some tasks require attention in every frame, others may wait for a number of seconds. The main loops are:<p>

<ul>
<li><b>Effect volume loop:</b> Determines if the plane is inside an effect volume and executes its action
<li><b>Interpolation loop:</b> Interpolates the weather parameters in space, takes care of the altitude model of the visibility and of the wind boundary layer effects (see Appendix for details)
<li><b>Tile management loop:</b> Controls the generation of new tiles and the removal of old ones.
<li><b>Buffer loop and housekeeping loop:</b> Move clouds out of the buffer into the scenery and back.
<li><b>Quadtree loop:</b> Determines which clouds are inside the field of view and moves them with the tile windspeed.
<li><b>Dynamics loop:</b> Moves effect volumes, tile centers and interpolation points with the windfield, ages convective clouds in their lifecycle.
<li><b>Convective loop:</b> Periodically re-creates convective clouds to compensate for the decaying clouds.
</ul>

All other subroutines are called by one of these loops. <p>

The internal state of the local weather system is found in the property tree under <i>local-weather/</i>. In this directory, various loop flags are found. They indicate the state of the main monitoring loops - they are set to 1 if a loop is running, setting them to zero terminates the loop.<p>

The <i>local-weather</i> folder contains various subdirectories. <i>clouds/</i> contains the record of all visible weather phenomena (clouds, precipitation layers, lightning...) in a subdirectory <i>tile[j]/cloud[i]/</i>. The total number of all models placed is accessible as <i>local-weather/clouds/cloud-number</i>. Inside each <i>cloud/</i> subdirectory, there is a string <i>type</i> specifying the type of object and subdirectories <i>position/</i> and <i>orientation</i> which contain the position and spatial orientation of the model inside the scenery. Note that the orientation property is obsolete for clouds which are rotated by the shader.<p> 

The <i>local-weather/effect-volumes/</i> subfolder contains the management of the effect volumes. It has the total count of specified effect volumes, along with the count of currently active volumes for each property.<p>

<i>local-weather/interpolation/</i> holds all properties which are set by the interpolation system. Basically, here is the state of the weather as it is outside of effect volumes. Since parameters may be set to different values in effect volumes, the folder <i>local-weather/current/</i> contains the weather as the local weather system currently thinks it should be. Currently, weather may be passed to the Flightgear environment system through several workarounds, dependent on the Flightgear core version.<p>

<i>local-weather/tiles</i> stores the information of the 9 managed weather tiles (the one the airplane is currently in, and the 8 surrounding it). By default each directory contains the tile center coordinates and a flag if it has been generated. Tiles are not generated unless a minimum distance to the tile center has been reached. Once this happens, the tile type is written as a code, and the cloud, interpolation and effect volume information corresponding to the tile is generated. <p>



<h2>9. Weather tile setup</h2>

Examples for weather tile setup can be found in <i>Nasal/weather-tiles.nas</i>. Each tile is generated by a sequence of Nasal function calls to first set weather stations, then to draw the cloud layers, and effect volumes. It is a bit awkward to have to write in Nasal to customize the system, but I can't think of a reasonable GUI for the task, except marking every placement on a map which exceeds my coding skills a bit. The problem is that there is no real standard solution - every weather tile needs different calls, sometimes a large one generating many clouds, sometimes several smaller ones.<p>

The first important call sets up the conditions to be interpolated:<p>

<i>set_weather_station(latitude, longitude, visibility-m, temperature-degc, dewpoint-degc, pressure-sea-level-inhg);</i><p>

The atmosphere light propagation needs to be prepared as well by a call<p>

<i>set_atmosphere_ipoint(latitude, longitude, vis_aloft, vis_alt_aloft, vis_overcast, overcast,overcast_alt_low, overcast_alt_high, scattering, scattering_alt_low, scattering_alt_high);</i><p>

The meaning of these parameters is as follows: Visibility is linearly interpolated in altitude between several altitudes: the ground value is given in the weather station call. <i>vis_aloft</i> determines the visibility after passing the lowest inversion layer (i.e. usually the lowest cloud layer altitude) where the visibility suddenly increases. The altitude of the transition is given by <i>vis_alt_aloft</i>. The visibility higher up is determined by high-altitude haze, i.e. it takes the value <i>vis_overcast</i> at the position <i>overcast_alt_high</i> (the upper edge of the haze layer) and increases with constant rate from there. The amount of high-altitude haze is given by <i>overcase</i>, a number between 0 and 1, and the position of the layer is determined by <i>overcast_alt_low</i> and <i>overcast_alt_high</i>. Above the second value, the skydome is no longer coloured. Finally, <i>scattering</i> determines the amount of light reaching the surface (between 0 and 1, reasonable values range from 0.5 to 1) and the following altitudes specify where the layers casting shadow are found - there is always the full amount of light available above <i>scattering_alt_high</i>. See the appendix for details of the model.<p>

The cloud placement calls should be reasonably familiar, as they closely resemble the structure by which they are accessible from the 'Local Weather (Test)' menu.<p> 

If the cloud layer has an orientation, then all placement coordinates should be rotated accordingly. Similarly, each placement call should include the altitude offset. Take care to nest effect volumes properly where possible, otherwise undesired effects might occur...<p>

To make your own tile visible, an entry in the menu <i>gui/dialogs/local_weather_tiles.xml</i> needs to be created and the name needs to be added with a tile setup call to the function <i>set_tile</i> in <i>Nasal/local_weather.nas</i>.

<h2>10. Performance tuning</h2>

With default settings, the local weather package generates a 40x40 km weather tile when the aircraft is closer than 39 km to the tile center and unloads it when the aircraft is more than 39.5 km away. This means that the system can generate at most 4 tiles at once and clouds are visible for at least 19 km and up to 45 km (the latter number determined by fading in the shaders). However, rendering and managing multiple overcast cloud layers in a region of 80x80 km is a significant drain on performance. For older systems, a few things can be done:<p>

<ul>

<li> the menu option 'asymmetric range' decreases loading and unloading ranges in a 90 degree sector behind the aircraft. This means that in straight flight, less tiles will be loaded at the same time, as tiles in the rear are unloaded more quickly. <p>

<li> a further reduction in the amount of simultaneously generated tiles can be achieved by changing the range for tile loading and unloading in the menu. Ranges below 20 km will guarantee that only one tile is loaded at a time, but will create empty spots when no tile is loaded. A range above 28 km will guarantee that the aircraft never flies in an empty tile, but empty sky in front will be visible. Finally, ranges above 56 km would guarantee that all 9 tiles (a region of 120x120 km) are managed at all times - but will most likely cause a severe drop in framerate for most scenarios and is currently not possible from the menu.<p>

<li> a further reduction in workload can be achieved by lowering the visibility range of clouds in the menu. This helps significantly, as clouds in the buffer array do not take significant processing power. Note that this can be done at runtime. Agressive buffering of the rear hemisphere can gain another 20-30% performance, but is only suitable for flying a straight course.<p>

<li> if this does not help, try avoiding scenarios with large cloud count. As a rule, low pressure areas have high cloud count, high pressure areas have a low cloud count. Do not use 'detailed clouds', which tend to generate large cloud counts.<p>

<li> a different issue is a characteristic small pause every  second. This may be caused by the interpolation loop resetting the weather parameters or by the altitude correction of convective clouds when cloud count is high and wind drift is on. The first issue only occurs when the system did not find hard coded support. There is no easy fix for the second problem, except to avoid dynamical weather in situations with large cloud counts.
 <p>

<li> dynamical weather uses a lot of performance. If framerate is low and you don't need it, don't use it! From fast planes, cloud drift is almost impossible to see against the relative motion of cloud and airplane anyway.<p>

</ul>

<h2>11. Known issues</h2>

<ul>

<li> [2.0.0] The local weather system does not mix well with the standard weather system. 3d cloud layers can be placed in the absence of effect volumes, but any effect volume causing precipitation will let the layer behave in a strange way. Likewise, 2d cloud layers can be placed, but may or may not lead to strange rendering artefacts. Local weather, as long as interpolation and effect volumes are running, will in general overwrite all other settings - bother real weather METAR and user-specified settings from the menu. The results of mixing standard and local weather settings are unpredictable, and may not lead to the desired results.<p>

<li> Some cloud textures have artefacts, rain textures have too sharp boundaries and in general some things could look better. Please don't complain, but rather get me good photographs of the sky, cloud texture files or create better AC3D cloud models. I will eventually improve texture quality, but it's not high up in the to-do list, and the cloud model files are openly accessible for anyone with an editor.<p>

<li> [2.0.0] Rain and snow may not start properly. For me, rain is only generated when I switch 'Shader effects' on and off in the menu on startup, otherwise neither moving the menu slider nor entering an effect volume generate rain. This seems to be a bug of some Flightgear versions, not of the local weather system.<p>

<li> [2.0.0] Especially with multiple overcast layers and weather fronts, loading and unloading weather tiles may take a long time / cause severe drops in framerate. It seems that a dual core processor is very valuable with this particular issue - try switching multiprocessor support on if needed, otherwise please refer to performance tuning to solve such problems. In more recent versions of Flightgear, an activated texture cache improves performance dramatically. In general, overcast layers and tropical weather tiles do require a system on the high end of the performance scale to render properly.<p>

<li> The local weather package is able to occasionally trigger errors like 'Warning:: Picked up error in TriangleIntersect'. These seem to be a problem in the core Flightgear code - the package does nothing but placing normal (rather simple) AC3D models into the scenery.<p>

<li> For dynamical weather, clouds sometimes appear to 'jump' to a position. The reason is that the control loop of cloud drift accepts for performance reasons only a limited number of clouds. If there are more in the field of view, the most distant clouds are not processed. As nearby clouds drift out of the visual field, more distant clouds move into the loop, at which point their position is suddenly updated, resulting in a jump. Short of committing potentially vast computational resources (if there is a large number of clouds in the visual field), there is no easy fix to the problem.<p>

<li> [2.0.0] To smooth out changes in wind settings, rather than producing a sudden gust, the wind is changed over about 1 second. In sharp wind gradients, this produces a series of ripples like turbulence. This is actually a realistic behaviour in this situation and hence left as it is. Some systems seem to take an unreasonable effort to reinit the environment (as must be done to set wind) - here the function call <i>setWindSmoothly()</i> in <i>local_weather.nas</i> should perhaps be replace by <i>setWind</i> to ease the load.<p>

<li> [2.0.0] Large tile creation distances can cause problems in low visibility weather, because Flightgear loads terrain only if it is within visual range. Thus, trying to sample the terrain for a tile 55 km away in 8 km visibility doesn't work because the terrain elevation and altitude is not known. This may cause improper placement of clouds - chiefly convective clouds, but also layered clouds may not appear on the proper altitude. Currently, there is a limit which restricts tile loading range to 3 times the visibility, but presumably a better solution can be found.<p>

<li> Using the 'aloft interpolated' wind option, it is possible to turn the wind direction sharply over a small distance (for example, one may turn the wind by 90 degrees from one tile to the next). Such sharp wind changes are (in most situations) unphysical, and they may cause problems for local weather because they rotate the coordinate system to a degree that the neighbouring tile may not be identified correctly. In essence, the system may not generate new tiles because the nearest tile is still the last generated one. The system largely tries to detect the problem and compensate, but occasionally this may be an issue.<p>

<li> [2.0.0] The thermals in the soaring scenarios need GIT to work.<p>

<li> [2.0.0] No support for live weather data.<p>

<li> [2.0.0] No change of light saturation. <p>

<li> Currently, the light conditions need to be changed globally. This works fine for an 8/8 overcast layer, as there is little light on the ground, the light increases during the layer transition and is full above the layer. However, the effect is less than perfect for broken layers, as one can observe the ground during descent getting darker. A full solution to the problem would be (computationally rather demanding) individual cloud shadows rather than an average shading of the whole terrain, but as it stands, this is currently not feasible.


</ul>

<h2><a name="appendix_A">Appendix A: An introduction to the algorithms</a></h2>

This section describes the more complicated cloud placement algorithms in some detail. It is intended for readers who are interested in understanding (and possibly modifying) what creates the weather they get to see. 

<h3>The convective startup algorithm and the properties of thermals</h3>

The convective startup algorithm is used to place Cumulus clouds as well as thermals. Thermals are by default not placed to save CPU time unless the flag is set in the menu.<p>

At the core of the convective algorithm is the concept of locally available thermal energy. The source of this energy is solar radiation. The flux of solar energy depends on the angle of incident sunlight with the terrain surface. It is possibly (though computationally very expensive) to compute this quantity, but the algorithm uses a proxy instead. The daily angle of the sun at the equator assuming flat terrain is modelled as <i>0.5 * (1.0-cos(t/24.0*2pi))</i> with t expressed in hours, a function that varies between zero at midnight and 1 at noon. There is a geographical correction to this formula which goes with <i>cos(latitude)</i>, taking care of the fact that the sun does not reach the zenith at higher latitudes. Both the yearly summer/winter variation of the solar position in the sky and the terrain slope are neglected.<p>

However, the incident energy does not equal the available energy, since some of this energy is reflected back into space, either by high clouds, or by the terrain itself. The reflection by high clouds is not explicitly included in the algorithm - but since in creating a weather tile, one must setup both the high altitude clouds and the convective system, it can easily be included approximately by calling the convective system with a strength that is reduced according to the density of high-altitude clouds. The reflection by the terrain is encoded in the probability <i>p</i> that a given landcover will lead to a thermal. <i>p</i> ranges from 0.35 for rock or concrete surface which heat very well in the sun to  0.01 over water or ice which reflect most of the energy back into space.<p>

The algorithm now tries to place a number <i>n</i> of clouds in a random position where <i>n</i> is a function of the user-specified strength of development, modified by the daily and geographical factors as described above. However, a cloud is only placed at a position with probability <i>p</i>, so a call to the convective system over city terrain will lead to significantly more clouds than a call with the same strength over water.<p>

The next task is to determine how the available thermal energy is released in convection across different thermals. There can be for example many weak thermals, or few strong thermals for the same energy. The empirical observation is that the number of thermals and clouds peaks around noon, whereas the strength of thermals peaks in the afternoon. The algorithm thus assigns a strength <i>1.5 * rand() + (2.0 * p))</i> to each cloud, which is again modified by a sinusoidal function with a peak shifted from noon to 15:30.<p>

Based on this strength parameter <i>s</i>, a cloud model is chosen, and the maximal thermal lift (in ft/s) is calculated as <i>3 + 1 * (s -1)</i> (note that this means that not every cloud is associated with lift). By default, the radius of thermals is assumed to range from 500 to 1000 m. The slider 'thermal properites' in the menu allows to modify the balance between radius and lift from these values. Since the flow profile in a thermal is approximately quadratic, requiring the same flux means that increasing the maximal lift by a factor <i>f</i> leads to a radius reduced by <i>1/f</i>. Moving the thermal properties slider to 'rough day' thus generates narrow thermals with large maximal lift and sink (which are more difficult to fly), moving it to low convection instead generates large thermals with weak lift.<p>

The following series of pictures, taken over KLSV (Nellis AFB, Las Vegas) illustrates the algorithm at work.<p>

At 7:00 am, the thermal activity is weak, and there is no lift available in thermals yet.<p>

<center>
<img src="img/./KLSV-7_00.jpg">
</center><p>

Some activity starts around 10:00 am the average available lift is 0.3 m/s, the more active clouds tend to be above city terrain.

<center>
<img src="img/KLSV-10_00.jpg">
</center><p>

At 12:00 noon, the maximal cloud number is reached. The average available lift is 1 m/s, in peaks up to 2 m/s.

<center>
<img src="img/KLSV-12_00.jpg">
</center><p>

The maximum of lift strength is reached close to 15:00 pm. The average lift is now 1.5 m/s, in peaks up to 3 m/s, and the strong convection leads to beginning overdevelopment, some clouds reach beyond the first inversion layer and tower higher up. At this point, the clouds may also overdevelop into a thunderstorm (which is not modelled explicitly by the convective algorithm as it requires somewhat different modelling, but is taken into account in the weather tiles).<p>

<center>
<img src="img/KLSV-15_00.jpg">
</center><p>

At 17:30 pm, the lift is still strong, 1.5 m/s on average and 2.5 m/s in peaks, but compared with the situation at noon, there are fewer clouds with stronger lift.<p>

<center>
<img src="img/KLSV-17_30.jpg">
</center><p>

At sunset around 19:00 pm, the number of clouds decreases quickly, but there is still a lot of residual thermal energy (the ground has not cooled down yet), therefore thermal lift of on average 1 m/s is still available even without solar energy input.

<center>
<img src="img/KLSV-19_00.jpg">
</center><p>

While not accurate in every respect, the model works fairly well to reproduce the actual time dependence of convective clouds and thermal lift during the day.<p>

<h3>The convective dynamics algorithm</h3>

The convective dynamics algorithm is responsible for modelling the life cycle of convective clouds, dependent on the terrain type underneath. It meshes well with the convective startup algorithm, and its long-term zero wind limit is just the situation set up by the initial convective placement.<p>

At its heart is the idea of fractional cloud lifetime. A cloud is born with fractional lifetime zero, and it decays once its fractional lifetime reaces 1. The translation of real time to fractional lifetime is given by <i>sqrt(p)</i> where <i>p</i>  is the landcover dependent probability defined above. A cloud over landcover with maximum <i>p</i> of 0.35  has a lifetime of 30 minutes, so if a cloud spends 10 minutes over this terrain type, its fractional lifetime is increased by 1/3. If the landcover is different, the lifetime is reduced according to <i>sqrt(p_1/p_max)</i>.<p>

A cloud field is initialized with fractional lifetimes randomly distributed between zero and 1. To compensate for the decay of clouds, clouds are periodically respawned as in the startup algorithm, but with placement probability <i>sqrt(p)</i> instead of <i>p</i>. In the limit of no wind, the cloud density over a terrain type is then given by placement probability times lifetime, i.e. <i>sqrt(p) * sqrt(p) = p</i> as it should be. The presence of a windfield distorts the cloud distribution, dense clouds are then found preferably downwind of suitable convection sources.<p>

<h3>The thermal lift model</h3>

The model of the distribution of lift inside a thermal is quite complex. <p>

<center>
<img src="img/thermal_lift.gif">
</center><p>

Vertically, is is characterized in addition to height and radius by two parameters, 'coning' and 'shaping', which make it cone-shaped and wasp-waisted. From zero to 200 m above ground, the lift is smoothly fading in, above the cloudbase it is smoothly faded out to zero at 10% above the nominal altitude. Horizontally, there is an outer ring where the air becomes turbulent, followed by a region of sink which in turn is followed by the inner core of lift.<p>

The distribution of lift and sink is time dependent. 

<center>
<img src="img/thermal_lift_time.gif">
</center><p>

In a young thermal, lift starts to develop from the ground, sink is initially absent. When the lift reaches the cloudbase, sink starts to develop from the ground and rises up as well. Only in a mature thermal are sink and lift in equilibrium. When the thermal starts to decay, lift initially decays from the ground upward, till it reaches the cloudbase. At this time the cap cloud dissolves. For a time there is a residual distribution of sink decaying from bottom to top till the thermal evolution is over and the thermal (and the associate turbulence field) is removed.<p>

<h3>The terrain presampling and cloud altitude determination algorithm</h3>

While the meaning of a cloud layer altitude is rather obvious in level terrain, this quickly becomes a highly non-trivial question in mountaineous terrain where the elevation of the terrain is more difficult to define. Observation of weather patterns in mountain regions suggests that clouds follow changes in terrain elevation to some degree, but not all cloud types do to the same degree. While convective clouds follow a change in elevation more readily even on small distance scales, layered clouds don't do so. The purpose of the terrain presampling and cloud altitude determination algorithm is to capture this behaviour as closely as possible.<p>

In nature, what determines the altitude of various clouds are the properties of air layers. In general, clouds become visible at the condensation altitude, i.e. when temperature and dew point merge and the relative humidity of air exceeds 100%. In conditions where there is a lot of vertical air movement (i.e. for Cumulus clouds), the conditions are much more local than in situations with lack of vertical movement (i.e. for layered clouds).<p>

In the algorithm, various proxies for the structure of air layers and hence the condensation altitude are used. It is assumed that air layers must follow the general slope of the terrain (because there is nowhere else to go), but can (at least to some degree) flow around isolated obstacles. To get the general layout of the terrain, the algorithm first samples the altitude of an 80x80 km square around the 40x40 weather tile to be created. The choice of a larger sampling area reduces the sensitvity of the outcome to purely local terrain features and prevent pronounced transitions from one tile to the next. The result of this sampling is a distribution of probability to find the terrain at a given altitude:<p>

<center>
<img src="img/terrain1.jpg">
</center><p>

For instance, the terrain around Geneva is mostly flat around 1000 ft (where the peak of the distribution lies) with some mountains up to 4500 ft nearby. Based on such distributions, the algorithm next determines the minimum altitude <i>alt_min</i>, the maximum altitude <i>alt_max</i>, the altitude below which 20% of the terrain are found <i>alt_20</i> and the median altitude below which 50% of the terrain are found <i>alt_med</i>.<p>

Cumulus clouds are always placed at a constant altitude above <i>alt_20</i>. This is done to ensure gorges and canyons do not provide a minimum in otherwise flat terrain so that clouds appear down in the gorge as opposed to on the rim where they would naturally occur. Basically, layers are assumed not to trace too fine structures in the terrain, so at least 20% of the terrain are required. In the test case of Grand Canyon, the algorithm correctly places the clouds at rim altitude rather than down in the canyon:

<center>
<img src="img/cloud_altitude_02.jpg">
</center><p>

However, convective clouds are given some freedom to adjust to the terrain. The maximally possible upward shift is given by <i>alt_med - alt_20</i>. This is based on the notion that above <i>alt_med</i>, the terrain is not a significant factor any more because the air can simply flow around any obstacle. However, this maximal shift is not always used - if the cloud is placed far above the terrain in the first place, it would not follow the terrain much. Thus, a factor of <i>1000 ft / altitude above terrain</i>, required to be between 0 and 1, modifies the shift. As a result, a cloud layer placed high above the terrain has no sensitivity to terrain features. The result of this procedure is that clouds show some degree of following terrain elevation, as seen here in Grenoble<p>

<center>
<img src="img/cloud_altitude_03.jpg">
</center><p>

but they do not follow all terrain features, especially not single isolated peaks as seen here at the example of Mt. Rainier:

<center>
<img src="img/cloud_altitude_01.jpg">
</center><p>

Finally, layered clouds have essentially no capability to shift with terrain elevation. Moreover, they are caused by large-scale weather processes, hence they do not usually shift upward over even large mountain massives. Currently, the model places them at <i>0.5 * (alt_min + alt_20)</i> base altitude in order to retain, even in mountains, the sensitivity to the flat terrain surrounding the massiv. usually this works well, but may have a problem with gorges in flat terrain. The following picture shows a Nimbostratus layer close to Grenoble:<p>

<center>
<img src="img/cloud_altitude_04.jpg">
</center><p>

<h3>The offline large scale weather pattern</h3>

The local weather package generates semi-plausible weather changes even in the absence of METAR information. These weather patterns are encoded in an algorithm governing the rules which weather tiles can have common borders.<p>

Weather tiles are classified chiefly by air pressure. What is currently in the models are three classes for a low pressure system, four different classes for the system of weather fronts and airmasses spiralling into the low pressure system and three classes for a hugh pressure system. The general rule is that low pressure tiles contain layered clouds, overcast skies and rain whereas the high pressure tiles contain clear skies and few convective clouds. The topology assumed for the weather system is apparent in the following diagram:

<center>
<img src="img/weather_patterns.jpg">
</center><p>

A transition between classes is possible whenever a class has a common border. However, if a transition actually takes place is probabilistic. Typically, the probability not to make a transition is about 80%. Since changes are only triggered for weather tiles one is actually in, the average distance over which weather patterns persist is 160 km. An exception to this are fronts - weather front tiles trigger changes based on direction rather than probability, so a warmfront will always be a sequence of 4 tiles, a coldfront will always be a small-scale phenomenon crossed within 30 km.

To avoid unrealistically large changes in pressure when generating a transition and randomly sampling central pressure in tiles from two different pressure classes, a monitoring algorithm limits the pressure difference between tiles to 2 mbar and ensures a slow transition from high pressure to low pressure regions.<p>

The weather algorithm is currently not able to handle the transition to tropical weather in the Hadley cell close to the equator, although tropical weather exists as a standalone tile and can be used in repetitive mode.<p>

<h3>The boundary layer computation</h3>

The boundary layer is only dynamically computed when 'terrain presampling' is active (otherwise the weather system has no information of the terrain and a schematic reduction of aloft winds by 2/3 is used instead). The assumption is that the boundary layer at median altitude has a thickness of 150 ft. Below the median altitude, the boundary layer is assumed to grow with 1/3 of the altitude difference, but to no more than 3000 ft while above it is assumed to shrink with 10% of the altitude difference, but to no more than 50 ft. <p>

The boundary layer effectiveness, i.e. the amount of windspeed reduction at the layer bottom is assumed to vary logarithmically with thickness - thicker layers are more effective, but not dramatically so. Over open water, the layer thickness is hence about 150 ft with a maximal reduction of 10%, in deep valleys the reduction factor can be as large as 70%. The interpolation of wind reduction inside the boundary layer is done linearly.<p>

Realistically, the boundary layer should also depend on terrain coverage. Due to the need for performance to sample terrain coverage in the vicinity of the aircraft frequently, this is currently not implemented.<p>

Gusty winds are assumed to be a bounday layer phenomenon and faded out to zero at a multiple of the boundary layer thickness which is given by <i>base wind speed [kt]/10</i>, i.e. for 25 kt winds the gusts are absent for 2.5 times the bounday layer thickness.<p>

<h3>Light propagation in the atmosphere</h3>

Relatively low visibility (as reported by METAR) is usually confined to low altitudes, due to the lower density of the upper atmosphere and the reduced level of dust and water the visibility at airliner cruise altitude is frequently in excess of 100 km. This means that an altitude model of the visibility is needed.<p>

The following schematics illustrates the essential features of the light propagation model:<p>

<center>
<img src="img/light_model.gif">
</center><p>

The parameters to be set are <i>overcast</i> (the amount of colouring of the skydome, from 0 (no haze) to 1 (completely opaque)), <i>visibility</i> and <i>light</i> (the amount of light available, determining the shade of faraway objects). The assumptions underlying the model are:

<ul>
<li> The visibility increases above the lowest inversion layer quite rapidly. It can then be manually set up to a high-altitude haze layer (to account for phenomena such as weather fronts where a low-visibility airmass may be above), but increases with constant rate higher up.
<li> The high-altitude visibilities are not realistic, but kept artificially low to avoid framerate problems connected with excessive terrain loading.
<li> For the amount of light, a single transition region can be specified. This usually is the lowest inversion layer, but doesn't have to - for multiple layers, a more democratic choice can be made. Above the transition region, the full amount of light is always assumed.
<li>Currently, a single high-altitude haze layer is supported, and it's transition altitude can be given. No haze is simulated above it's highest altitude.

</ul>

<h2>Credits</h2>

The model of a thermal has been developed by Patrice Poly. The shader code used to transform clouds is heavily based on prior work by Stuart Buchanan. Hard-coding of some features by Torsten Dreyer, Thorsten Brehm and Erik Hofman is greatly appreciated.<p>


Thorsten Renk, June 2011

</body>


</html>


--- End of README.local_weather.html ---


--- Start of README.logging ---

Logging in FlightGear
---------------------

[Note: JSBSim also has its own independent logging facilities, which
are not discussed here.]

FlightGear can log any property values at any interval to one or more
CSV files (which can be read and graphed using spreadsheets like
Gnumeric or Excel).  Logging is defined in the '/logging' subbranch of
the main property tree; under '/logging', each '/log' subbranch
defines a separate log with its own output file and interval.  Here is
a simple example that logs the rudder and aileron settings every
second (1000ms) to the file steering.csv, using a comma (the default,
anyway) as the field delimiter:

<PropertyList>
 <logging>
  <log>
   <enabled>true</enabled>
   <filename>steering.csv</filename>
   <interval-ms>1000</interval-ms>
   <delimiter>,</delimiter>
   <entry>
    <enabled>true</enabled>
    <title>Rudder</title>
    <property>/controls/flight/rudder</property>
   </entry>
   <entry>
    <enabled>true</enabled>
    <title>Ailerons</title>
    <property>/controls/flight/aileron</property>
   </entry>
  </log>
 </logging>
</PropertyList>

Each 'log' subbranch contains a required 'enabled' property, an
optional 'filename' property (defaults to "fg_log.csv"), an optional
'delimiter' property (defaults to a comma), an optional 'interval-ms'
property (defaults to 0, which logs every frame), and a series of
'entry' subbranches.  The 'delimiter' property uses only the first
character of the property value as the delimiter.  Note that the
logger does no escaping, so you must choose a delimiter that will not
appear in the property values (that's not hard, since most of the
values are numeric, but watch for commas in the titles).

Each 'entry' subbranch contains a required 'enabled' property, a
'property' property specifying the name of the property to be logged,
and an optional 'title' property specifying the title to use in the
CSV file (defaults to the full path of the property).  The elapsed
time in milliseconds since the start of the simulation is always
included as the first entry with the title "Time", so there is no need
to include it explicitly.

Here's a sample of the logging output for the above log:

  Time,Rudder,Ailerons
  6522,0.000000,0.000000
  7668,-0.000000,0.000000
  8702,-0.000000,0.000000
  9705,-0.000000,0.000000
  10784,-0.000000,0.000000
  11792,-0.000000,0.000000
  12808,-0.000000,-0.210000
  13826,-0.000000,-0.344000
  14881,-0.000000,-0.066000
  15901,-0.000000,-0.806000
  16943,-0.000000,-0.936000
  17965,-0.000000,-0.534000
  19013,-0.000000,-0.294000
  20044,-0.000000,0.270000
  21090,-0.000000,-1.000000
  22097,-0.000000,-0.168000

Note that the requested interval is only a minimum; most of the time,
the actual interval is slightly longer than the requested one.

The easiest way for an end-user to define logs is to put the log in a
separate XML file (usually under the user's home directory), then
refer to it using the --config option, like this:

  fgfs --config=log-config.xml

The output log files are always relative to the current directory.

--

David Megginson, last updated 2002-02-01

--- End of README.logging ---


--- Start of README.materials ---

README.materials

This README describes the materials.xml file format. It is targeted at those
wanting to change the appearance of the scenery in FlightGear.

The materials file used by FlightGear is set in the /sim/rendering/materials-files
property.  It is read on startup, and can be reloaded in-sim from the
"Reload Materials" item in the Debug menu.

The materials file consists of one or more <region> elements.  Each <region>
contains one or more geographical <area> elements, defining a rectangle
(lat1/lon1, lat2/lon2), and a set of <material> elements which describes a
single visually distinct terrain material in the FG world which will be used to
render one of more scenery landclasses (for example Grass or Town).  When determining
the material to use for a given landclass at a given lat/lon, the <region> elements
are checked in order and the <condition> element of the materials evaluated.  The
_last_ matching material definition is used.  So more specific regions and materials
definitions should be put towards the bottom of the materials file.

The rest of this document describes the children tags of the <material> entry.

name : Scenery type names that map to this material. These are typically taken
       from landclass definitions created by TerraGear. Multiple scenery types
       may map to a single material. This is recommended to minimize texture
       memory usage.

condition : A condition statement used to activate the material. Note that this
       if evaluated once at start-up.

texture : A relative path to an SGI RGB, PNG or DDS file containing a texture
       for the material. RGB and PNG are recommended for platform compatibility.
       You may define more than one <texture> element, in which case the scenery
       loader will choose one texture for each contiguous set of scenery
       triangles.

texture-set : If using an effect (see below), it may be necessary to define more
       than one texture.  The texture-set element has multiple <texture> element
       children which may then be referenced by the effect. You may define more
       than one <texture-set> element, in which case the scenery loader will
       choose one texture for each contiguous set of scenery triangles.

object-mask : An optional bitmap file used to control random placement of lights,
       buildings and vegetation on the terrain.  The green channel mask is used
       for random vegetation placement, the blue channel for buildings and lights.
       and the red channel controls the rotation of buildings (0.0 is North, 0.5
       is South). Fractional colour values can be used to give a probability of
       placement. Multiple object-masks may be defined to match up with <texture>
       or <texture-set> elements.

effect : The effect to be used for this material. (default:
       Effects/terrain-default)

       ambient, diffuse, specular, emissive, and shininess are copied into the
       parameter section of the effect created for this material.

parameters : Additional parameters to be used in the effect. See README.effects
            for format information.

wrapu : True if the texture should repeat horizontally over a surface, false if
       it should not repeat (default: true).

wrapv : True if the texture should repeat vertically over a surface, false if
       it should not repeat (default: true).

mipmap : True if the texture should be mipmapped, false otherwise. (default: true).

xsize : The horizontal size of a single texture repetition, in meters.

ysize : the vertical size of a single texture repetition, in meters

light-coverage : The coverage of a single point of light in m^2. 0 indicates no
        lights at all. Minimum value is 1000m^2. May be masked by the blue channel
        of an object-mask. Lights are all generated 3m above the surface, and
        have random colour (50% yellow, 35% white, 10% orange, 5% red)

ambient : The ambient light colour for the material, specified as separate
        r, g, b, a components (default: all color components 0.2, alpha 1.0).

diffuse : The diffuse light colour for the material, specified as separate
        r, g, b, a components (default: all color components 0.8, alpha 1.0).

specular : The specular light colour for the material, specified as separate
        r, g, b, a components (default: all color components 0.0, alpha 1.0).

emissive : The emissive light colour for the material, specified as separate
        r, g, b, a components (default: all color components 0.0, alpha 1.0).

solid : Whether the surface is solid from an FDM perspective. If it is not
        solid, it is assumed that the material models a fluid (water) surface.
        (default: true).

friction-factor : The friction factor for that material. The normalized
        factor can be used by a FDM to post-multiply all contact friction forces
        with that factor. That is the more slippery a material is the smaller
        this value should be. (default: 1.0 for Dry concrete/Asphalt).

rolling-friction : the gear rolling rolling-friction coefficient for this
        particular material. (default: 0.02 for Dry concrete/Asphalt).

bumpiness : normalized bumpiness factor for this particular terrain.
        (default: 0.0 for a smooth surface).

load-resistance : a pressure value how much force per surface area this
        surface can carry without deformation. The value should be in N/m^2
        (default: 1e30).

glyph : group that defines one letter/digit/symbol in a font texture
        sub-entries: name, left (default: 0.0), right (default: 1.0)
        (left and right describe the horizontal position in the texture.)

wood-coverage : The coverage of trees in areas marked as woodland in
         m^2. A lower number means a higher density of trees. A value of
         0 indicates no woods. May be masked by the green channel of an
         object-mask. (default: 0)

tree-range-m : The range at which trees become visible. Note that this
         is not absolute, as trees are loaded in blocks. A lower number means
         trees will not become visible until you are closer.

tree-texture : A texture to use for the trees. Typically this will contain around
         8 different trees in a row, duplicate 4 times. From bottom to top, the
         rows contain
         * summer textures
         * summer snow texture
         * winter texture
         * winter snow texture

         Each tree must have space at the top. For a 512x512 texture sheet, this
         should be 8 pixels.  Otherwise subsequent rendering results in "top hats"
         above trees in the distance where the trunk of the tree above in the
         textures sheet bleeds downwards when the mipmaps are generated.

tree-varieties : The number of different trees defined in the tree-texture
         horizontally. (default: 1)

tree-height-m : The average height of the trees. Actual tree height will
         vary by +/- 50%. (default: 0)

tree-width-m : The average width of the tree cover. Actual tree width will
         vary by +/- 50%. (default 0)

tree-max-density-angle-deg : The slope angle at which trees begin to thin out
         as the slope is too steep to support the full coverage. Shallower
         slopes have maximum wood-coverage.  Steeper slopes have fewer trees.
         (default : 45)

tree-zero-density-angle-deg : The angle at which the slope is too steep to
         support significant vegetation.  Steeper slopes have no trees.
         (default : 60)

object-max-density-angle-deg : The angle at which objects and buildings become
         less dense due to a steep slope. (default : 20)

object-zero-density-angle-deg : The angle at which the slope is too steep to build
         on.  No object/buildings will be placed on slopes steeper than this.
         (default : 30)

object-group : A group of random objects to be placed on the surface. Contains
         <range-m> and one or more <object> children.

range-m : The distance at which objects within this object-group become
         visible. Note that for realism, 60% of the objects will become visible
         at <range-m>, 30% at 1.5*<range-m>, and 10% at 2*<range-m>.
         (default: 2000)

object : A set of random objects to be placed. Contains <coverage-m2>, <path>
         and <heading> children.

coverage-m2 : The coverage of a single object in m2. Lower values mean a higher
         density. Minimum value is 1000.

spacing-m : The minimum space between this object and any other on the surface in
         meters. This helps to avoid objects being placed ontop of each other.
         (default 20)

path :   Path relative to FG_ROOT to a model definition, usually .ac or .xml file.
         More than one <path> may be included within the <object> tag, in which
         case a single <path> is chosen at random for each individual object
         placement.

heading-type : Indicator of how the heading of the random objects should be
         determined. Valid values are:
           fixed     - Objects all point North. Default.
           random    - Objects are assigned an individual random heading
           mask      - Rotation is taken from the red channel of the object-mask
           billboard - Object is always rotated to face camera - expensive


Random Buildings
================

Random Buildings come in three sizes, with individual constraints.

Small buildings.  These have different textures on the sides compared to the front
and back.  Small buildings are never deeper than they are wide.

Medium buildings, which are never taller than they are wide.

Large buildings. There are no constraints on their width, depth or height.

building-coverage : The coverage of random buildings in areas marked for random
         objects in m^2. A lower number means a higher density of buildings. A
         value of 0 indicates no buildings. May be masked by the blue channel of an
         object-mask. (default: 0)

building-spacing-m : The minimum spacing between random buildings and other buildings
         or random objects. This helps avoid objects being placed on top of each
         other. (default: 5)

building-small-ratio: Ratio of small buildings. These buildings are 1-3 stories
         in height, and may have a pitched roof. Fraction of small buildings is
         (<building-ratio-small> / (<building-ratio-small> + <building-ratio-medium>
         + <building-ratio-large>). (default: 0.8)

building-medium-ratio : Ratio of medium buildings. These buildings are 3-6 stories
         in height, and have a flat roof. (default: 0.15)

building-large-ratio : Ratio of large buildings. These buildings are 5-10 stories in
         height, and have a flat roof. (default 0.05)

building-small-pitch : Fraction of small buildings with pitched roofs. (default 0.8)
building-medium-pitch : Fraction of small buildings with pitched roofs. (default 0.2)
building-large-pitch : Fraction of small buildings with pitched roofs. (default 0.1)

building-small-min-floors : Min. number of floors for a small building. (default 1)
building-small-max-floors : Max. number of floors for a small building. (default 3)

building-medium-min-floors  : Min. number of floors for a medium building. (default 3)
building-medium-max-floors  : Max. number of floors for a medium building. (default 8)

building-large-min-floors  : Min. number of floors for a medium building. (default 5)
building-large-max-floors  : Max. number of floors for a medium building. (default 20)

building-small-min-width-m : Min. width of small buildings. (default 15)
building-small-max-width-m : Max. width of small buildings. (default 60)
building-small-min-depth-m : Min. depth of small buildings. (default 10)
building-small-max-depth-m : Max. depth of small buildings. (default 20)

building-medium-min-width-m : Min. width of medium buildings. (default 25)
building-medium-max-width-m : Max. width of medium buildings. (default 50)
building-medium-min-depth-m : Min. depth of medium buildings. (default 20)
building-medium-max-depth-m : Max. depth of medium buildings. (default 50)

building-large-min-width-m : Min. width of large buildings. (default 50)
building-large-max-width-m : Max. width of large buildings. (default 75)
building-large-min-depth-m : Min. depth of large buildings. (default 50)
building-large-max-depth-m : Max. depth of large buildings. (default 75)

building-texture : The texture used for all buildings. See Docs/buildings.png for
                   details. (default Texture/buildings.png)

building-lightmap: Emissive texture for all buildings, which is faded in at night to
                   provide illusion of lit windows.  Same texture coordinates and
                   format at building-texture above.

building-range-m: Range at which all buildings are visible.  Beyond this point fewer
                  and fewer buildings are rendered, with no buildings rendered at
                  2*building-range-m (default 10000)

--- End of README.materials ---


--- Start of README.mingw ---

How to compile FlightGear with mingw
====================================


MinGW & MSYS
============

You need to install mingw & msys: 

http://www.mingw.org

You need at least:

MinGW: binutils, gcc-core, gcc-g++, mingw-runtime, mingw-utils, w32api
I would recommed the gcc-3.4.4 versions.
MSYS: msys-1.0.10.exe, msys-autoconf, msys-automake, msys-libtool, msys-DTK.

Please read instructions carefully.

Set the follwing environment variables within msys shell.

export CFLAGS="-I/usr/local/include -O2"
export CXXFLAGS="-I/usr/local/include -O2"
export CPPFLAGS=-I/usr/local/include
export LDFLAGS=-L/usr/local/lib

Pthread-win32
=============

http://sources.redhat.com/pthreads-win32/

compile:
make  GCE-inlined

Install:
cp pthread.h sched.h semaphore.h /usr/local/include
cp linpthreadGCE2.a  /usr/local/lib/libpthread.a
cp pthread-GCE.dll /usr/local/bin

patch header:

--- pthread.h   Sat Oct  1 20:56:43 2005
***************
*** 210,218 ****
   * -----------------
   */
  
! #if HAVE_CONFIG_H
! #include "config.h"
! #endif /* HAVE_CONFIG_H */
  
  #ifndef NEED_FTIME
  #include <time.h>
--- 210,218 ----
   * -----------------
   */
  
! //#if HAVE_CONFIG_H
! //#include "config.h"
! //#endif /* HAVE_CONFIG_H */
  
  #ifndef NEED_FTIME
  #include <time.h>

GLUT
====

use precompiled in order to avoid conflicts with glut32.dll already installed.

http://www.xmission.com/~nate/glut.html
http://www.xmission.com/~nate/glut/glut-3.7.6-bin.zip

The header has to be updated with respect to MINGW.

*** glut.h      Tue Dec 12 22:22:52 2000
--- /local_old/include/GL/glut.h        Thu Aug 18 20:41:15 2005
***************
*** 20,26 ****
     /* XXX This is from Win32's <windef.h> */
  #  ifndef APIENTRY
  #   define GLUT_APIENTRY_DEFINED
! #   if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__) || defined(__LCC__)
  #    define APIENTRY    __stdcall
  #   else
  #    define APIENTRY
--- 20,26 ----
     /* XXX This is from Win32's <windef.h> */
  #  ifndef APIENTRY
  #   define GLUT_APIENTRY_DEFINED
! #   if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__) || defined(__LCC__) || defined(__MINGW32__)
  #    define APIENTRY    __stdcall
  #   else
  #    define APIENTRY


install:
cp glut.h /usr/local/include
cp glut32.dll /usr/local/bin

reimp glut32.lib 
cp libglut32.a /usr/local/lib

OpenAL
======

Get OpenAL for instance from Creative

OpenAL win32 package
install Redist


install:

cd libs
reimp  OpenAL32.lib
cp libopenal32.a  /usr/local/lib
cp alut.lib  /usr/local/lib/libalut.a
cd ..
mkdir /usr/local/include/AL
cp Include/* /usr/local/include/AL


zlib-1.2.3
==========

configure --prefix=/usr/local
make
make install

plib-1.6.8
==========
configure --prefix=/usr/local
make 
make install

simgear
=======
get simgear from CVS
configure --prefix=/usr/local
make
make  install

flightgear
=========
configure --prefix=/usr/local --with-threads
make 
make install


--- End of README.mingw ---


--- Start of README.minipanel ---

Mini Panels for c172

List of files:

./keyboard.xml - same as release key bindings with "s" added to swap panels.
./preferences.xml - same as release preferences.xml with "panel2" added.
./Aircraft/c172/Panels/c172-panel-mini.xml - mini with sacred six, compass, 
	mixture knob, flaps, and control indicators.
./Aircraft/c172/Panels/c172-panel-trans-mini.xml - same mini panel with 
	plexiglass (transparent) background.
./Aircraft/c172/Panels/Textures/panel-mini-bg.rgb - grey background.
./Aircraft/c172/Panels/Textures/panel-trans-mini-bg.rgb - transparent background.


USAGE NOTES:

Hitting "s" will switch between the standard panel and the default.

You may choose other panels for the two that get toggled by changing the
preferences or adding command line parameters.

The property for the panels are:
Normal (Primary) panel: /sim/panel/path=<path to xml file>
Mini (Secondary) panel: /sim/panel2/path=<path to xml file>

The new property is /sim/panel2/path,  it does not need to be a mini panel, you 
can use whatever you want.

For example: to use the grey mini panel change preferences.xml or add this to 
your command line:

runfgfs --prop:/sim/panel2/path=Aircraft/c172/Panels/c172-panel-mini.xml

--- End of README.minipanel ---


--- Start of README.multiplayer ---

The commands are of the form:

--multiplay=in | out,Hz,destination address,destination port
--callsign=a_unique_name


Below are some examples of startup commands that demonstrate the use of the
multiplayer facilities.

For two players on a local network or across the internet:
----------------------------------------------------------
Player1:
--multiplay=out,10,192.168.0.3,5500 --multiplay=in,10,192.168.0.2,5501
--callsign=player1

Player2:
--multiplay=out,10,192.168.0.2,5501 --multiplay=in,10,192.168.0.3,5500
--callsign=player2


For multiple players on a local network:
----------------------------------------
Player1:
--multiplay=out,10,255.255.255.255,5500
--multiplay=in,10,255.255.255.255,5500 --callsign=player1

Playern:
--multiplay=out,10,255.255.255.255,5500
--multiplay=in,10,255.255.255.255,5500 --callsign=playern

Note that the callsign is used to identify each player in a multiplayer game
so the callsigns must be unique. The multiplayer code ignores packets that
are sent back to itself, as would occur with broadcasting when the rx and tx
ports are the same.


Multiple players sending to a single player:
--------------------------------------------
Player1:
--multiplay=out,10,192.168.0.2,5500 --callsign=player1

Player2:
--multiplay=out,10,192.168.0.2,5500 --callsign=player2

Player3:
--multiplay=out,10,192.168.0.2,5500 --callsign=player3

Player4 (rx only):
--multiplay=in,10,192.168.0.2,5500 --callsign=player4

This demonstrates that it is possible to have multiple instances of
Flightgear that send to a single instance that displays all the traffic. This
is the sort of implementation that we are considering for use as a tower
visual simulator.


For use with a server:
----------------------
Oliver Schroeder has created a server for multiplayer flightgear use.
The server acts as a packet forwarding mechanism. When it
receives a packet, it sends it to all other active players
in the vicinity (the server is configured to use 100nm by default).

Check out the server homepage <http://www.o-schroeder.de/fg_server/>
for the current status. You can either download the server for
some local use, or join the developers flying at the existing servers.
As with flightgear, the server is free software, released under GPL.

Pigeon <http://pigeond.net> has created a web page monitoring
two such servers, showing the traffic in a Google map environment.
See <http://pigeond.net/flightgear/fg_server_map.html>.

Options needed to enable multiplayer game with a server:
Player1:
--multiplay=out,10,serveraddress,5000 --multiplay=in,10,myaddress,5000
--callsign=player1

Player2:
--multiplay=out,10,serveraddress,5000 --multiplay=in,10,myaddress,5000
--callsign=player2

...

PlayerN:
--multiplay=out,10,serveraddress,5000 --multiplay=in,10,myaddress,5000
--callsign=playerN

Note that if every player using a particular server, such as one of those
listed on the Pigeon's page, needs to have a unique callsign, not
already in use on that server.

If you are sitting behind a NAT'ting firewall, then you need to forward
the incoming traffic on the firewall outer (visible to the internet)
address arriving at the UDP port you use (5000 in the case above)
over to your private LAN address. In this case, use your PRIVATE LAN address
as <myaddress>. Example (if your private LAN address is 10.0.0.1,
in order to play on pigeond.net):

fgfs --multiplay=in,10,10.0.0.1,5000 --multiplay=out,10,pigeond.net,5000
	--callsign=...UNIQUE callsign here...

If you and the server are in the same address space (i.e., both have a public
IP address or both are on the same private LAN), you hopefully don't need to
mess with any firewalls.

If you don't see other players playing on the same server in your flightgear,
check that you have followed the above router configuration guidelines.  Check
that you don't have any LOCAL firewall running on your computer preventing the
flightgear network traffic flow.

Finally, use ethereal(1) or tethereal(1) to capture the UDP traffic on the port
that you are using, and see if you observe both incoming and outgoing packets.

It's a good idea to talk to the IRC channel #flightgear on irc.flightgear.org
while flying on one of the public servers. Also, it makes sense for every user
on the same server to use the same weather setup, e.g., the real weather
METAR feed, selected by setting to true the real-world-weather-fetch and
control-fdm-atmosphere properties.

Further reading (a must if you have a problem):
-----------------------------------------------
[1] The flightgear server homepage <http://fgms.sourceforge.net/>
[2] The wiki howto <http://wiki.flightgear.org/index.php/Howto:_Multiplayer>
[3] If everything else fails, ask for help on
the IRC channel #flightgear on irc.flightgear.org

--- End of README.multiplayer ---


--- Start of README.multiscreen ---

The Open Scene Graph library, which current FlightGear uses for its 3D
graphics, provides excellent support for multiple views of a
scene. FlightGear uses the osgViewer::Viewer class, which implements a
"master" camera with "slave" cameras that are offset from the master's
position and orientation. FlightGear provides the "camera group"
abstraction which allows the configuration of slave cameras via the
property tree.

Slave cameras can be mapped to windows that are open on different
screens, or all in one window, or a combination of those two schemes,
according to the video hardware capabilities of a machine. It is not
advisable to open more than one window on a single graphics card due
to the added cost of OpenGL context switching between the
windows. Usually, multiple monitors attached to a single graphics card
are mapped to different pieces of the same desktop, so a window can be
opened that spans all the monitors. This is implemented by Nvidia's
TwinView technology and the Matrox TripleHead2Go hardware.

The camera group is configured by the /sim/rendering/camera-group node
in the property tree. It can be set up by, among other things, XML in
preferences.xml or in an XML file specified on the command line with
the --config option.

Here are the XML tags for defining camera groups.

camera-group
For the moment there can be only one camera group. It can contain
window, camera, or gui tags.

 window
 A window defines a graphics window. It can be at the camera-group
 level or defined within a camera. The window contains these tags:

  name - string
  The name of the window which might be displayed in the window's
  title bar. It is also used to refer to a previously defined
  window. A window can contain just a name node, in which case
  the whole window definition refers to a previously defined window.

  host-name - string
  The name of the host on which the window is opened. Usually this is
  empty.

  display - int
  The display number on which the window is opened.

  screen - int
  The screen number on which the window is opened.

  x, y - int
  The location on the screen at which the window is opened. This is in
  the window system coordinates, which usually puts 0,0 at the upper
  left of the screen XXX check this for Windows.

  width, height - int
  The dimensions of the window.

  decoration - bool
  Whether the window manager should decorate the window.

  fullscreen - bool
  Shorthand for a window that occupies the entire screen with no
  decoration.

  overrideRedirect - bool
  Only effective when fullscreen = true.
  Provides an extra hint for Gnome-based linux systems that we insist that
  the full screen window span *all* physical displays, not just the current
  physical display.

 camera
 The camera node contains viewing parameters.

  window
  This specifies the window which displays the camera. Either it
  contains just a name that refers to a previous window definition, or
  it is a full window definition.

  viewport
  The viewport positions a camera within a window. It is most useful
  when several cameras share a window.

   x, y - int
   The position of the lower left corner of the viewport, in y-up
   coordinates.

   width, height - int
   The dimensions of the viewport

  view
  The view node specifies the origin and direction of the camera in
  relation to the whole camera group. The coordinate system is +y up,
  -z forward in the direction of the camera group view. This is the
  same as the OpenGL viewing coordinates.

   x,y,z - double
   Coordinates of the view origin.

   heading-deg, pitch-deg, roll-deg - double
   Orientation of the view in degrees. These are specified using the
   right-hand rule, so a positive heading turns the view to the left,
   a positive roll rolls the view to the left.

  perspective
  This node is one way of specifying the viewing volume camera
  parameters. It corresponds to the OpenGL gluPerspective function. 

   fovy-deg - double
   The vertical field-of-view

   aspect-ratio - double
   Aspect ratio of camera rectangle (not the ratio between the
   vertical and horizontal fields of view).

   near, far - double
   The near and far planes, in meters from the camera eye point. Note
   that FlightGear assumes that the far plane is far away, currently
   120km. The far plane specified here will be respected, but the sky
   and other background elements may not be drawn if the view plane is
   closer than 120km.

   offset-x, offset-y - double
   Offsets of the viewing volume specified by the other parameters in
   the near plane, in meters.

  frustum
  This specifies the perspective viewing volume using values for the near
  and far planes and coordinates of the viewing rectangle in the near
  plane.

   left, bottom - double
   right, top - double
   The coordinates of the viewing rectangle.

   near, far - double
   The near and far planes, in meters from the camera eye point.

  ortho
  This specifies an orthographic view. The parameters are the sames as
  the frustum node's.

 gui
 This is a special camera node that displays the 2D GUI.

  viewport
  This specifies the position and dimensions of the GUI within a
  window, *however* at the moment the origin must be at 0,0.

Here's an example that uses a single window mapped across 3
displays. The displays are in a video wall configuration in a
horizontal row.

<PropertyList>
  <sim>
    <rendering>
      <camera-group>
        <window>
          <name>wide</name>
          <host-name type="string"></host-name>
          <display>0</display>
          <screen>0</screen>
          <width>3840</width>
          <height>1024</height>
          <decoration type = "bool">false</decoration>
        </window>
        <camera>
          <window>
            <name>wide</name>
          </window>
          <viewport>
            <x>0</x>
            <y>0</y>
            <width>1280</width>
            <height>1024</height>
          </viewport>
          <view>
            <heading-deg type = "double">0</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>-.5004</left>
            <right>-.1668</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <camera>
          <window>
            <name type="string">wide</name>
          </window>
          <viewport>
            <x>1280</x>
            <y>0</y>
            <width>1280</width>
            <height>1024</height>
          </viewport>
          <view>
            <heading-deg type = "double">0</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>-.1668</left>
            <right>.1668</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <camera>
          <window>
            <name>wide</name>
          </window>
          <viewport>
            <x>2560</x>
            <y>0</y>
            <width>1280</width>
            <height>1024</height>
          </viewport>
          <view>
            <heading-deg type = "double">0</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>.1668</left>
            <right>.5004</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <gui>
          <window>
            <name type="string">wide</name>
          </window>
        </gui>
      </camera-group>
    </rendering>
  </sim>
</PropertyList>

Here's a complete example that uses a seperate window on each
display. The displays are arranged in a shallow arc with the left and
right displays at a 45.3 degree angle to the center display because,
at the assumed screen dimensions, the horizontal field of view of one
display is 45.3 degrees. Each camera has its own window definition;
the center window is given the name "main" so that the GUI definition
can refer to it.  Note that the borders of the displays are not
accounted for.

<PropertyList>
  <sim>
    <rendering>
      <camera-group>
        <camera>
          <window>
            <host-name type="string"></host-name>
            <display>0</display>
            <screen>0</screen>
            <fullscreen type = "bool">true</fullscreen>
          </window>
          <view>
            <heading-deg type = "double">45.3</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>-.1668</left>
            <right>.1668</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <camera>
          <window>
            <name type="string">main</name>
            <host-name type="string"></host-name>
            <display>0</display>
            <screen>1</screen>
            <fullscreen type = "bool">true</fullscreen>
          </window>
          <view>
            <heading-deg type = "double">0</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>-.1668</left>
            <right>.1668</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <camera>
          <window>
            <host-name type="string"></host-name>
            <display>0</display>
            <screen>2</screen>
            <fullscreen type = "bool">true</fullscreen>
          </window>
          <view>
            <heading-deg type = "double">-45.3</heading-deg>
          </view>
          <frustum>
            <top>0.133</top>
            <bottom>-0.133</bottom>
            <left>-.1668</left>
            <right>.1668</right>
            <near>0.4</near>
            <far>120000.0</far>
          </frustum>
        </camera>
        <gui>
          <window>
            <name type="string">main</name>
          </window>
        </gui>
      </camera-group>
    </rendering>
  </sim>
</PropertyList>

--- End of README.multiscreen ---


--- Start of README.osgtext ---

This document describes the syntax for text objects in the scene graph.
Text nodes are configured using XML and may appear within a model description
file, like other models or the particlesystem.

For the anxious reader, here is a complete example of a text node:

<!-- Must be enclosed by a <text/> node
<text>
  <!-- It should have a name. Can be used for other animations -->
  <name>My first Text</name>
  <!-- Use offsets for the initial placement -->
  <offsets>
    <pitch-deg>0</pitch-deg>
    <heading-deg>0</heading-deg>
    <roll-deg>0</roll-deg>
    <x-m>0</x-m>
    <y-m>0</y-m>
    <z-m>0</z-m>
  </offsets>

  <!-- instead of using pitch/heading/roll offset, one may use
       axis-alignment -->
  <!-- remember: x backwards, y right and z up -->
  <axis-alignment>xy-plane</axis-alignment>
  <!--
  <axis-alignment>reversed-xy-plane</axis-alignment>
  <axis-alignment>xz-plane</axis-alignment>
  <axis-alignment>reversed-xz-plane</axis-alignment>
  <axis-alignment>yz-plane</axis-alignment>
  <axis-alignment>reversed-yz-plane</axis-alignment>
  <axis-alignment>screen</axis-alignment>
  -->

  <!-- what type of text to draw, use on of literal, text-value or number-value -->
  <!-- A simple constant, never changing string -->
  <type type="string">literal</type>
  <text type="string">Hello, world!</text>

  <!-- The string value of a property -->
  <type type="string">text-value</type>
  <property type="string">some/property</property>
  <format type="string">%s</format> <!-- the printf() format to display the value -->

  <!-- A number from a property -->
  <type type="string">number-value</type>
  <property type="string">position/latitude-deg</property>
  <factor type="double">1.0</factor> <!-- optional, scale the propertie's value -->
  <offset type="double">0.0</offset> <!-- optional, shift the propertie's value -->
  <format type="string">%5.2lf</format> <!-- printf() format to display -->
  <truncate type="bool">false</truncate> <!-- truncate to an integer value -->

  <layout>left-to-right</layout> <!-- default -->
  <!--
  <layout>right-to-left</layout>
  <layout>vertical</layout>
  -->

  <draw-text type="bool">true</draw-text> <!-- draw the text itself -->
  <draw-alignment type="bool">false</draw-alignment> <!-- draw crosshair at object center -->
  <draw-boundingbox type="bool">false</draw-boundingbox> <!-- draw a bounding box -->

  <font>led.txf</font> <!-- The font file name, relative to data/Fonts -->
  <character-size type="double">0.01</character-size> <!-- size (height) im meters -->
  <character-aspect-ratio type="double">1.0</character-aspect-ratio>
  <max-height>0.012</max-height> <!-- the maximum height of the text -->
  <max-width>0.040</max-width> <!-- the maximum width of the text -->
  <font-resolution>
    <width type="int">32</width>
    <height type="int">32</height>
  </font-resolution>

  <!-- chose one of the kerning types or omit for default -->
  <kerning>default</kerning>
  <!--
  <kerning>unfitted</kerning>
  <kerning>none</kerning>
  -->

  <alignment>center-center</alignment> <!-- alignment of the text itself -->
  <!-- possible values are
  <alignment>left-top</alignment>
  <alignment>left-center</alignment>
  <alignment>left-bottom</alignment>
  <alignment>center-top</alignment>
  <alignment>center-center</alignment>
  <alignment>center-bottom</alignment>
  <alignment>right-top</alignment>
  <alignment>right-center</alignment>
  <alignment>right-bottom</alignment>
  <alignment>left-baseline</alignment>
  <alignment>center-baseline</alignment>
  <alignment>right-baseline</alignment>
  <alignment>baseline</alignment>
  -->

</text>

The <text/> node may appear within <model/> or <PropertyList/> nodes. If you place
your text directly within your model file, use <text></text> nodes. You can also put
your <text> configuration into a separate file using the well known include directive:

Your model.xml file:
<model>
  <path>may-fancy-model.ac</path>
  <text include="HelloWorld.xml"/>
</model>

Your HelloWorld.xml:
<PropertyList>
  <name>Hello World</name>
  <font>Helvetica.txf</font>
  <type type="string">literal</type>
  <text type="string">Hello, world!</text>
  <!-- etc. - you get the idea -->
</PropertyList>

Animation can be applied to text nodes like any other object. To give your text some
color, use the material animation, or translate, rotate, scale or spin your text as
you like.

--- End of README.osgtext ---


--- Start of README.properties ---

================================================================================
CONTROLS
================================================================================

Flight Controls
---------------
/controls/flight/aileron
/controls/flight/aileron-trim
/controls/flight/elevator
/controls/flight/elevator-trim
/controls/flight/rudder
/controls/flight/rudder-trim
/controls/flight/flaps
/controls/flight/slats
/controls/flight/BLC			// Boundary Layer Control
/controls/flight/spoilers
/controls/flight/speedbrake
/controls/flight/wing-sweep
/controls/flight/wing-fold
/controls/flight/drag-chute

Engines
-------
/controls/engines/throttle_idle
/controls/engines/engine[%d]/throttle
/controls/engines/engine[%d]/starter
/controls/engines/engine[%d]/fuel-pump
/controls/engines/engine[%d]/fire-switch
/controls/engines/engine[%d]/fire-bottle-discharge
/controls/engines/engine[%d]/cutoff
/controls/engines/engine[%d]/mixture
/controls/engines/engine[%d]/propeller-pitch
/controls/engines/engine[%d]/magnetos
/controls/engines/engine[%d]/boost
/controls/engines/engine[%d]/WEP
/controls/engines/engine[%d]/cowl-flaps-norm
/controls/engines/engine[%d]/feather
/controls/engines/engine[%d]/ignition
/controls/engines/engine[%d]/augmentation
/controls/engines/engine[%d]/afterburner
/controls/engines/engine[%d]/reverser
/controls/engines/engine[%d]/water-injection
/controls/engines/engine[%d]/condition

Fuel
----
/controls/fuel/dump-valve
/controls/fuel/tank[%d]/fuel_selector
/controls/fuel/tank[%d]/to_engine
/controls/fuel/tank[%d]/to_tank
/controls/fuel/tank[%d]/boost-pump[%d]

/consumables/fuel/tank[%d]/level-lbs
/consumables/fuel/tank[%d]/level-gal_us
/consumables/fuel/tank[%d]/capacity-gal_us
/consumables/fuel/tank[%d]/density-ppg
/consumables/fuel/total-fuel-lbs
/consumables/fuel/total-gal_us


Gear
----
/controls/gear/brake-left
/controls/gear/brake-right
/controls/gear/brake-parking
/controls/gear/steering
/controls/gear/gear-down
/controls/gear/antiskid
/controls/gear/tailhook
/controls/gear/tailwheel-lock
/controls/gear/wheel[%d]/alternate-extension

Anti-Ice
--------
/controls/anti-ice/wing-heat
/controls/anti-ice/pitot-heat
/controls/anti-ice/wiper
/controls/anti-ice/window-heat
/controls/anti-ice/engine[%d]/carb-heat
/controls/anti-ice/engine[%d]/inlet-heat

Hydraulics
----------
/controls/hydraulic/system[%d]/engine-pump
/controls/hydraulic/system[%d]/electric-pump

Electric
--------
/controls/electric/battery-switch
/controls/electric/external-power
/controls/electric/APU-generator
/controls/electric/engine[%d]/generator
/controls/electric/engine[%d]/bus-tie

Pneumatic
---------
/controls/pneumatic/APU-bleed
/controls/pneumatic/engine[%d]/bleed

Pressurization
--------------
/controls/pressurization/mode
/controls/pressurization/dump
/controls/pressurization/outflow-valve
/controls/pressurization/pack[%d]/pack-on

Lights
------
/controls/lighting/landing-lights
/controls/lighting/turn-off-lights
/controls/lighting/formation-lights
/controls/lighting/taxi-light
/controls/lighting/logo-lights
/controls/lighting/nav-lights
/controls/lighting/beacon
/controls/lighting/strobe
/controls/lighting/panel-norm
/controls/lighting/instruments-norm
/controls/lighting/dome-norm

Armament
--------
/controls/armament/master-arm
/controls/armament/station-select
/controls/armament/release-all
/controls/armament/station[%d]/stick-size
/controls/armament/station[%d]/release-stick
/controls/armament/station[%d]/release-all
/controls/armament/station[%d]/jettison-all

Seat
----
/controls/seat/vertical-adjust
/controls/seat/fore-aft-adjust
/controls/seat/cmd_selector_valve
/controls/seat/eject[%d]/initiate
/controls/seat/eject[%d]/status

APU
---
/controls/APU/off-start-run
/controls/APU/fire-switch

Autoflight
----------
/controls/autoflight/autopilot[%d]/engage
/controls/autoflight/autothrottle-arm
/controls/autoflight/autothrottle-engage
/controls/autoflight/heading-select
/controls/autoflight/altitude-select
/controls/autoflight/bank-angle-select
/controls/autoflight/vertical-speed-select
/controls/autoflight/speed-select
/controls/autoflight/mach-select
/controls/autoflight/vertical-mode
/controls/autoflight/lateral-mode

================================================================================
FDM (Aircraft settings)
================================================================================

Position
---------------
/position/latitude-deg
/position/longitude-deg
/position/altitude-ft

Orientation
-----------
/orientation/roll-deg
/orientation/pitch-deg
/orientation/heading-deg

/orientation/roll-rate-degps
/orientation/pitch-rate-degps
/orientation/yaw-rate-degps

/orientation/side-slip-rad
/orientation/side-slip-deg
/orientation/alpha-deg

Velocities
----------
/velocities/airspeed-kt
/velocities/mach
/velocities/speed-north-fps
/velocities/speed-east-fps
/velocities/speed-down-fps

/velocities/uBody-fps
/velocities/vBody-fps
/velocities/wBody-fps

/velocities/vertical-speed-fps
/velocities/glideslope

Acceleration
------------
/accelerations/nlf

/accelerations/ned/north-accel-fps_sec
/accelerations/ned/east-accel-fps_sec
/accelerations/ned/down-accel-fps_sec

/accelerations/pilot/x-accel-fps_sec
/accelerations/pilot/y-accel-fps_sec
/accelerations/pilot/z-accel-fps_sec

Engines
-------

common:
/engines/engine[%d]/fuel-flow-gph
/engines/engine[%d]/fuel-flow_pph
/engines/engine[%d]/thrust_lb
/engines/engine[%d]/running
/engines/engine[%d]/starter
/engines/engine[%d]/cranking

piston:
/engines/engine[%d]/mp-osi
/engines/engine[%d]/egt-degf
/engines/engine[%d]/oil-temperature-degf
/engines/engine[%d]/oil-pressure-psi
/engines/engine[%d]/cht-degf
/engines/engine[%d]/rpm

turbine:
/engines/engine[%d]/n1
/engines/engine[%d]/n2
/engines/engine[%d]/epr
/engines/engine[%d]/augmentation
/engines/engine[%d]/water-injection
/engines/engine[%d]/ignition
/engines/engine[%d]/nozzle-pos-norm
/engines/engine[%d]/inlet-pos-norm
/engines/engine[%d]/reversed
/engines/engine[%d]/cutoff

propeller:
/engines/engine[%d]/rpm
/engines/engine[%d]/pitch
/engines/engine[%d]/torque


================================================================================
LIGHT
================================================================================
/sim/time/sun-angle-rad
/rendering/scene/ambient/red
/rendering/scene/ambient/ggreen
/rendering/scene/ambient/blue
/rendering/scene/diffuse/red
/rendering/scene/diffuse/green
/rendering/scene/diffuse/blue
/rendering/scene/specular/red
/rendering/scene/specular/green
/rendering/scene/specular/blue

--- End of README.properties ---


--- Start of README.protocol ---

The generic communication protocol for FlightGear provides a powerful way
of adding a simple ASCII based or binary input/output protocol, just by
defining an XML encoded configuration file and placing it in the
$FG_ROOT/Protocol/ directory.




== file layout ================================================================

A protocol file can contain either or both of <input> and <output>
definition blocks. Which one is used depends on how the protocol
is called  (e.g. --generic=file,out,1,/tmp/data.xml,myproto would
only use the <output> definitions block).

  <?xml version="1.0"?>
  <PropertyList>
      <generic>

          <output>
              <binary_mode>false</binary_mode>
              <line_separator></line_separator>
              <var_separator></var_separator>
              <preamble></preamble>
              <postamble></postamble>

              <chunk>
                      ... first chunk spec ...
              </chunk>

              <chunk>
                      ... another chunk etc. ...
              </chunk>
          </output>

          <input>
              <line_separator></line_separator>
              <var_separator></var_separator>

              <chunk>
                      ... chunk spec ...
              </chunk>
          </input>

      </generic>
  </PropertyList>




== input/output parameters ====================================================

Both <output> and <input> blocks can contain information about
the data mode (ascii/binary) and about separators between fields
and data sets, as well as a list of <chunk>s. Each <chunk> defines
a property that should be written (and how), or a variable and which
property it should be written to.

--- ASCII protocol parameters ---

output only:
  <preamble>        STRING  default: ""    file header put on top of the file
  <postamble>       STRING  default: ""    file footer put at the end of the file

input & output:
  <binary_mode>	    BOOL    default: false (= ASCII mode)
  <var_separator>   STRING  default: ""    field separator
  <line_separator>  STRING  default: ""    separator between data sets


<var_separator> are put between every two output properties, while
<line_separator> is put at the end of each data set. Both can contain
arbitrary strings or one of the following keywords:

  Name             Character

  newline          '\n'
  tab              '\t'
  formfeed         '\f'
  carriagereturn   '\r'
  verticaltab      '\v'


Typical use could be:

  <var_separator>tab</var_separator>
  <line_separator>newline</var_separator>

or

  <var_separator>\t</var_separator>
  <line_separator>\r\n</line_separator>


--- Binary protocol parameters ---

To enable binary mode, simply include a <binary_mode>true</binary_mode> tag in
your XML file. The format of the binary output is tightly packed, with 1 byte
for bool, 4 bytes for int, and 8 bytes for double. At this time, strings are not
supported. A configurable footer at the end of each "line" or packet of binary
output can be added using the <binary_footer> tag. Options include the length
of the packet, a magic number to simplify decoding. Examples:

  <binary_footer>magic,0x12345678</binary_footer>
  <binary_footer>length</binary_footer>
  <binary_footer>none</binary_footer>                 <!-- default -->




== variable parameters (chunk spec) ===========================================

Both <input> and <output> block can contain a list of <chunk> specs,
each of which describes the properties of on variable to write/read.


  <name>        for ease of use (not tranferred)
  <node>        the property tree node which provides the data
  <type>        the value type (needed for formatting)
                one of string, float, bool, int (default: int)
  <format>      (ASCII protocol only, not used or needed in binary mode)
                defines the actual piece of text which should be sent.
                it can include "printf" style formatting options like:
                                <type>
                        %s      string
                        %d      integer (default)
                        %f      float

  <factor>      an optional multiplication factor which can be used for
                unit conversion. (for example, radians to degrees).
  <offset>      an optional offset which can be used for unit conversion.
                (for example, degrees Celcius to degrees Fahrenheit).


Chunks can also consist of a single constant <format>, like in:
  <format>Data Section</format>


== examples ===================================================================

Writes log of this form:

V=16
H=3.590505
P=3.59
V=12
H=3.589020
P=3.59



<?xml version="1.0"?>

<PropertyList>
  <generic>

    <output>
      <line_separator>newline</line_separator>
      <var_separator>newline</var_separator>
      <binary_mode>false</binary_mode>

      <chunk>
        <name>speed</name>
        <format>V=%d</format>
        <node>/velocities/airspeed-kt</node>
      </chunk>

      <chunk>
        <name>heading (rad)</name>
        <format>H=%.6f</format>
        <type>float</type>
        <node>/orientation/heading-deg</node>
        <factor>0.0174532925199433</factor>  <!-- degrees to radians -->
      </chunk>

      <chunk>
        <name>pitch angle (deg)</name>
        <format>P=%03.2f</format>
        <node>/orientation/pitch-deg</node>
      </chunk>
   </output>

 </generic>
</PropertyList>




-- writing data in XML syntax -------------------------------------------------

Assuming the file is called $FG_ROOT/Protocol/xmltest.xml, then it could be
used as   $ fgfs --generic=file,out,1,/tmp/data.xml,xmltest


<?xml version="1.0"?>

<PropertyList>
  <generic>
    <output>
      <binary_mode>false</binary_mode>
      <var_separator>\n</var_separator>
      <line_separator>\n</line_separator>
      <preamble>&lt;?xml version="1.0"?&gt;\n\n&lt;data&gt;\n</preamble>
      <postamble>&lt;/data&gt;\n</postamble>

      <chunk>
        <format>\t&lt;set&gt;</format>
      </chunk>

      <chunk>
        <node>/position/altitude-ft</node>
        <type>float</type>
        <format>\t\t&lt;altitude-ft&gt;%.8f&lt;/altitude-ft&gt;</format>
      </chunk>

      <chunk>
        <node>/velocities/airspeed-kt</node>
        <type>float</type>
        <format>\t\t&lt;airspeed-kt&gt;%.8f&lt;/airspeed-kt&gt;</format>
      </chunk>

      <chunk>
        <format>\t&lt;/set&gt;</format>
      </chunk>
    </output>
  </generic>
</PropertyList>


-- Analyzing the resulting binary packet format -------------------------------

A utility called generic-protocol-analyse can be found under
FlightGear/utils/xmlgrep which can be used to analyze the resulting
data packet for the binary protocol.

The output would be something like:

bintest.xml
Generic binary output protocol packet description:

 pos | size |  type  | factor     | description
-----|------|--------|------------|------------------------
   0 |    4 |    int |            | indicated speed (kt)
   4 |    4 |  float |            | pitch att (deg)
   8 |    4 |  float |            | magnetic heading (deg)
  12 |    4 |    int |            | outside air temperarure (degF)
  16 |    1 |   bool |            | autocoord

total package size: 17 bytes


--- End of README.protocol ---


--- Start of README.scenery ---

This document describes how FlightGear searches and loads scenery, how to
add static objects to the scenery as well as the syntax of *.stg files.




Contents ----------------------------------------------------------------------

1  scenery path
2  terrasync

3  stg files
   3.1  OBJECT_BASE
   3.2  OBJECT
   3.4  OBJECT_SHARED / OBJECT_SHARED_AGL
   3.3  OBJECT_STATIC / OBJECT_STATIC_AGL
   3.5  OBJECT_SIGN /OBJECT_SIGN_AGL
   3.6  BUILDING_ROUGH / BUILDING_DETAILED
   3.7  ROAD_ROUGH / ROAD_DETAILED
   3.8  RAILWAY_ROUGH / RAILWAY_DETAILED
   3.9  BUILDING_LIST

4  model manager ("/models/model")
   4.1  static objects
   4.2  dynamic objects
   4.3  loading/unloading at runtime

5  tools for object placing
   5.1  calc-tile.pl
   5.2  ufo scenery object editor

6  embedded Nasal
   6.1  static models
   6.2  AI models




1 scenery path ----------------------------------------------------------------

FlightGear loads scenery by default from the Scenery/ subdirectory of its
data directory. The path to this data directory can be set via environment
variable FG_ROOT or the --fg-root option. The scenery path can be set
independently via environment variable FG_SCENERY or option --fg-scenery.
The order of precedence is as follows:

  --fg-scenery=/some/dir         ... highest priority
  $FG_SCENERY
  $FG_ROOT/Scenery/              ... lowest priority


A scenery specification may be a list of paths, separated by the OS-specific
path separator (colon on Unix/OSX, semicolon on MS Windows). The paths are
searched in the order from left to right:

  FG_SCENERY=/first/dir:/second/dir:/third/dir
                                     (likewise with --fg-scenery option)

Each of the scenery paths normally contains a set of directories, each containing
a particular scenery type :

 Terrain/ containing the terrain mesh and airport data
 Objects/ containing placed scenery objects such as large landmarks, bridges
 Pylons/  containing electricity pylon Models
 Roads/   containing detailed road and railways
 Buildings/ containing osm2city-generated buildings

The user can control at runtime which of these directories is actually loaded
via the property tree:
/sim/rendering/scenery-path-suffix[n]/name      defines the name of the sub-directory
/sim/rendering/scenery-path-suffix[n]/enabled   indicates whether it is loaded.

hese properties are typically set in the Rendering Options menu.

In turn each of these contains a tree of directories breaking down the world into
10x10 degree and then 1x1 degree chunks.  E.g. Terrain/w130n30/w123n37/

For backwards compatibility reasons, the top level can alternatively just
contain 10x10 degree directories.  E.g. w130n30/w123n37/

Note that as soon as any of the scenery-path-suffix directories is found, any
10x10 directory on the same hierarchy level will be ignored!

This example shows which directories are used to search for scenery:

  $ ls /first/dir
  w130n30/                   searched

  $ ls /second/dir
  Objects/                   searched
  Terrain/                   searched
  w130n30/                   *not* searched

  $ ls /third/dir
  Terrain/                   searched
  w130n30/                   *not* searched


Within the 1x1 degree chunks, the ground is further broken up into "tiles" of
approx 20x20km. If FlightGear searches for a particular "tile" file, let's say for
"w130n30/w123n37/942050.stg", then (using the above examples) it looks
into

  /first/dir/w130n30/w123n37/942050.stg             (A)

  /second/dir/Terrain/w130n30/w123n37/942050.stg      (B)\__ same path element
  /second/dir/Objects/w130n30/w123n37/942050.stg      (C)/      /second/dir
  /second/dir/Pylons/w130n30/w123n37/942050.stg       (D)/
  /second/dir/Roads/w130n30/w123n37/942050.stg        (E)/
  /second/dir/Buildings/w130n30/w123n37/942050.stg    (F)/

  /third/dir/Terrain/w130n30/w123n37/942050.stg       (G)

As soon as it finds an OBJECT_BASE entry it only finishes this
path element and then stops scanning. So, if (B) contains an entry
"OBJECT_BASE 942050.btg, then the other directories in /second/dir (C, D, E, F)
will be read.  But (G) will *not*!

This searching behavior is usually used to collect user-downloaded scenery first,
then to read automatically downloaded scenery (see terrasync
below), then standard scenery and objects that came with the distribution.
So a typical scenery path specification could look like this:

  FG_SCENERY=$HOME/.fgfs/Scenery:$HOME/.fgfs/TerraSync:$FG_ROOT/Scenery

The first path would then be populated by the user with unpacked scenery
archives downloaded various sources.

Using a private directory for downloaded add-on scenery and adding
that path to FG_SCENERY is the preferred way. This separates default
data from locally added data, and makes administration and later updates
easier.

HINT: if you want to see where FlightGear is searching and finding
terrain/objects, start it with the --log-level=info option.

2 terrasync -------------------------------------------------------------------

FlightGear can download scenery on-the-fly.  Simply select "Download scenery
automatically" from the launcher, or use --enable-terrasync from the commandline.
By default this will add $HOME/.fgfs/TerraSync to the scenery path.

Note, however, that if it downloads scenery for the area around your
starting location, then you'll only see that after the next start, or
after you flew or teleported to a distant location and then back.

2.1 .dirindex -----------------------------------------------------------------

To save having to download scenery every time, while allowing updates to
propagate, terrasync checks for a .dirindex file each time it downloads a
directory from the server.  This lists files, directories and tarballs that
should be present in the local directory, along with their size and a sha1sum
of their contents.  This sha1sum is checked against the local files to
determine which files are to be downloaded.

The format of the .dirindex is as follows:

version:<version>
path:<scenery_path>
<type>:<filename>:<sha1sum>:<size>
<type>:<filename>:<sha1sum>:<size>
<type>:<filename>:<sha1sum>:<size>
.
.
.

Where:

<version> is the .dirindex version number
<scenery_path>  is the path of the current file, e.g. Objects/w010n50/w009n57
<type>  is the file type - "f" for file, "d" for directory, "t" for tarball
<filename> is the file name  (e.g. 2811121.stg)
<sha1sum>  is the sha1sum of the file named (e.g. 9da6ebc1695ed1c3b151cd34263e9c931ee309ea)
<size>     is the size of the file

Tarballs (labelled with a "t" in the .dirindex) must be <name>.tgz files which
unpack into a <name>/ sub-directory.  This enables terrasync to clean up
out of date files by simply deleting the <name>/ subdirectory before unpacking
the updated file.

3 stg files -------------------------------------------------------------------

stg files ("static terragear") define the static elements of a scenery
"tile", including the terrain elevation data, airport geometry, and all
static objects placed on this tile. (See section 5 for how to find out which
geo coordinates belong to which tile.) Four of the available key words
are followed by a string and four numbers. The meaning of these numbers
is always the same and described in section 3.3.

3.1  OBJECT_BASE
----------------

specifies the terrain elevation data file. These files are generated with
the TerraGear tools (http://www.terragear.org/) and have file extension
".btg" ("binary terragear"; there used to be an "*.atg" file, too, where
the 'a' stood for ASCII).

Example:

  OBJECT_BASE 942050.btg

The entry may be anywhere in the 942050.stg file, on a separate line.

3.2  OBJECT
-----------

specifies an airport geometry 'drop-in' file. The scenery elevation file
has cut out holes for airports, that are filled with such objects. They
are usually called after the airport ICAO id:

Example:

  OBJECT KSFO.btg

These files are, again, created by TerraGear tools and are usually gzipped,
so you'll find that file stored as KSFO.btg.gz.




3.3  OBJECT_SHARED / OBJECT_SHARED_AGL
--------------------------------------

add static object to the tile.

Example:

  OBJECT_SHARED Models/Airport/tower.xml -122.501090 37.514830 15.5 0.00 0.00 0.00

Syntax:

  OBJECT_SHARED <object-path> <lon> <lat> <elev-m> <hdg-deg> <pitch-deg> <roll-deg>

The <object-path> is relative to the data directory (FG_ROOT).
<elev-m> is in meter and relative to mean sea-level (in the fgfs world).
<hdg-deg> is in degree, counter-clockwise with North being 0.0. Note
that this differs from about every other place in FlightGear, most notably
the /orientation/heading-deg entry in the property system, which is clockwise.
<pitch-deg> and <roll-deg> are in degree and optional.
OBJECT_SHARED models are cached and reused. They are only once in memory
and never freed. (See also the next section.)

OBJECT_SHARED_AGL places the object relative to the ground elevation.  Note that
this is an expensive operation and is strongly discouraged.

3.4  OBJECT_STATIC / OBJECT_STATIC_AGL
--------------------------------------

add static objects to the tile, just like OBJECT_SHARED. There are three
differences to OBJECT_SHARED (apart from the name):

(A) the path is relative to the tile directory where the *.stg file with
    this entry is located. For example, relative to 130n30/w123n37/. This
    usually means that all 3D object files, textures, and XML animation
    files are in this tile directory, too.

(B) these objects are *not* cached and kept loaded, but rather freed with
    the tile (that is, when you leave that area).

(C) the animation XML files may contain Nasal blocks <nasal><load> and
    <nasal><unload> which are executed on loading/unloading.

Example:

  OBJECT_STATIC ggb-fb.xml -122.4760494 37.81876042 0 105 0.00 0.00


OBJECT_STATIC_AGL places the object relative to the ground elevation.  Note that
this is an expensive operation and is strongly discouraged.


3.5 OBJECT_SIGN / OBJECT_SIGN_AGL
---------------------------------

defines taxiway or runway sign. The syntax is much like that of OBJECT_SHARED
entries, except that the path is replaced with a sign contents specification
and that there is an additional size value at the end of the line.

Example:

  OBJECT_SIGN {@R}10L-28R{@L}C -122.35797457 37.61276290 -0.5398 74.0 2

The sign specification defines the sign contents. We try to resemble the
apt.dat 850 specifications in our implementation.
In the simplest form it contains just 'normal' text, for example:

  EXIT

This will create a black panel of 1m height with "EXIT" written on it
in white versal letters. Actually, each of those characters are
single-letter glyph names that are looked up in the <glyph> map of a
texture font <material> entry in $FG_ROOT/materials.xml. It just
happens that the <glyph> entry for <name> 'E' maps to a drawn 'E' in
the font texture. This isn't true for all ASCII characters. Many aren't
mapped at all (and thus not available), others are mapped to non-standard
drawings. The '_', for example, is mapped to an empty black area and can
therefore be used as a space. (The sign specification must not contain
real spaces.) The '*' is mapped to a raised period.

Some glyph names consist of more than one character, and can't, thus, be
used directly. They have to be put in a pair of curly braces:

  {^rd}

This creates an arrow that points to the right and down. Braces can really
contain a list of glyph names, separated by commas (no space!).
Single-letter glyph names can be used that way, too, or in any mixture
of both methods:

  EXIT
  {E,X,I,T}
  {E}{X}{I}{T}
  EX{I,T}
  E{X,I}T{^lu,^rd}
  {^u}EXIT{^u}


Multi-letter glyph names are usually used for symbols. Arrow symbol names
always start with a caret ("arrow head") and the left or right direction
always comes first (like the x in a Cartesian coordinate system). Here's
a list of some of the available names (see $FG_ROOT/materials.xml for
more):


  ^l       left arrow
  ^r       right arrow
  ^u       up arrow
  ^d       down arrow
  ^lu      left-up arrow
  ^ld      left-down arrow
  ^ru      right-up arrow
  ^rd      right-down arrow
  no-entry "no entry" symbol
  critical runway critical area
  safety   ils safety area
  hazard   end of taxiway



There are commands for pre-defined sign types according to the FAA
specification (5345-44; see http://www.google.com/search?q=5345-44g).

  @Y   "Direction, Destination, Boundary" sign (black on yellow)
  @R   "Mandatory Instruction" sign (white on red with black outline)
  @L   "Location" sign  (yellow text and frame on black)
  @B   "Runway Distance Remaining" sign  (white on black)


Examples:

  {@R}10L-28R{@L}C
  {@Y,^l}P|{^lu}N{@L}F{@Y}F{^ru}
  {@Y,^ld}C   ...  same as any of {@Y}{@ld}C  {@Y,@ld,C}
  {@B}17


Syntax errors are reported in --log-level=debug, in the SG_TERRAIN
group. You can use this command line to filter out such messages:

  $ fgfs --log-level=debug 2>&1|grep OBJECT_SIGN

OBJECT_SIGN_AGL places the sign relative to the ground elevation.  Note that
this is an expensive operation and is strongly discouraged.

3.6  BUILDING_ROUGH / BUILDING_DETAILED
---------------------------------------

defines building meshes, typically based on OSM data.

Example:

  BUILDING_ROUGH buildings.ac -122.501090 37.514830 15.5 0.00 0.00 0.00

Syntax:

  BUILDING_ROUGH <object-path> <lon> <lat> <elev-m> <hdg-deg> <pitch-deg> <roll-deg>

Note that only bare .ac files should be referenced. The material definition for
"OSM_Building" will be used to determine the texture and Effects.

BUILDING_ROUGH uses the "rough" LOD range, while BUILDING_DETAILED uses the
"detailed" LOD range. Some randomness is applied so that building meshes
gradually fade in

3.7  ROAD_ROUGH / ROAD_DETAILED
-------------------------------

Identical to BUILDING_ROUGH / BIULDING_DETAILED above, except used for roads.
the material definition "OSM_Road" is applied.

3.8  RAILWAY_ROUGH / RAILWAY_DETAILED
-------------------------------

Identical to BUILDING_ROUGH / BIULDING_DETAILED above, except used for roads.
the material definition "OSM_Railway" is applied.

3.9  BUILDING_LIST
------------------

Defines a file containing building coordinates that should be rendered using
the building shader (aka Random Buildings).

Example:

  BUILDING_LIST buildings.txt OSM_Building -2.72943543 56.00080606 36.1

Syntax

  BUILDING_LIST <filename> <material name> <lon> <lat> <elev>

Where:
- <filename> is the name of a file containing building positions
- <material name> is the name of the material that will be referenced to find
  random building parameters.
- <lat>, <lon>, <elev> defines the center of the set of buildings, and also
  the point at which the material definition will be evaluated (for regional
  materials).

See README.materials for details on configuring the random building parameters.

The referenced <filename> (in the example buildings.txt) contains lines of the form

X Y Z R B W D H P S O F WT RT

Where:
- X,Y,Z are the cartesian coordinates of the center of the front face. +X is East, +Y is North
- R is the building rotation in degrees centered on the middle of the front face.
- B is the building type [0, 1, 2] for SMALL, MEDIUM, LARGE
- W is the building width in meters
- D is the building depth in meters
- H is the building height in meters, excluding any pitched roof
- P is the pitch height in meters. 0 for a flat roof
- S is the roof shape (only 0, 2, 4, 6 are implemented, others are approximated to those) :
    0=flat 1=skillion 2=gabled 3=half-hipped 4=hipped 5=pyramidal 6=gambrel
    7=mansard 8=dome 9=onion 10=round 11=saltbox
- O is the roof ridge orientation :
    0 = parallel to the front face of the building
    1 = orthogonal to the front face of the building
- F is the number of floors (integer)
- WT is the texture index to use for walls (integer). Buildings with the same WT value will have the same wall texture assigned.  There are 6 small, 6 medium and 4 large textures.
- RT is the texture index to use for roofs (integer). Buildings with the same RT value will have the same roof texture assigned.  There are 6 small, 6 medium and 4 large textures.

<x> <y> <z> <rot> <type>

where :
- (<x>,<y>,<z>) define the bottom left corner of the building in cartesian space (+X is North, +Y is East, +Z is up), with (0,0,0) being the position referenced above
- <rot> is the clockwise rotation around the Z-axis in degrees, rotating around the bottom left (SW) corner of the building
- <type> is {0,1,2} which map to small, medium and large buildings respectively, as per random buildings.

For example, the following entries generates 3 small, 2 medium and 2 large buildings in an easterly line:

0 0 0 0 0
0 100 0 0 0
0 200 0 0 0
0 300 0 0 1
0 400 0 0 1
0 500 0 0 2

4 model manager ("/models/model") --------------------------------------------


4.1  static objects
-------------------

Another way to add objects to the scenery is via the "model manager".
It reads all /models/model entries at startup and places these objects
in the scenery. Just load a definition like the following into the
property tree, for example by putting it into $FG_ROOT/preferences.xml, or
better: an XML file that you load with e.g. --config=$HOME/.fgfs/stuff.xml:

  <models>
      <model n="0">
          <name>pony</name>
          <path>Local/pony.ac</path>
          <longitude-deg>-115.8352869</longitude-deg>
          <latitude-deg>37.24302849</latitude-deg>
          <elevation-ft>4534.691321</elevation-ft>
          <heading-deg>0</heading-deg>
          <pitch-deg>0</pitch-deg>
          <roll-deg>0</roll-deg>
      </model>
  </models>

The <path> is relative to $FG_ROOT, the <name> is optional. One can leave the
heading/pitch/roll entries away, in which case they are set to zero. The values
are fixed and unchangeable at runtime.




4.2  dynamic objects
--------------------

Any of the model properties can be made changeable at runtime by appending
"-prop" and using a property path name instead of the fixed value:

  <local>
      <pony>
          <longitude-deg>-115.8352869/<longitude-deg>
          <latitude-deg>37.24302849</latitude-deg>
          <elevation-ft>4534.691321</elevation-ft>
          <heading-deg>0</heading-deg>
      </pony>
  </local>

  <models>
      <model n="1">
          <name>pony</name>
          <path>Local/pony.ac</path>
          <longitude-deg-prop>/local/pony/longitude-deg</longitude-deg-prop>
          <latitude-deg-prop>/local/pony/latitude-deg</latitude-deg-prop>
          <elevation-ft-prop>/local/pony/elevation-ft</elevation-ft-prop>
          <heading-deg-prop>/local/pony/heading-deg</heading-deg-prop>
          <pitch-deg>1.234</pitch-deg>  <!-- static, just for fun -->
      </model>
  </models>

Then one can move the pony around by changing the values in /local/pony/ in
the property system. One can, of course, use other animals, too.




4.3 loading/unloading at runtime
--------------------------------

Both dynamic and static model-manager-models can be loaded and unloaded
at runtime. For loading you first create a new <model> entry under <models>,
initialize all properties there (<longitude-deg> or <longitude-deg-prop>,
etc.), and finally you create a child <load> of any type in this group.
This is the signal for the model manager to load the object. You can
remove the <load> property after that. It has no further meaning.

To remove a model-manager model at runtime, you simply delete the whole
<model> group.





5 tools for object placing ----------------------------------------------------


5.1 calc-tile.pl
----------------

For finding out the tile number for a given geo coordinate pair there's
a script "scripts/perl/scenery/calc-tile.pl" in the FlightGear sources.
You feed longitude and latitude to it and it returns the path to the
*.stg file where you have to add the object entry.

  $ perl calc-tile.pl 16.1234 48.5678
  Longitude: 16.1234
  Latitude:  48.5678
  Tile:      3220128
  Path:      "e010n40/e016n48/3220128.stg"




5.2 ufo scenery object editor
-----------------------------

The ufo has a scenery object editor built-in. It uses the model manager
described in section 4. To place objects with it, start fgfs, optionally
with specifying an initial model type ("cursor") and a list of subdirectories
of $FG_ROOT where the ufo should search for available 3D models ("source"):

  $ fgfs --aircraft=ufo --prop:cursor=Models/Airport/radar.xml  \
                        --prop:source=Models,Scenery/Objects

Then click anywhere on the terrain to add a model (left mouse button).
You can open the adjustment dialog (Tab-key) to make adjustments to
position and orientation. Click as often as you like, choose further
models from the space-key dialog. You can select an already placed object
by Ctrl-clicking at its base (not at the object itself, but the surface
point where it's located!). By also holding the Shift key down, you
can select several objects or add them to a selection. You can remove
the selected object(s) with the Backspace-key. (See the ?-key dialog
for futher available keys.) After clicking on the input field right
over the status line (invisible if there's no text in it) you can enter
a comment/legend for the selected object.

And finally, you dump the object data to the terminal (d-key) or export
them to a file $HOME/.fgfs/ufo-model-export.xml (Unix) or
%APPDATA%\flightgear.org\ufo-model-export.xml (MS Windows).

You can now put the generated object entries into the specified *.stg
file to make them permanent. Or load the whole exported *.xml file
via --config option:

  $ fgfs --config=$HOME/.fgfs/ufo-model-export.xml

If you choose the sign placeholder object from the m-key dialog (first
entry; "Aircraft/ufo/Models/sign.ac"), then an OBJEC_SIGN *.stg line
will be generated with the legend used as sign contents. If you didn't
insert any legend, then the sign text will be: NO CONTENTS and a 4 digits
random number for later identification in the *.stg file.

Unfortunately, objects added with this method are kept in memory, no
matter where you are actually flying, so the *.stg method is preferable.





6 embedded Nasal in XML files (static objects and AI) -------------------------


6.1 static models
-----------------

Objects loaded via OBJECT_STATIC in *.stg files as well as AI models loaded
via scenarios may contain embedded Nasal code. This can be used to drive
more advanced animations. An example is a lighthouse with specific light
signals, or hangar doors that open when the "player"'s aircraft is nearby.
The Nasal code is added to the object's XML wrapper/animation file, anywhere
on the top level, for example:


   <PropertyList>
       <path>lighthouse.ac</path>

       <nasal>
           <load>
               var loop_id = 0;
               var light = aircraft.light.new("
                       "/models/static/w120n30/w118n35/lighthouse/light",
                       [2, 1, 2, 1, 2, 1, 2, 5]);

               var loop = func(id) {
                   id == loop_id or return;
                   light.switch(getprop("/sim/time/sun-angle-rad") > 1.37);
                   settimer(func { loop(id) }, 30);
               }
               loop(loop_id += 1);
           </load>

           <unload>loop_id += 1</unload>
       </nasal>

       <animation>
           <type>select</type>
           <object-name>light-halo</object-name>
           <property>/models/static/w120n30/w118n35/lighthouse/light/state</property>
       </animation>

       ...
   </PropertyList>


The <load> part is executed when the scenery tile on which the model is placed
is loaded into memory. It can start timers or listeners that modify properties,
which are then queried by the <animation>. As a convention developers are requested
to use "/models/static/" + <tile-path> + <file-basename>. So, in the above example
file "$FG_ROOT/Scenery/Objects/w120n30/w118n35/lighthouse.xml" all properties
are stored under "/models/static/w120n30/w118n35/lighthouse/". That way collisions
with other models are quite unlikely.

An optional <unload> part is executed when the tile and model is removed from
memory. Note that this is only when the "player" is already far away! To
cause minimal impact on the framerate it is recommended to do as few
calculations as possible, to use as large timer intervals as possible, and to
stop all timers and listeners in the <unload> part, as shown in the example.

All Nasal variables/functions are in a separate namespace, which is named
after the file name. It's recommended not to access this namespace from
outside for other than development purposes.

What the above code does: as soon as the model is loaded, an aircraft.light
is created with a specific light sequence. Then, in half-minute intervals,
the light is turned on or off depending on the sun angle. On <unload> the
loop identifier is increased, which makes the loop terminate itself. For
more info about this technique, see the Nasal wiki.




6.2 AI models
-------------

Here the syntax is the same like for static models. The only two differences
are:

- these models are currently only removed at program end, so it's more
  important to consider effects on performance.

- AI models don't need to store their properties in /models/static/...,
  but get a separate node under /ai/models/, for example /ai/models/carrier[1].
  The embedded Nasal code can access this dynamically assigned property
  via cmdarg() function, which returns a props.Node hash. Example:

     <nasal>
         <load>print("my data are under ", cmdarg().getPath())</load>
         <unload>print("Currently I'm only called at fgfs exit!")</unload>
     </nasal>

--- End of README.scenery ---


--- Start of README.sound ---


OpenAL setup for general use (Linux)
-------------------------------------
As of the July 2004 release of OpenAL it is best to add at least the
following line to your ~/.openalrc file on Linux because it wil find out
what audio backend to use, starting with the most appropriate:

(define devices '(native alsa sdl esd arts null))



ALSA surround sound (5.1) setup
-------------------------------------
(taken from http://floam.ascorbic.com/how-to/alsa5.1)

Make a ~/.openalrc, we are telling OpenAL that we want surround sound and
we want to use ALSA instead of OSS.

(define speaker-num 4)
(define devices '(alsa))
(define alsa-out-device "surround40:0,0")



IRIX surround sound (5.1) setup
-------------------------------------
To add 4 channel surround sound on IRIX hardware that supports in
directly you can just add the following line to your ~/.openalrc file:

(define speaker-num 4)

To add 4 channel surround sound to IRIX systems that have more than one
stereo output you can add the following section to your ~/.openalrc file
(for a typical O2 configuration):

(define speaker-num 4)
(define native-out-device "Analog Out")
(define native-rear-out-device "Analog Out 2")

or alternatively:

(define speaker-num 4)
(define native-out-device "A3.Speaker")
(define native-rear-out-device "A3.LineOut2")



(Note the following section is obsolete as of the July 2004 release of
OpenAL, since your could command OpenAL to use ALSA or Arts directly)

ALSA and Arts
-------------------------------------

I'm using kernel 2.6.5 with alsa, my sound module is snd-intel8x0. When I ran
fgfs, I'd get quite 'choppy' sound (wasn't smooth, there'd be a couple of
breaks in the sound every second or so). Running arts, and starting fgfs with
"artsdsp fgfs" (from the artsdsp website: "When an application is run under
artsdsp all accesses to the /dev/dsp audio device are intercepted and mapped
into aRts API calls. While the device emulation is not perfect, most
applications work this way, albeit with some degradation in performance and
latency.") would improve the situation, but it seemed to still be choppy.

This command:
echo "fgfs 0 0 direct" >/proc/asound/card0/pcm0p/oss

(from the alsa kernel OSS emulation website:
  "The direct option is used, as mentioned above, to bypass the automatic
   conversion and useful for MMAP-applications")

made my sound work beautifully when fgfs was run with artsdsp. Running without
artsdsp however (with artsd suspended or killed), would give me no sound at all
(which I find a bit strange)

The following websites might help people with similar troubles:
http://www.alsa-project.org/~iwai/OSS-Emulation.html
http://www.arts-project.org/doc/handbook/artsdsp.html

Computer info:

kernel 2.6.5

flightgear 0.9.4
simgear 0.3.5
plib 1.8.3

soundcard is onboard an asus p4p800-e deluxe mobo (using snd-intel8x0), alsa,
related modules from lsmod:
Module                  Size  Used by
snd_pcm_oss            53252  1
snd_mixer_oss          19968  1 snd_pcm_oss
snd_intel8x0           33476  1
snd_ac97_codec         63492  1 snd_intel8x0
snd_pcm                97408  2 snd_pcm_oss,snd_intel8x0
snd_timer              26112  1 snd_pcm
snd_page_alloc         11396  2 snd_intel8x0,snd_pcm
snd_mpu401_uart         7936  1 snd_intel8x0
snd_rawmidi            24832  1 snd_mpu401_uart
snd_seq_device          8324  1 snd_rawmidi
snd                    53892  9 snd_pcm_oss,snd_mixer_oss,snd_intel8x0,
                                snd_ac97_codec,snd_pcm,snd_timer,snd_mpu401_uart,
                                snd_rawmidi,snd_seq_device
soundcore              10208  2 snd

--- End of README.sound ---


--- Start of README.submodels ---

<?xml version="1.0"?>

<!--

Submodels are objects which can be dropped or launched from the user
aircraft. The trigger is a boolean property, which you define, which when
"true" causes the submodel to be released/launched.

A submodel will create an AIBallistic object which will follow a ballistic
path. By default one submodel will be released when the corresponding
trigger is "true".

Notes:
   1.  This utility is intended for ballistic objects which align to the
   trajectory. Drag is applied based on this assumption: no allowance is
   for changes in drag for objects which do not conform to this asumption.
   made

  2.  While Inertia is calculated properly, Moment of Inertia and rotational
  aerodynamic damping are simulated. It is assumed that the object is a cylinder
  of uniform density - if your object does not conform to this, there will be
  inaccuracies.

  3.  The program does not calculate windage for ballistic objects well. While
  adequate for smoke effects, etc., for bullets, bombs, droptanks this is probably
  best left at "False". Since the effects of wind on various ballistic objects is
  uncertain, there is no plan to change this situation.

  4. Submodels can be ensted to any depth, thus a submodel on expiry or impact etc,
  can launch a child submodel, which in turn can launch a submodel. and so on. This
  is the basis for Persistent Contrails, but any use is possible.

The initial conditions (IC) define the object's starting point (relative
to the user aircraft's "reported position"), and its initial speed and
direction (relative to the user aircraft).  If you want to release many
similar objects with similar IC, then you may use the <repeat>, <delay>
and <count> properties to define this.  The allowed properties are:

<name>         The name of the submodel.
<model>        The path to the visual model.
<trigger>      The property which will act as the trigger. If this tag is not
               included, the submodels will be released continuously, provided
               <count> is set to -1.
<speed>        Initial speed, in feet/sec, relative to user aircraft.
<speed-prop>   The property containing the Initial speed, in feet/sec, relative to
               user aircraft. If this path is found, <speed> will be overwritten.
<repeat>       Set "true" if you want multiple releases of this submodel.
<delay>        Time, in seconds, between repeated releases.
<count>        Number of submodels available for multiple release.
               -1 defines an unlimited number.
<slaved>       If true, the submodel is slaved to the parent model.
<x-offset>     Submodel's initial fore/aft position (in feet), relative to user
               aircraft.  Fore is positive.
<y-offset>     Submodel's initial left/right position (in feet), relative to user
               aircraft.  Right is positive.
<z-offset>     Submodel's initial up/down position (in feet), relative to user
               aircraft.  Up is positive.
<yaw-offset>   Submodel's initial azimuth, in degrees, relative to user
               aircraft'snose. Right is positive.
<pitch-offset> Submodel's initial elevation, in degrees, relative to user aircraft's
               pitch. Up is positive.
<life>         Life span in seconds.
               Default is 900.0.
<buoyancy>     In ft/sec/sec.  Works opposite acceleration of gravity.
               For example, if set to 32 the submodel will feel no
               gravity. If greater than 32 the object will rise.
               Default is 0.
<wind>         Set to true if you want the submodel to react to the wind. Default
               is "false".
<cd>           The Coeffient of Drag. Varies with submodel shape - 0.295 for a
               bullet, 0.045 for an airfoil. Enter an appropriate value. Defaults to
               0.295.
<random>       When this is true the Cd is varied by +- 5%. Useful for smoke or
               contrails.
<eda>          Effective drag area (sq ft). Usually the cross-sectional area of the
               submodel normal to the airflow.
<weight>       The weight of the submodel (lbs). NOT set to 0 on submodel release.
               You may wish to set this value to 0 by means of key bindings or Nasal
               script. Defaults to 0.25.
<contents>     The path to the contents of a submodel. The contents must be in lbs.
               Intended for use with drop tanks. The property value will be set to
               0 on release of the submodel: do not also set to 0 elsewhere e.g. in
               key bindings. Defaults to 0.
<random>       Varies CD by +- 10%, initial azimuth by +- 10 degs, and life by
               <randomness>
<randomness>   If <random> is true, <randomness> is applied to <life>. 0 > Value < 1
               are valid. Defaults to 0.5.
<no-roll>      If true the submodel does not roll.
<impact>       If true, the impact location (lat/lon) on the terrain is calculated.
               The Material (e.g Grass)of the terrain, load resistance, and impact
               velocity. Altitude agl is calculated.
<collision>    If true, collisions with other objects is tested. If a collision is
               detected then the position data are written to the "Report Node".
<fuze-range>   Used in detecting collisions. The distance in feet between an object
               and a submodel at which a collision is deemed to have occurred.
<expiry>       If true, the current position of the submodel is written to the
               "Report Node" when the submodel life expires.
<impact-reports> Defines a "Report Node". When an impact happens, then the path of
               the submodel will be written to this node. An attached listener
               function can evaluate the impact properties. If unset, reports go to
               /ai/models/model-impact.

***** experimental ****

<external-force> If true the submodel is subjected to an external force
<force-path> A string describing the property where the magnitude, azimuth and
             elevation of the external force are to be found. The following child
              properties are instantiated:
               ~/force-lb
              ~/force-azimuth-deg
              ~/force-elevation-deg

You will have to set these values by some means (Nasal script etc.) to make use of this
utility.

<PropertyList>

  <submodel>
    <name>left gun</name>
    <model>Models/Geometry/tracer.ac</model>
    <trigger>ai/submodels/submodel[0]/trigger</trigger>
    <speed>2750.0</speed>
    <repeat>true</repeat>
    <delay>0.25</delay>
    <count>100</count>
    <x-offset>1.0</x-offset>
    <y-offset>-7.0</y-offset>
    <z-offset>-2.0</z-offset>
    <yaw-offset>0.4</yaw-offset>
    <pitch-offset>1.8</pitch-offset>
    <life>2.0</life>
  </submodel>

  <submodel>
    <name>right gun</name>
    <model>Models/Geometry/tracer.ac</model>
    <trigger>ai/submodels/submodel[0]/trigger</trigger>
    <speed>2750.0</speed>
    <repeat>true</repeat>
    <delay>0.25</delay>
    <count>100</count>
    <x-offset>1.0</x-offset>
    <y-offset>7.0</y-offset>
    <z-offset>-2.0</z-offset>
    <yaw-offset>-0.4</yaw-offset>
    <pitch-offset>1.8</pitch-offset>
    <life>2.0</life>
  </submodel>

  <submodel>
    <name>droptank-l</name>
    <model>Aircraft/Hunter/Models/droptank-100gal.ac</model>
    <trigger>controls/armament/station[0]/jettison-all</trigger>
    <speed>0</speed>
    <repeat>false</repeat>
    <count>1</count>
    <x-offset>0.820</x-offset>
    <y-offset>-9.61</y-offset>
    <z-offset>-2.39</z-offset>
    <yaw-offset>0</yaw-offset>
    <pitch-offset>0</pitch-offset>
    <wind>false</wind>
    <eda>2.11348887</eda>
    <weight>170</weight>
    <cd>0.045</cd>
    <contents>consumables/fuel/tank[2]/level-lbs</contents>
  </submodel>

  <submodel>
    <name>droptank-r</name>
    <model>Aircraft/Hunter/Models/droptank-100gal.ac</model>
    <trigger>controls/armament/station[1]/jettison-all</trigger>
    <speed>0</speed>
    <repeat>false</repeat>
    <count>1</count>
    <x-offset>0.820</x-offset>
    <y-offset>9.61</y-offset>
    <z-offset>-2.39</z-offset>
    <yaw-offset>0</yaw-offset>
    <pitch-offset>0</pitch-offset>
    <wind>false</wind>
    <eda>2.11348887</eda>
    <weight>170</weight>
    <cd>0.045</cd>
    <contents>consumables/fuel/tank[3]/level-lbs</contents>
  </submodel>

  <submodel>
    <name>engine exhaust r</name>
    <model>Aircraft/seahawk/Models/exhaust_s.xml</model>
    <trigger>sim/ai/aircraft/exhaust</trigger>
    <speed-node>engines/engine/n1</speed-node>
    <speed>10</speed>
    <repeat>true</repeat>
    <delay>0.1</delay>
    <count>-1</count>
    <x-offset>-3.5</x-offset>
    <y-offset>2.6768</y-offset>
    <z-offset>-0.3937</z-offset>
    <yaw-offset>170</yaw-offset>
    <life>10</life>
    <buoyancy>128</buoyancy>
    <aero-stabilised>0</aero-stabilised>
    <wind>true</wind>
    <eda>1</eda>
    <cd>0.95</cd>
    <weight>1</weight>
    <random>1</random>
  </submodel>

</PropertyList>

-->

--- End of README.submodels ---


--- Start of README.systems ---

By Default systems are initialized by the Aircraft/generic/generic-system.xml
This initializes the following:
- The generic electrical system
- 1 pitot system, index [0]
- 1 static system index [0]
- 2 vacuum systems [0] and [1], depending on engine rpm of engine[0] and
  engine[1] respectfully

If you want to define more systems, copy the generic-system file to your
aircraft-name/Systems folder and rename it systems.xml

In your aircraft -set file add the path to the system.xml file:
<sim>
    ....
    <systems>
        ....
        <path>Aircraft/aircraft-name/Systems/systems.xml</path>
        ....
    </systems>
    ....
</sim>


** Adding a second pitot system.
In your systems.xml, you should already have

  <pitot>
    <name>pitot</name>
    <number>0</number>
    <stall-deg>60</stall-deg>           # optionnal, default to 60 degrees
  </pitot>

and you need to add for a pitot system with index 1:

  <pitot>
    <name>pitot</name>
    <number>1</number>
    <stall-deg>60</stall-deg>  #optionnal
  </pitot>

For the any pitot system except for the first (with index 0)
add in the aircraft -set file (below for index 1):

<systems>
      <pitot n="1">
                <serviceable>1</serviceable>
      </pitot>
</systems>

Of course you can add a third or fourth etc.


** Adding a second static system
Absolutely analog with the pitot system. So add in systems.xml:

  <static>
    <name>static</name>
    <number>1</number>
    <tau>1</tau>
    <type>0</type>                          #optionnal: 0,1 or 2 default is 0
    <error-factor>0.5</error-factor>        #optionnal see below default = 0
  </static>

and in the aircraft -set file:

<systems>
      <static n="1">
                <serviceable>1</serviceable>
      </static>
</systems>

Now you can source your instrumentation relying on static and pitot
pressure (airspeed, altimeter, vertical speed indicator) from different
and independent systems


** The PITOT System

The pitot system measures impact pressure and is basically a tube pointing forward.
Small aircraft have one, small IFR aircraft have one or two (of which at least
one is heated) and larger commercial aircraft have three or even more. In those large
aircraft the left pitot serves the pilot instruments, the right the co-pilot and
the third system the back-up instruments. This might be different for each type
of aircraft of course.
In Flightgear the pitot system outputs the total pressure to the following property:
/systems/pitot[n]/total-pressure-inhg and
/systems/pitot[n]/measured-total-pressure-inhg
which are the same except at supersonic speeds. For supersonic aircraft use the "measured"
property. See also the README.airspeed-indicator.
However it is advised for every aircraft to use the measured property. In future
this will be the property where all the measurement faults are reflected.
the following "measurement failures" are currently applied:
1) decrease of total and measured pressure due to side-slip and angle of attack
2) at 60 deg the pitot tube will stall and the value will fall back to static pressure
3) for the "measured" property only: at Mach>1, a shock wave is assumed in front of the
  pitot tube, decreasing the total pressure.

The stall angle may be (optionally) set to any angle between 0 and 90 deg
(default = 60 deg) like so:
  <pitot>
    <name>pitot</name>
    <number>0</number>
    <stall-deg>45</stall-deg>
  </pitot>

Both the decrease of the pitot pressure and the default stall angle are based on a measurement
on an AN5812 pitot tube.


** The STATIC system

The static system measures the static pressure. So all influences of airspeed are eliminated.
In real life this is however not always easy. Effects from angle of attack, side-slip, flap defection,
gear extension, engine power setting and airspeed are present and for the aircraft
designer it is not alway easy to find a good position for the static port.
Usually the number of static systems are equal to the number of pitot systems.
In Flightgear there are 3 types of static systems modelled.
Type 0 (default): the perfect sensor. No measurement failures.
Type 1: Dual static ports on the fuselage sides. Side-slip angle influence only. this model the whole pair.
Type 2: Static port on the pitot tube. Both angle of attack and side-slip influence.
If you want to use type 1 or 2:
  <static>
    <name>static</name>
    <number>0</number>
    <tau>0.1</tau>
    <type>1</type>
    <error-factor>0.5</error-factor>
  </static>
The output property /systems/static[n]/pressure-inhg is filtered. Therefore, if you want to see
the effect of the measurement failure, "tau" should be 0.1 or smaller.
The "error-factor" should be between 0.2 and 0.7. Setting it to 0 equals a "perfect sensor".
A setting of 1 means the whole (projected on static port face) impact pressure is applied.
This is not realistic as usually there are more than one static pick-up points
and so the pressure increase gets "flattened".

--- End of README.systems ---


--- Start of README.tutorials ---

== README.tutorials ===========================================================

FlightGear offers a flexible tutorial system, entirely written in the Nasal
language. Tutorials can be started and stopped from the "Help" menu. They are
defined in XML files. Each of them has to be loaded into /sim/tutorials/ under
a separate tutorial[n]/ branch:

  <sim>
      <tutorials>
          <tutorial include="Tutorials/take-off.xml"/>
          <tutorial include="Tutorials/landing.xml"/>
      </tutorial>
  </sim>

Alternatively, all tutorials can be defined in one file, with <tutorial> tags
around each tutorial. This is then included like so:

  <sim>
      <tutorials include="foo-tutorials.xml"/>
  </sim>

Finally, tutorials are automatically generated from any valid checklists
on startup.  See README.checklists for details.


== TUTORIAL STRUCTURE =========================================================


A tutorial has this structure, where some of the elements are described
in detail below:


<tutorial>
  <name>...</name>            mandatory; short identifier, also shown in the
                                         tutorial selection dialog
  <description>...</description> mandatory; longer description for the dialog
  <audio-dir>...</audio-dir>  optional; defines where to load sound samples
  <timeofday>noon</timeofday> optional; defines daytime; any of "dawn",
                                        "morning", "noon", "afternoon",
                                        "evening", "dusk", "midnight", "real"

  <step-time>                 optional; period between each step being executed.
                              Default 5
  <exit-time>                 optional; period between exit/abort conditions being
                              checked. Default 1

  <nasal>
      ...                     optional; initial Nasal code; see below
  </nasal>

  <models>
      ...                     optional; scenery objects; see below
  </models>

  <targets>
      ...                     optional; targets; see below
  </targets>

  <presets>
      ...                     optional; initial simulator state; see below
  </presets>


  <init>                      optional; initial settings; see below
    <set>
        ...                     optional; property settings; allowed multiple
    </set>                      times
    <view>
        ...                     optional; view settings
    </view>
    <marker>
        ...                     optional; marker coordinates
    </marker>
    <nasal>
        ...                     optional; Nasal code
    </nasal>
  </init>

  <step>                      mandatory; well, not really, but if there's not
                              at least one <step>, then the whole tutorial
                              won't do anything; see below for details

    <message>...</message>      optional; message to be displayed/spoken when
                                <step> is entered; allowed multiple times, in
                                which case one is chosen at random

    <message-param>             optional; allowed up to 4 times.
      <property>...</property>  property to substitute into the <message> string
    </message-param>            using sprintf() formatting.  E.g. %d, %.2f

    <audio>...</audio>          optional; file name of *.wav sample to be played;
                                          may be used multiple times (random)
    <set>
        ...                     optional; allowed several times
    </set>
    <view>
        ...                     optional
    </view>
    <marker>
        ...                     optional
    </marker>
    <nasal>
        ...                     optional; Nasal code that is executed when the
    </nasal>                              step is entered

    <wait>10</wait>             optional; wait period after initial messages etc.

    <error>                     optional; allowed several times
        <message>..</message>       optional; text displayed/spoken
        <audio>...</audio>          optional; name of *.wav sample to be played

        <condition>
            ...                     optional, but one should be there to make sense
        </condition>                          see $FG_ROOT/Docs/README.conditions

        <nasal>
            ...                     optional; Nasal code that is executed when the
        </nasal>                              error condition was fulfilled
    </error>

    <exit>                      optional; defines when to leave this <step>
        <condition>                       see $FG_ROOT/Docs/README.conditions
            ...
        </condition>

        <nasal>
            ...                     optional; Nasal code that is executed when the
        </nasal>                              exit condition was met
    </exit>
  </step>


  <end>                           optional; final settings & actions; see below
      <message>...</message>          optional; multiple times (random)
      <audio>...</audio>              optional; multiple times (random)
      <set>
          ...                         optional
      </set>
      <view>
          ...                         optional
      </view>
      <nasal>
          ...                         optional
      </nasal>
  </end>
</tutorial>



After the tutorial has finished initialization, it goes through all <steps>.
For each it outputs the <message> or <audio>, optionally sets a <marker> and/or
a <view>, then it checks all <error>s and, if an <error><condition> is fulfilled,
outputs the respective <error><message>. If none of the <error>s occurred, then
it checks if the <exit><condition> is true, and if so, it jumps to the next
<step>. Otherwise the current <step> is endlessly repeated. Finally, after all
<step>s were processed, the <end> group is executed.








== ELEMENTS ===================================================================


-- <nasal> --------------------------------------------------------------------

Embedded Nasal is supported on the top level, in <init> in each <step>, in a
<step>'s <error> and <exit>, and in <end>. All Nasal runs in a separate
namespace __tutorial, so it's possible to define a function in the <init>'s
Nasal block, and to use this function in other blocks without prefix. The
namespace is preloaded with some functions:


  next([n=1])      ... to switch n <step>s forward
  previous([n=1])  ... to switch n <step>s backwards

  say(what [, who="copilot [, delay=0]])
                   ... says 'what' with voice 'copilot' after 'delay' seconds


A Nasal group looks like this:

  <nasal>
      <script>
          say("Hi, I'm the pilot!", "pilot");
      </script>
      <module>__tutorial</module>           optional; preset with __tutorial
  </nasal>





-- <models> -------------------------------------------------------------------

This loads models into the scenery. It can be used to place, for example,
a helicopter landing pad at an airport where normally none is, so that the
tutorial can train landing. The layout is the following, with <path> being
relative to $FG_ROOT:

  <models>
      <model>
          <path>Models/Airport/supacat_winch.ac</path>     mandatory
          <longitude-deg>-122.4950109</longitude-deg>      mandatory
          <latitude-deg>37.51403798</latitude-deg>         mandatory
          <elevation-ft>51</elevation-ft>                  mandatory
          <heading-deg>2.488888979</heading-deg>           optional (default: 0)
          <pitch-deg>0</pitch-deg>                         optional (default: 0)
          <roll-deg>0</roll-deg>                           optional (default: 0)
      </model>

      <model>
          ...                      another model
      </model>
  </models>

The models are only removed before a new tutorial is loaded. Otherwise they
remain in the scenery for the whole FlightGear session. They aren't permanently
added.





-- <targets> ------------------------------------------------------------------

These are simple pairs of longitude/latitude under an arbitrary name (here
"hospital" and "helipad"):

  <targets>
      <hospital>
          <longitude-deg>-122.4950109</longitude-deg>      mandatory
          <latitude-deg>37.51403798</latitude-deg>         mandatory
      </hospital>

      <helipad>
          ...
      </helipad>
  </targets>


The tutorial system will for each calculate how the user's aircraft is positioned
relative to the respective target, and offer the information in this structure:

  <sim>
      <tutorials>
          <targets>
              <hospital>
                  <direction-deg>12.345</direction-deg>
                  <heading-deg>33.333</heading-deg>
                  <distance-m>12404.932</distance-m>
                  <eta-min>39.2358</eta-min>
              </hospital>

              <helipad>
                  ...
              </helipad>
          </targets>
      </tutorials>
  </sim>


Where:
  <direction-deg> is an angle between the aircraft's velocity vector and the
                  azimuth to the target. 0 means that the aircraft is moving
                  right towards the target. 10 means that the target is slightly
                  to the right, -90 means that it's exactly left, and -180 or
                  179.9999 that it's right behind.

  <heading-deg>   is the absolute heading that the aircraft would currently
                  have to fly with in a straight line to reach the target

  <distance-m>    is the distance in meters

  <eta-min>       is the "Estimated Time of Arrival" given the aircraft's
                  current speed towards the target. Positive times mean that
                  the aircraft is getting nearer to the target and can arrive
                  there in this time given the current speed. It will, of course,
                  only arrive there, if <direction-deg> is zero. A negative
                  number means that the aircraft moves away, or in other words:
                  that in this number of minutes it will be away twice as far.





-- <presets> ------------------------------------------------------------------

These set the initial simulator state. All properties are optional.
The last three entries are to define the position relative to the
airport/runway or the longitude/latitude.

  <presets>
      <airport-id>KHAF</airport-id>
      <on-ground>1</on-ground>
      <runway>12</runway>
    <!--
      <altitude-ft>122.333</altitude-ft>
      <latitude-deg>37.555</latitude-deg>
      <longitude-deg>1000</longitude-deg>
    -->
      <heading-deg>0</heading-deg>
      <airspeed-kt>0</airspeed-kt>
      <glideslope-deg>0</glideslope-deg>
      <offset-azimuth>0</offset-azimuth>
      <offset-distance>0</offset-distance>
  </presets>





-- <set> ----------------------------------------------------------------------

<set> groups can be used in <init>, <step>, and <end>. They set a <property>
to a given <value> or to the value that a second <property> points to. They
can also reset values that were only temporarily changed for the duration
of the tutorial. This is desirable for properties that are saved to the
aircraft config file or to ~/.fgfs/autosave.xml.

  <set>
      <property>/foo/bar</property>        set /foo/bar to 123
      <value>123</value>
  </set>

  <set>
      <property>/foo/bar</property>        set /foo/bar to value of /test
      <property>/test</property>
  </set>





-- <view> ---------------------------------------------------------------------

These groups can be used in <init>, <step>, and <end>. They smoothly move the
view to a new view position/direction. All parameters are optional. If, for
example, only <field-of-view> is set, then the view will only zoom in -- the
direction and position will remain the same. This feature is meant for cockpit
tutorials, where the pilot's view is directed to some switch or instrument.
view-number can be used to switch between different views, i.e. to tower-view,
copilot view etc. Default view-number is 0 (captain's view).

  <view>
      <view-number>0</view-number>                 0=captain's view, 1=copilot,...
      <heading-offset-deg>20</heading-offset-deg>  positive is left
      <pitch-offset-deg>-4</pitch-offset-deg>      positive is up
      <roll-offset-deg>0</roll-offset-deg>         positive is roll right
      <x-offset-m>0.2</x-offset-m>                 positive is move right
      <y-offset-m>0.2</y-offset-m>                 positive is move up
      <z-offset-m>0.2</z-offset-m>                 positive is move back
      <field-of-view>55</field-of-view>            default: 55; smaller zooms in
  </view>                                                       bigger zooms out





-- <marker> -------------------------------------------------------------------

These are supported in <init>, <step>, and <end>. They show a magenta colored
circle at given position (relative to aircraft origin) in given size. See the
last section for how to conveniently find the proper coordinates.

  <marker>
      <x-m>1.3</x-m>                               positive is back
      <y-m>0.3</y-m>                               positive is to the right
      <z-m>0.1</z-m>                               positive is up
      <scale>1.3</scale>                           optional; default: 1
  </marker>


For this to work, the aircraft model needs to include the tutorial marker
model in its animation xml file:

  <PropertyList>
      <path>lightning-f1a.ac</path>

      <model>
          <path>Aircraft/Generic/marker.xml</path>
      </model>

      ...
  </PropertyList>





-- <message>/<audio> ----------------------------------------------------------

Groups <step> and <end> can have one or more <message> entries, and one or
more <audio> entries. If more are used of a kind, then the tutorial chooses
one at random. If <audio> are available, then the contents are interpreted as
file name of a *.wav sample, which is appended to the <audio-dir> path defined
at the <tutorial> top level (default: "") and played by the tutorial system.
Otherwise the <message> is handed over to the voice system, and synthesized
to speech by the Festival speech synthesizer (if installed). In either
case the chosen <message> is displayed on top of the screen. Neither <message>
nor <audio> are mandatory.

Because one and the same <message> string can be displayed *and* be synthesized,
which can be problematic in some cases, there is a way to specify parts for
either display *or* voice synthesizer:  "{<display part>|<voice part}".
Example:

  <message>Press the {No1|number one} button!</message>

Here, "No1" would be displayed on the screen, but "number one" would be
sent to the speech synthesis system. This can also be used to add
invisible but audible exclamation marks:   "Press the button{|!}"





-- <condition> ----------------------------------------------------------------

These are explained in detail in $FG_ROOT/Docs/README.conditions. Here's just
one example:

  <condition>
      <less-than>
          <property>/foo/bar</property>
          <value>12</value>
      </less-than>
  </condition>

This condition is true when the value of /foo/bar is less than 12, and false
otherwise.








== FINDING MARKER COORDINATES =================================================

If an aircraft tutorial wants to use the marker, then the aircraft animation
file needs to include the marker model (see above). If this is done, then one
can use the "marker-adjust" dialog to find the respective <marker> coordinates.
Just type this into the "Help->Nasal Console" dialog:

  tutorial.dialog()


Or temporarily add a key binding to the *-set.xml file:

  <key n="96">
      <name>Backtick</name>
      <desc>Open marker adjust dialog</desc>
      <binding>
          <command>dialog-show</command>
          <dialog-name>marker-adjust</dialog-name>
      </binding>
  </key>


The dialog allows to move a red cross around, which has the blinking marker
circle in the middle. Note that ctrl- and shift-modifiers modulate the slider
movements. Ctrl makes positioning coarser, and shift finer. The [Reset]
button moves the marker back to aircraft origin, the [Center] button centers
the sliders, and the [Dump] button dumps the marker coordinates to the
terminal, for example:

  <marker>
      <x-m>1.1425</x-m>
      <y-m>0.1994</y-m>
      <z-m>-0.0844</z-m>
      <scale>2.0489</scale>
  </marker>

This just needs to be copied to the tutorial XML file.

--- End of README.tutorials ---


--- Start of README.voice.html ---

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
<html>
	<head>
		<title>FlightGear: Festival Voice Interface</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	</head>

	<body>


<h1>FlightGear: Festival Voice Interface</h1>

This page describes how to use FlightGear's voice interface to the Festival speech synthesis system, so that
ATC, Pilot, etc. messages can be made audible. These messages are normally only displayed on top of the screen.
A raw socket mode allows to send the messages to arbitrary servers.


<h2>Quick instructions (assuming that you have Festival installed)</h2>

<blockquote><pre>
$ festival --server &amp;
$ fgfs --aircraft=j3cub --airport=KSQL --prop:/sim/sound/voices/enabled=true</pre></blockquote>

Now, in FlightGear, enable ATC (in the menu under "ATC"-&gt;"Options"), press the '-key (apostrophe key) and
send a message to the ATC. Hear "your" voice, that of the ATC, and some time later that of AI-planes.



<h2>Installing the Festival system</h2>

<ul>
<li>
	Make sure Festival is installed, or download it from here:
	<a href="http://www.cstr.ed.ac.uk/projects/festival/">http://www.cstr.ed.ac.uk/projects/festival/</a>
</li><li>
	Check if Festival works. Only the relevant lines are shown here. Note the parentheses!
	<blockquote><pre>
$ festival
festival&gt; (SayText "FlightGear")
festival&gt; (quit)</pre></blockquote>
</li><li>
	Check if MBROLA is installed, or download it from here:
	<a href="http://tcts.fpms.ac.be/synthesis/mbrola/">http://tcts.fpms.ac.be/synthesis/mbrola/</a> -&gt; "Downloads"
	-&gt; "MBROLA binary and voices" (link at the bottom; hard to find). Choose the binary for your platform.
	Unfortunately, there's no source code available. If you don't like that, then you can skip the whole MBROLA
	setup. But then you can't use the more realistic voices. You can also install further MBROLA voices from
	this page. (See below)
</li><li>
	Run MBROLA and marvel at the help screen. That's just to check if it's in the path and executable.
	<blockquote><pre>
$ mbrola -h</pre></blockquote>
</li>
</ul>


<h2>Installing more voices</h2>

I'm afraid this is a bit tedious. You can skip it if you are happy with the default voice. First find the
Festival data directory. All Festival data goes to a common file tree, like in FlightGear. This can be
<tt>/usr/local/share/festival/</tt> on Unices. We'll call that directory <tt>$FESTIVAL</tt> for now.

<ul>
<li>
	Check which voices are available. You can test them by prepending <tt>voice_</tt>:
	<blockquote><pre>
$ festival
festival&gt; (print (mapcar (lambda (pair) (car pair)) voice-locations))
(kal_diphone rab_diphone don_diphone us1_mbrola us2_mbrola us3_mbrola en1_mbrola)
nil
festival&gt; (voice_us3_mbrola)
festival&gt; (SayText "I've got a nice voice.")
festival&gt; (quit)</pre></blockquote>
</li><li>
	Festival voices and MBROLA wrappers can be downloaded here:
	<a href="http://festvox.org/packed/festival/1.95/">http://festvox.org/packed/festival/1.95/</a>
	The "don_diphone" voice isn't the best, but it's comparatively small and well suited for "ai-planes".
	If you install it, it should end up as directory <tt>$FESTIVAL/voices/english/don_diphone/</tt>. You also need
	to install "festlex_OALD.tar.gz" for it as <tt>$FESTIVAL/dicts/oald/</tt> and run the Makefile in this
	directory. (You may have to add "<tt>--heap 10000000</tt>" to the festival command arguments in the Makefile.)
</li><li>
	Quite good voices are "us2_mbrola", "us3_mbrola", and "en1_mbrola". For these you need to install
	MBROLA (see above) as well as these wrappers: <tt>festvox_us2.tar.gz</tt>, <tt>festvox_us3.tar.gz</tt>,
	and <tt>festvox_en1.tar.gz</tt>. They create directories <tt>$FESTIVAL/voices/english/us2_mbrola/</tt> etc.
	The voice <em>data</em>, however, has to be downloaded separately from another site:
</li><li>
	MBROLA voices can be downloaded from the MBROLA download page (see above). You want the
	voices labeled "us2" and "us3". Unpack them in the directories that the wrappers have created:
	<tt>$FESTIVAL/voices/english/us2_mbrola/</tt> and likewise for "us3" and "en1".
</li>
</ul>


<h2>Running FlightGear with voice support</h2>

<ul>
<li>First start the festival server:
	<blockquote><pre>
$ festival --server</pre></blockquote>
</li><li>
	Start FlightGear with enabled voice subsystem, let's say with
	<blockquote><pre>
$ fgfs --aircraft=j3cub --airport=KSQL --prop:/sim/sound/voices/enabled=true</pre></blockquote>
	Of course, you can put this option into your personal configuration file. This doesn't mean that
	you then <em>always</em> have to use FlightGear together with Festival. You'll just get a few
	error messages in the terminal window, but that's it. Note that you can currently <em>not</em>
	enable the voice subsystem at runtime!
</li><li>
	Open the property browser to <tt>/sim/sound/voices/voice[0]/</tt> and write some text to the
	<tt>text</tt> property. You should now hear this spoken with the default voice ("voice_kal_diphone").
	You can try the same with <tt>voice[1]/</tt> etc. and should hear different voices if they
	are installed, or the default voice again otherwise.
</li><li>
	Contact the KSFO ATC via '-key dialog (apostrophe key). You should hear "your" voice first (and see the
	text in yellow color on top of the screen), then you should hear ATC answer with a different voice (and see
	it in light-green color).
</li><li>
	You can edit the voice parameters in the <tt>preferences.xml</tt> file, and select different
	screen colors and voice assignments in <tt>$FG_ROOT/Nasal/voice.nas</tt>. The messages aren't written
	to the respective <tt>/sim/sound/voices/voice[*]/text</tt> properties directly, but rather to aliases
	<tt>/sim/sound/voices/{atc,approach,ground,pilot,ai-plane}</tt>. (BTW: I've never heard anything from
	<tt>ground</tt> and <tt>approach</tt> yet.)
</li>
</ul>



<h2>Configuration &amp; Internals</h2>

The <em>voice</em> subsystem only offers the common subsystem functions to the rest of FlightGear.
There's no built-in function to let it send data to the socket. The only way is to write to the
respective speech properties. The number of available voices, or rather "channels", isn't hard-coded.
It's the number of &lt;voice&gt; groups in "/sim/sound/voices" that decides how many channels should be
opened. This is a typical setting of interface properties, whereby the aliases at the end have
nothing to do with the subsystem, but are handy shortcuts:

<blockquote><pre>
&lt;sim&gt;
    &lt;voices&gt;
        &lt;host type="string"&gt;localhost&lt;/host&gt;
        &lt;port type="string"&gt;1314&lt;/port&gt;
        &lt;enabled type="bool"&gt;false&lt;/enabled&gt;

        &lt;voice&gt;
            &lt;desc&gt;Pilot&lt;/desc&gt;
            &lt;text type="string"&gt;&lt;/text&gt;
            &lt;volume type="double"&gt;1.0&lt;/volume&gt;
            &lt;pitch type="double"&gt;100.0&lt;/pitch&gt;
            &lt;speed type="double"&gt;1.0&lt;/speed&gt;
            &lt;preamble type="string"&gt;(voice_us3_mbrola)&lt;/preamble&gt;
            &lt;festival type="bool"&gt;true&lt;/festival&gt;
        &lt;/voice&gt;

        &lt;voice&gt;
            ...
        &lt;/voice&gt;

        &lt;!-- handy aliases, not part of the interface: --&gt;

        &lt;atc alias="/sim/sound/voices/voice[0]/text"/&gt;
        &lt;approach alias="/sim/sound/voices/voice[0]/text"/&gt;
        &lt;ground alias="/sim/sound/voices/voice[0]/text"/&gt;
        &lt;pilot alias="/sim/sound/voices/voice[1]/text"/&gt;
        &lt;copilot alias="/sim/sound/voices/voice[2]/text"/&gt;
        &lt;ai-plane alias="/sim/sound/voices/voice[3]/text"/&gt;
    &lt;/voices&gt;
&lt;/sim&gt;
</pre></blockquote>

The &lt;enabled&gt; property decides at init time whether the subsystem should
be activated or not. There's currently no way to change this at runtime.

Each &lt;voice&gt; group defines one channel. &lt;text&gt; is the output
property. Every value that's written to it will be spoken by this channel.
If &lt;festival&gt; is true, then the channel will set up &lt;pitch&gt; and
&lt;speed&gt; (&lt;volume&gt; does currently not work and has to be <tt>1</tt>),
and puts Festival markup around the text. If &lt;festival&gt; is false,
then all text is written verbatim to the socket. &lt;preamble&gt; is always
written to the socket once as last step of the socket creation. In "festival"
mode it's used to set the voice, while in raw mode it could be used to identify
the channel (assuming that the server knows what to do with it).



<h2>Usage</h2>

The design principle is that message generators (e.g. the ATC subsystem) write
to a message property (e.g. <tt>/sim/messages/pilot</tt>). A listener ($FG_ROOT/Nasal/screen.nas)
watches this property and decides what to do with it. For pilot and ATC it writes the message
to the screen.log and copies it to the <tt>/sim/sound/voices/pilot</tt> property. This
is an alias to the real voice channel <tt>/sim/sound/voices/voice[1]/text</tt>.
This allows the most control and makes all steps user-configurable from Nasal
scripts. Message generator should <em>not</em> write to the voice's &lt;text&gt;
property directly, and only to the <tt>/sim/sound/voices/*</tt> aliases if a
message should not be displayed by the system.



<h2>Backward compatibility</h2>

The new voice subsystem is functionally compatible with the old one that
was part of the ATC subsystem. You just need to turn the &lt;festival&gt;
bool properties off and set the server address correctly. This sends only
the messages without any Festival syntax added:

<blockquote><pre>
&lt;sim&gt;
    &lt;voices&gt;
        &lt;host type="string"&gt;192.168.2.15&lt;/host&gt;
        &lt;port type="string"&gt;7100&lt;/port&gt;
        &lt;enabled type="bool"&gt;true&lt;/enabled&gt;
        &lt;voice&gt;
            &lt;desc&gt;ATC/Approach/Ground&lt;/desc&gt;
            &lt;text type="string"&gt;&lt;/text&gt;
            &lt;preamble type="string"&gt;ATC&lt;/preamble&gt;
            &lt;festival type="bool"&gt;false&lt;/festival&gt;
        &lt;/voice&gt;
        &lt;voice&gt;
            &lt;desc&gt;Pilot&lt;/desc&gt;
            &lt;text type="string"&gt;&lt;/text&gt;
            &lt;preamble type="string"&gt;Pilot&lt;/preamble&gt;
            &lt;festival type="bool"&gt;false&lt;/festival&gt;
        &lt;/voice&gt;
        ...
    &lt;/voices&gt;
&lt;/sim&gt;
</pre></blockquote>

&lt;volume&gt;, &lt;pitch&gt;, and &lt;speed&gt; have no meaning and can
be left away. Note that also in this mode the preamble gets sent first.
It can be used to identify the channel. Of course, all messages could be
sent to just one channel, though.



<h2>Multichannel server</h2>

Raw mode does, of course, require a different server than Festival. Here's
a small Perl example for a multichannel server. Note how the &lt;preamble&gt;
is used as channel identification:


<blockquote><pre>
#!/usr/bin/perl -Tw
# License: GPL V2
# Modified after Example from perlipc.pod ($ man perlipc)

use strict;
BEGIN {
	$ENV{PATH} = '/usr/ucb:/bin';
}

use Socket;
use Carp;
my $EOL = "\015\012";

sub spawn;  # forward declaration
sub logmsg {
	print "$0 $$: @_ at ", scalar localtime, "\n";
}


my $port = shift || 1314;
my $proto = getprotobyname('tcp');


($port) = $port =~ /^(\d+)$/ or die "invalid port";


socket(Server, PF_INET, SOCK_STREAM, $proto) || die "socket: $!";
setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die "setsockopt: $!";
bind(Server, sockaddr_in($port, INADDR_ANY)) || die "bind: $!";
listen(Server,SOMAXCONN) || die "listen: $!";


logmsg "server started on port $port";


my $waitedpid = 0;
my $paddr;

use POSIX ":sys_wait_h";
sub REAPER {
	my $child;
	while (($waitedpid = waitpid(-1,WNOHANG)) &gt; 0) {
		logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
	$SIG{CHLD} = \&amp;REAPER;  # loathe sysV
}


$SIG{CHLD} = \&amp;REAPER;

for ($waitedpid = 0;
		($paddr = accept(Client,Server)) || $waitedpid;
		$waitedpid = 0, close Client) {
	next if $waitedpid and not $paddr;
	my($port,$iaddr) = sockaddr_in ($paddr);
	my $name = gethostbyaddr($iaddr,AF_INET);

	logmsg "connection from $name [", inet_ntoa($iaddr), "] at port $port";

	spawn sub {
		$|=1;
		print "Hello there, $name, it's now ", scalar localtime, $EOL;
		exec '/usr/bin/fortune'           # XXX: `wrong' line terminators
			or confess "can't exec fortune: $!";
	};
}


sub spawn
{
	my $coderef = shift;

	unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq 'CODE') {
		confess "usage: spawn CODEREF";
	}

	my $pid;
	if (!defined($pid = fork)) {
		logmsg "cannot fork: $!";
		return;
	} elsif ($pid) {
		logmsg "creating child $pid";
		return; # I'm the parent
	}
	# else I'm the child -- go spawn

	# print header
	my $id;
	while (&lt;Client&gt;) {
		s/^\s+//;
		s/\s+$//;

		# first line is voice channel id = "&lt;preamble&gt;"
		if (not defined $id) {
			$id = $_;
			next;
		}

		print "\033[32m$id: \033[m$_\n";
		last unless /\S/;
	}

	open(STDIN,  "&lt;&amp;Client") || die "can't dup client to stdin";
	open(STDOUT, "&gt;&amp;Client") || die "can't dup client to stdout";
	## open(STDERR, "&gt;&amp;STDOUT") || die "can't dup stdout to stderr";
	exit &amp;$coderef();
}
</pre></blockquote>

</body>
</html>


--- End of README.voice.html ---


--- Start of README.wildfire ---

Cellular Automata based wildfire for FlightGear/CVS
---------------------------------------------------

Copyright (C) 2008 - 2009  Anders Gidenstam

 *  These programs are free software; you can redistribute them and/or modify
 *  them under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Usage
-----

A fire is started by calling wild_fire.ignite(pos) where pos is a
valid geo.Coord instance.

Example: starting fires by ctrl+shift+click:

Put this Nasal fragment somewhere where it is run at startup.
(E.g. in a <nasal><MyStuff><script>...</script></MyStuff></nasal>
block in preferences.xml.)

setlistener("/sim/signals/click", func {
  if (__kbd.shift.getBoolValue()) {
    if (__kbd.ctrl.getBoolValue()) {
      var click_pos = geo.click_position();
      wildfire.ignite(click_pos);
    }
  }
});


Configuration properties
-----------------------

These properties can be set at runtime, in preferences.xml or in any
other way supported by FlightGear.

/environment/wildfire/enabled : bool
  Enables/disables the whole WildFire module.
  On disable the current state is lost. Can be used to reset WildFire.

/environment/wildfire/share-events : bool
  Enables/disables sending and receiving of fire events over the
  multiplayer network.

/environment/wildfire/fire-on-crash : bool
  If true a fire will start if the aircraft crashes.

/environment/wildfire/report-score : bool
  Report the result of fire fighting.

/environment/wildfire/models/enabled : bool
  Enables/disables rendering of the 3d models.
  (That is, fire, smoke, soot and foam.)

/environment/wildfire/save-on-exit : bool
  If set the current log of Wildfire events is saved in
  ~/.fgfs/Wildfire/fire_log.xml .

/environment/wildfire/restore-on-startup : bool
  If set Wildfire will load and execute the events in
  ~/.fgfs/Wildfire/fire_log.xml . This recreates the fire state
  as it where when the log was saved.
  NOTE: A long event log or one that covers a long period of time will take
  a a lot of time to recreate.
  Storing and reloading of the CA state, as opposed to the event log, is not
  supported yet.


API
---

ignite : func (pos, source=1)
     pos    - fire location    : geo.Coord
     source - broadcast event? : {0, 1}

   Start a fire.


resolve_water_drop : func (pos, radius, volume, source=1)
     pos    - drop location    : geo.Coord
     radius - drop radius m    : double
     volume - Not used         : double
     source - broadcast event? : {0, 1}

  Extinguishes any fires in the cells within r of pos and
  makes the cells nonflammable.

resolve_retardant_drop : func (pos, radius, volume, source=1) {
     pos    - drop location    : geo.Coord
     radius - drop radius m    : double
     volume - Not used         : double
     source - broadcast event? : {0, 1}

  Identical to resolve_water_drop.

resolve_foam_drop : func (pos, radius, volume, source=1) {
     pos    - drop location    : geo.Coord
     radius - drop radius m    : double
     volume - Not used         : double
     source - broadcast?       : {0, 1}

  Extinguishes any fires in the cells within r of pos and
  makes the cells nonflammable and foamy.

load_event_log : func (filename, skip_ahead_until=-1)
     filename         - getprop("/sim/fg-home") ~ "/Wildfire/" ~ filename
     skip_ahead_until - skip from last event to this time : double (epoch)
                        fast forward from skip_ahead_until
                        to current time.
       x < last event   - fast forward all the way to current time (use 0).
                          NOTE: Can be VERY time consuming.
       -1               - skip to current time.

  Loads an event log.
  The skip_ahead_until argument can be used for synchronizing a restored
  fire state among multiple players.

save_event_log : func (filename)
     filename         - getprop("/sim/fg-home") ~ "/Wildfire/" ~ filename

  Saves an event log.

print_score = func
  Print a summary of the current wildfire state.


/Anders

--- End of README.wildfire ---


--- Start of README.xmlhud ---

Users' Guide to FlightGear Hud configuration
December 22 2000
Neetha Girish <neetha@ada.ernet.in>

This document describes the reconfigurable HUD of
FlightGear implemented through XML config files.
The present reconfigurable HUD code uses most of the code
of version 0.6.1 vintage and I have adapted the same to provide
a reconfigurable HUD for fgfs.
Corrections and additions are welcome.

Some History:

Older versions of FGFS had a hard coded display of HUD.
This was a less than ideal state of affairs when it came to
using different aircraft Huds. I remember, somewhere in the 0.6.1 HUD code
it was written that the HUD code is 'presently' hard coded but ideally should
be moved into the aircraft configuration dataset, so that when you choose
an aircraft, its HUD loads.
This implementation make that possible, all you have to do is to
create appropriate 'my_aircraft.xml' files in the HUD directory and
without re-compiling the code you could have 'your_aircraft' HUD, by choosing that
in the .fgfsrc file or as a command line option as described later. Of course,
as of now, I have only implemented those HUD instruments in .xml readable form
as was available in version 0.7.6 + few more used by ADA, Bangalore for our
aircraft carrier take-off/landing simulation studies <www.flightgear.org/projects/ADA>.
To use the ADA specific reticles/HUD objects, please contact me/ you can figure it out
yourself by studying the code. All of them are relevant 'only' if you use the conformal
climb/dive ladder, since they are all referenced to it.
The rewrite of Hud display code was done using pre and post release v0.7.6 code
allowing for configuration of the hud via XML.

The present Configurable Hud implements the entire functionality of
fgfs HUD (called default HUD) till this date.

Using Default/Custom Hud:

The default HUD location is $FG_ROOT/Huds/Default.
$FG_ROOT is the place on your filesystem where you installed FG
data files. Alternate huds can be specified on the command line
or set as the default in the $HOME/.fgfsrc or $FG_ROOT/preferences.xml
using a property specification. The command line format is as follows:

--prop:/sim/hud/path=Huds/Default/default.xml

The path description shown is relative to $FG_ROOT. An absolute
path may also be used for locations outside $FG_ROOT.
For the custom Hud the path will be Huds/Custom/default.xml


Hud - Implementation:

All of the hud configuration files are XML-encoded property lists.
The root element of each file is always named <PropertyList>. Tags are
always found in pairs, with the closing tag having a slash prefixing
the tag name, i.e </PropertyList>. The top level panel configuration
file is composed of a <name> and zero or more <instruments>.
Instruments are used by including a <"unique_name"> and a <path> to the
instruments configuration file.
Comments are bracketed with <!-- -->.

    Example Top Level Hud Config

<PropertyList>
 <name>Default Aircraft Hud</name>
 <instruments>

  <hudladder>                   <!--unique name -->
   <path>Huds/Instruments/Default/hudladder.xml</path>
  </hudladder>

  <hudcard>
   <path>Huds/Instruments/Default/hudcard.xml</path>
  </hudcard>

  <instrlabel>
   <path>Huds/Instruments/Default/instrlabel.xml</path>
  </instrlabel>

  <fgTBI>
   <path>Huds/Instruments/Default/fgtbi.xml</path>
  </fgTBI>

 </instruments>
</PropertyList>


The default location for instrument files is $FG_ROOT/Huds/Instruments/Default.
The location for custom instrument files is  $FG_ROOT/Huds/Instruments/Custom.
The location for minimal instrument files is $FG_ROOT/Huds/Instruments/Minimal.
Alternate locations may be specified in the hud configuration, paths
must be absolute to use files outside $FG_ROOT.

About Instrument Placement:

For the sake of simplicity the FGFS HUD overlay is always 640 x 480 res.
so all x/y values for instrument placement should fall within these bounds.
Being an OpenGL program, 0,0 represents the lower left hand corner of the
screen.

Instrument Implementation:

Instruments are defined in separate configuration files.
The Instruments are basically classified into 4 types( Each of them an xml file) :
The Hud Ladder,
The Hud Card,
The Hud Label and
The Turn Bank Indicator
.... (Note that that the earlier HUD classes/objects have been retained)
Newer objects may be instantiated using the above classes, Unless a totally
new object is required).

The Default as well as the Custom directory have the same (in terms of properties)
set of configuration files (but with different values to suit the aircraft).

We have a Base class - Hud Instrument Item.
We derive two more base classes - Instrument Scale and Dual Instrument Item from this.
(This implementation owes its existence to all those who wrote the HUD code for 0.6.1)

The Hud Instrument Label is an instantiable class derived from Hud Instrument Item -
for displaying alphanumeric labels (altitude, velocity, Mach no and/or anything else
as long you have a call back function to pass the value using the property
'data_source').

The Hud Card is an instantiable class derived from Instrument scale - for displaying
tapes and gauges (single variable display, for displaying aoa, g's, vsi,
elevator_posn, etc.).

The Hud Ladder is an instantiable class derived from Dual Instrument Item - for
displaying pitch reference ladder or climb/dive ladder (two variable display, for
displaying two types of ladders, the pitch reference ladder or the climb/dive ladder
as defined by MIL-1787b).

The fgTBI Instrument is an instantiable class derived from Dual Instrument scale
again - for display of Bank angle and Sideslip (two variable display, for display
of TSI info, kept different from the two variable ladder object basically because
of its totally different draw member function).

Most Hud instruments may be instantiated using above. It is proposed to provide all
Hud objects as defined in MIL-STD-1797A, soon.

Here is how you position 'any' object:

x ____________ x+width
  |          |
  |          |
y ------------ y+height

this defines the objects position centered about the centroid of above rectangle
in HUD overlay plane (640x480) coordinates with 0,0 at bottom-left corner.

One more, pixels per degree in the ladder class represents the compression factor of
the pitch ladder. In case of conformal HUD (climb/dive ladder) it is
<640/horizontal_fov> or <480/vertical_fov>. In case of pitch reference ladder it is
<your_no_of vertical_pixels/your_no_of_ladder_degrees>.

Example of Hud Ladder xml file.

<PropertyList>

 <ladders>

  <l1>
  <name>Pitch Ladder</name>     <!-- Name can be Pitch Ladder or Climb/Dive Ladder  -->
  <x>260</x>                    <!-- x start -->
  <y>150</y>                    <!-- y start -->
  <width>120</width>            <!-- x start + width = x end -->
  <height>180</height>          <!-- y start + height = y end -->
  <compression_factor>2.68</compression_factor>    <!-- Pixels per degree -->
  <loadfn>roll</loadfn>         <!-- Name of the function to be called, here
                                     get_roll() is called provision made in Hud.cxx -->
  <loadfn1>pitch</loadfn1>      <!-- Name of the function to be called, here get_pitch()
                                     is called -->
  <span_units>45.0</span_units>         <!-- Range of the Ladder seen at any instant -->
  <division_units>10.0</division_units> <!-- Divisions -->
  <screen_hole>70</screen_hole>         <!-- Hole b/w the Ladder Bars -->
  <lbl_pos>0</lbl_pos>                  <!-- Label Position to indicate pitch angle on bar -->
  <enable_frl>false</enable_frl>        <!-- To Enable Pitch Reference Symbol (used by us) -->
  <enable_target_spot>true</enable_target_spot>                <!-- To Enable Target Spot Symbol (fgfs uses this) -->
  <enable_velocity_vector>false</enable_velocity_vector>       <!-- To Enable Velocity Vector Symbol (use only with climb/dive ladder) -->
  <enable_drift_marker>false</enable_drift_marker>             <!-- To Enable Drift Marker Symbol (used by us) -->
  <enable_alpha_bracket>false</enable_alpha_bracket>           <!-- To Enable Alpha Bracket Symbol (used by us, presently hard coded bracket values, alpha values will be moved to xml file) -->
  <enable_energy_marker>false</enable_energy_marker>           <!-- To Enable Energy Marker Symbol (used by us) -->
  <enable_climb_dive_marker>false</enable_climb_dive_marker>   <!-- To Enable Climb/Dive Marker (used by us) -->
  <enable_glide_slope_marker>false</enable_glide_slope_marker> <!-- To Enable Glide/Slope Marker (tied to climb/dive ladder only) -->
  <glide_slope>0.0</glide_slope>                               <!-- Glide slope angle (specify the angle for drawing the reference bar) -->
  <enable_energy_worm>false</enable_energy_worm>               <!-- To Enable Energy worm (used by us) -->
  <enable_waypoint_marker>false</enable_waypoint_marker>       <!-- To Enable Way point Marker (bearing marker) -->
  <working>true</working>                                      <!-- use this to enable or disable whole object -->
  </l1>

 </ladders>

</PropertyList>

Before you read this, _____ this is tick_top        |                  |
                           |                        |                  |
                           |                        |__________________|
                           | this is cap_right,tick_left  cap_bottom    tick_right
                           |
                      _____| this is tick_bottom

Example of Hud Card xml file.

<PropertyList>

 <cards>

  <c1>
   <name>Gyrocompass</name>
   <x>220</x>
   <y>430</y>
   <width>200</width>
   <height>28</height>
   <loadfn>heading</loadfn>     <!-- Name of the function to be called, here get_Heading() is called -->
   <options>4</options>         <!--  Read Tape Options Below or Hud.hxx file for details -->
   <maxValue>360.0</maxValue>   <!-- Maximum scale value -->
   <minValue>0.0</minValue>     <!-- Minimum Scale Value -->
   <disp_scaling>1.0</disp_scaling> <!-- Multiply by this to get numbers shown on scale -->
   <major_divs>5</major_divs>       <!-- major division marker units -->
   <minor_divs>1</minor_divs>       <!-- minor division marker units -->
   <modulator>360</modulator>       <!-- Its a rose, Roll Over Point -->
   <value_span>25.0</value_span>    <!-- Range Shown  -->
   <type>tape</type>                <!-- Card type can be "tape" or "gauge" -->
   <tick_bottom>false</tick_bottom> <!-- Read Ticks and Caps below -->
   <tick_top>false</tick_top>
   <tick_right>true</tick_right>
   <tick_left>true</tick_left>
   <cap_bottom>true</cap_bottom>
   <cap_top>false</cap_top>
   <cap_right>false</cap_right>
   <cap_left>false</cap_left>
   <marker_offset>0.0</marker_offset>    <!-- Read Marker offset below -->
   <enable_pointer>true</enable_pointer> <!-- To draw a pointer -->
   <pointer_type>fixed</pointer_type>    <!-- Type of pointer, Fixed or Moving (yet to be implemented) -->
   <working>true</working>
  </c1>

 </cards>

</PropertyList>

Tape Options:

HUDS_AUTOTICKS    =     0x0001
HUDS_VERT         =     0x0002
HUDS_HORZ         =     0x0000
HUDS_TOP          =     0x0004
HUDS_BOTTOM       =     0x0008
HUDS_LEFT         =     HUDS_TOP
HUDS_RIGHT        =     HUDS_BOTTOM
HUDS_BOTH         =     (HUDS_LEFT | HUDS_RIGHT)
HUDS_NOTICKS      =     0x0010
HUDS_ARITHTIC     =     0x0020
HUDS_DECITICS     =     0x0040
HUDS_NOTEXT       =     0x0080
HUDS_LEFT | HUDS_VERT   = 0x0006
HUDS_RIGHT | HUDS_VERT  = 0x0010
HUDS_TOP | HUDS_NOTEXT  = 0x0084
HUDS_BOTTOM | HUDS_NOTEXT = 0x0088
HUDS_VERT | HUDS_LEFT | HUDS_NOTEXT  = 0x0086
HUDS_RIGHT | HUDS_VERT | HUDS_NOTEXT = 0x0090


For clarity, I repeat, Ticks and Caps :


1. Left Tick ->|_____|<- Right Tick
                  |
                  v
             Bottom Cap

2.    Top Cap
         |
         v
       _____
      |     |


3.    Top Tick
         |
         v
        ---
           |
           |<- Right Cap
           |
        ---
         |
         v
       Bottom Tick

4.            ---
              |
  Left Cap -> |
              |
              ---

Marker Offset :

To Draw pointer on the scale markings. In the case of a our hud with offset 10.0
The pointer is away from the scale and points at the markings.

        -|                      -
        -|                      -
        <|                      -<
        -|                      -
        -|                      -
Marker offset = 0.0     Marker offset = 10.0

This should be useful when I implement the fixed tape/moving pointer.


Example of a Label xml file.

<PropertyList>

 <labels>

  <i1>
   <name>machno</name>
   <x>25</x>
   <y>130</y>
   <width>40</width>
   <height>30</height>
   <data_source>mach</data_source>    <!-- Name of the function to be called, here get_Heading() is called -->
   <label_format>%4.2f</label_format> <!-- The Label Format -->
   <pre_label_string>blank</pre_label_string>  <!-- String to be written Pre Label -->
   <post_label_string>NULL</post_label_string> <!-- String to be written Post Label -->
   <scale_data>1.0</scale_data>
   <options>4</options>               <!-- Read Tape options or Hud.hxx -->
   <justification>2</justification>   <!-- Justify the label, 0=LEFT_JUSTIFY, 1=CENTER_JUSTIFY, 2=RIGHT_JUSTIFY -->
   <blinking>0</blinking>             <!-- Yet to be implemented -->
   <working>true</working>
   <latitude>false</latitude>         <!-- True if the label is to display Latitude (special label, displays deg.min.sec) -->
   <longitude>false</longitude>       <!-- True if the label is to display Longitude (special label, displays deg.min.sec) -->
  </i1>

 </labels>

</PropertyList>


Example of a Turn Bank Indicator xml file.

<PropertyList>

 <tbis>

  <f1>
  <name>fgTBI_Instrument</name>
  <x>290</x>
  <y>45</y>
  <width>60</width>
  <height>10</height>
  <loadfn>roll</loadfn>       <!-- Name of the function to be called, get_roll() is called here. -->
  <loadfn1>sideslip</loadfn1> <!-- Name of the function to be called, get_sideslip() is called here. -->
  <maxBankAngle>45.0</maxBankAngle> <!-- Maximum Angle of Bank -->
  <maxSlipAngle>5.0</maxSlipAngle>  <!-- Maximum Angle of Slip -->
  <gap_width>5</gap_width>          <!-- Screen Hole -->
  <working>true</working>
  </f1>

 </tbis>

</PropertyList>

I have still got to implement dials (as in MIL-STD-1787b).

REMEMBER IF YOU NEED TO INDICATE ANY OTHER PARAMETER ON THE HUD OTHER THAN WHAT IS PROVIDED AS
CALLBACK FUNCTIONS (PROPERTY NAMES LISTED BELOW) YOU HAVE TO FIDDLE WITH THE CODE, AS YET. LET ME
KNOW AND I SHALL INCLUDE THAT.

<loadfn>anzg</loadfn>             <!-- Here get_anzg() is called -->
<loadfn>heading</loadfn>          <!-- Here get_heading() is called -->
<loadfn>aoa</loadfn>              <!-- Here get_aoa() is called -->
<loadfn>climb</loadfn>            <!-- Here get_climb() is called -->
<loadfn>altitude</loadfn>         <!-- Here get_altitude() is called -->
<loadfn>agl</loadfn>              <!-- Here get_agl() is called -->
<loadfn>speed</loadfn>            <!-- Here get_speed() is called -->
<loadfn>view_direction</loadfn>   <!-- Here get_view_direction() is called -->
<loadfn>aileronval</loadfn>       <!-- Here get_aileronval() is called -->
<loadfn>elevatorval</loadfn>      <!-- Here get_elevatorval() is called -->
<loadfn>rudderval</loadfn>        <!-- Here get_rudderval() is called -->
<loadfn>throttleval</loadfn>      <!-- Here get_throttleval() is called -->
<loadfn>aux16</loadfn>            <!-- Here get_aux16() is called -->
<loadfn>aux17</loadfn>            <!-- Here get_aux17() is called -->
<loadfn>aux9</loadfn>             <!-- Here get_aux9() is called -->
<loadfn>aux11</loadfn>            <!-- Here get_aux11() is called -->
<loadfn>aux12</loadfn>            <!-- Here get_aux12() is called -->
<loadfn>aux10</loadfn>            <!-- Here get_aux10() is called -->
<loadfn>aux13</loadfn>            <!-- Here get_aux13() is called -->
<loadfn>aux14</loadfn>            <!-- Here get_aux14() is called -->
<loadfn>aux15</loadfn>            <!-- Here get_aux15() is called -->
<loadfn>aux8</loadfn>             <!-- Here get_aux8() is called -->
<loadfn>ax</loadfn>               <!-- Here get_Ax() is called -->
<loadfn>mach</loadfn>             <!-- Here get_mach() is called -->
<loadfn>framerate</loadfn>        <!-- Here get_frame_rate() is called -->
<loadfn>fov</loadfn>              <!-- Here get_fov() is called -->
<loadfn>vfc_tris_culled</loadfn>  <!-- Here get_vfc_tris_culled() is called -->
<loadfn>vfc_tris_drawn</loadfn>   <!-- Here get_vfc_tris_drawn() is called -->
<loadfn>latitude</loadfn>         <!-- Here get_latitude() is called -->
<loadfn>longitude</loadfn>        <!-- Here get_longitude() is called -->













--- End of README.xmlhud ---


--- Start of README.xmlpanel ---

Users Guide to FlightGear panel configuration
Version 0.7.7, May 16 2001
Author: John Check <j4strngs@rockfish.net>

This document is an attempt to describe the configuration of
FlightGear flight simulator's aircraft panel display via XML.  The
information was culled from the fgfs-devel@flightgear.org mailing list
and my experiences making alternate panels.  Corrections and additions
are encouraged.

Some History:
------------
Older versions of FGFS had a hard coded display of instruments.  This
was a less than ideal state of affairs due to FGFS ability to use
different aircraft models. Being primarily developed on UNIX type
systems, a modular approach is taken towards the simulation. To date,
most alternatives to the default Cessna 172 aircraft are the product
of research institutions interested in the flight characteristics and
not cosmetics.  The result of this was that one could fly the X-15 or
a Boeing 747 but be limited to C172 instrumentation.

A rewrite of the panel display code was done around v0.7.5 by
developer David Megginson allowing for configuration of the panel via
XML to address this limitation. Some major changes and additions were
made during the course of version 0.7.7 necessitating a rewrite and
expansion of this document.


About The Property Manager:
--------------------------
While not absolutely necessary in order to create aircraft panels,
some familiarity with the property manager is beneficial....
FlightGear provides a hierarchical representation of all aspects of
the state of the running simulation that is known as the property
tree.  Some properties, such as velocities are read only. Others such
as the frequencies to which the navcom radios are tuned or the
position of control surfaces can be set by various means.  FlightGear
can optionally provide an interface to these properties for external
applications such as Atlas, the moving map program, or even lowly
telnet, via a network socket. Data can even be placed on a serial port
and connected to, say a GPS receiver.  Aside from its usefulness in a
flight training context, being able to manipulate the property tree on
a running copy of FG allows for switching components on the fly, a
positive boon for panel authors.  To see the property tree start FG
with the following command line:

fgfs --props=socket,bi,5,localhost,5500,tcp

Then use telnet to connect to localhost on port 5500. You can browse
the tree as you would a filesystem.

XML and the Property Manager:
----------------------------
Panel instruments interface with the property tree to get/set values
as appropriate. Properties for which FG doesn't yet provide a value
can be created by simply making them up. Values can be adjusted using
the telnet interface allowing for creation and testing of instruments
while code to drive them is being developed.

If fact, the XML configuration system allows a user to combine
components such as flight data model, aircraft exterior model, heads
up display, and of course control panel. Furthermore, such a
preconfigured aircraft.xml can be included into a scenario with
specific flight conditions. These can be manually specified or a FG
session can be saved and/or edited and reloaded later. Options
specified in these files can be overridden on the command line. For
example:

--prop:/sim/panel/path=Aircraft/c172/Panels/c172-panel.xml

passed as an option, would override a panel specified elsewhere.
Property tree options all have the same format, specify the node and
supply it a value.

The order of precedence for options is thus:

Source          Location                Format
------          --------                ------
command line
.fgfsrc         Users home directory.   command line options
system.fgfsrc   $FG_ROOT                ""      ""
preferences.xml $FG_ROOT                XML property list


Loading Panels on the fly:
-------------------------
When editing a panel configuration, pressing Shift +F3 will reload the
panel. If your changes don't seem to be taking effect, check the
console output.  It will report the success or failure of the panel
reload*. Editing textures requires restarting FGFS so the new textures
can be loaded. Panels can be switched on the fly by setting the
/sim/panel/path property value and reloading.

Regarding Window Geometry:
-------------------------
For the sake of simplicity the FGFS window is always considered to be
1024x768 so all x/y values for instrument placement should relative to
these dimensions.  Since FG uses OpenGL 0,0 represents the lower left
hand corner of the screen. Panels may have a virtual size larger than
1024x768. Vertical scrolling is accomplished with
Shift+F5/F6. Horizontal scrolling is via Shift+F7/F8. An offset should
be supplied to set the default visible area. It is possible to place
items to overlap the 3D viewport.

Panel Architecture:
-------------------
All of the panel configuration files are XML-encoded* property lists.
The root element of each file is always named <PropertyList>. Tags are
almost always found in pairs, with the closing tag having a slash
prefixing the tag name, i.e </PropertyList>. The exception is the tag
representing an aliased property. In this case a slash is prepended to
the closing angle bracket.  (see section Aliasing)

The top level panel configuration file is composed of a <name>, a
<background> texture and zero or more <instruments>.Earlier versions
required instruments to have a unique name and a path specification
pointing to the instruments configuration file.

[ Paths are relative to $FG_ROOT (the installed location of FGFS data files.) ]
[ Absolute paths may be used.Comments are bracketed with <!-- -->.            ]

Old style instrument call in top level panel.xml:
------------------------------------------------
  <clock>         <!-- required "unique_name" -->
   <path>Aircraft/c172/Instruments/clock.xml</path>
   <x>110</x>     <!-- required horizontal placement -->
   <y>320</y>     <!-- required vertical placement -->
   <w>72</w>      <!-- optional width specification -->
   <h>72</h>      <!-- optional height specification -->
  </clock>

The difference between the old and new styles, while subtle, is rather
drastic.  The old and new methods are indeed incompatible. I cover the
old style only to acknowledge the incompatibility. This section will
be removed after the next official FGFS release.

New Style Example Top Level Panel Config:
----------------------------------------
<PropertyList>
 <name>Example Panel</name>
 <background>Aircraft/c172/Panels/Textures/panel-bg.rgb</background>
 <w>1024</w>                      <!-- virtual width -->
 <h>768</h>                       <!-- virtual height -->
 <y-offset>-305</y-offset>        <!-- hides the bottom part -->
 <view-height>172</view-height>   <!-- amount of overlap between 2D panel
                                       and 3D viewport -->

 <instruments>                    <!-- from here down is where old and new
                                       styles break compatibility -->

  <instrument include="../Instruments/clock.xml">
   <name>Chronometer</name>   <!-- currently optional but strongly recommended -->
   <x>150</x>                 <!-- required horizontal placement -->
   <y>645</y>                 <!-- required vertical placement -->
   <w>72</w>                  <!-- optional width specification -->
   <h>72</h>                  <!-- optional height specification -->
  </instrument>

 </instruments>

</PropertyList>


Indexed Properties
------------------
This is a lot to do with the compatibility break so lets get it out of
the way.  The property manager now assigns incremental indices to
repeated properties with the same parent node, so that

 <PropertyList>
 <x>1</x>
 <x>2</x>
 <x>3</x>
 </PropertyList>

shows up as

 /x[0] = 1
 /x[1] = 2
 /x[2] = 3

This means that property files no longer need to make up a separate
name for each item in a list of instruments, layers, actions,
transformations, or text chunks. In fact, the new panel I/O code now
insists that every instrument have the XML element name "instrument",
every layer have the name "layer", every text chunk have the name
"chunk", every action have the name "action", and every transformation
have the name "transformation" -- this makes the XML more regular (so
that it can be created in a DTD-driven tool) and also allows us to
include other kinds of information (such as doc strings) in the lists
without causing confusion.

Inclusion:
----------
The property manager now supports file inclusion and aliasing.
Inclusion means that a node can include another property file as if it
were a part of the current file.  To clarify how inclusion works,
consider the following examples:

If bar.xml contains

 <PropertyList>
 <a>1</a>
 <b>
 <c>2</c>
 </b>
 </PropertyList>

then the declaration

 <foo include="../bar.xml">
 </foo>

is exactly equivalent to

 <foo>
 <a>1</a>
 <b>
 <c>2</c>
 </b>
 </foo>

However, it is also possible to selectively override properties in the
included file. For example, if the declaration were

 <foo include="../bar.xml">
 <a>3</a>
 </foo>

then the property manager would see

 <foo>
 <a>3</a>
 <b>
 <c>2</c>
 </b>
 </foo>

with the original 'a' property's value replaced with 3.

This new inclusion feature allows property files to be broken up and
reused arbitrarily -- for example, there might be separate cropping
property lists for commonly-used textures or layers, to avoid
repeating the information in each instrument file.


Aliasing
--------
Properties can now alias other properties, similar to a symbolic link
in Unix. When the target property changes value, the new value will
show up in the aliased property as well. For example,

 <PropertyList>
 <foo>3</foo>
 <bar alias="/foo"/>
 </PropertyList>

will look the same to the application as

 <PropertyList>
 <foo>3</foo>
 <bar>3</bar>
 </PropertyList>

except that when foo changes value, bar will change too.


The combination of inclusions and aliases is very powerful, because it
allows for parameterized property files. For example, the XML file for
the NAVCOM radio can include a parameter subtree at the start, like
this:

 <PropertyList>
 <params>
 <comm-freq-prop>/radios/comm1/frequencies/selected</comm-freq-prop>
 <nav-freq-prop>/radios/nav1/frequencies/selected</comm-freq-prop>
 </params>

 ...

 <chunk>
 <type>number-value</type>
 <property alias="/params/nav-freq-prop"/>
 </chunk>

 ...
 </PropertyList>

Now, the same instrument file can be used for navcomm1 and navcomm2,
for example, simply by overriding the parameters at inclusion:

 <instrument include="../Instruments/navcomm.xml">
 <params>
 <comm-freq-prop>/radios/comm1/frequencies/selected</comm-freq-prop>
 <nav-freq-prop>/radios/nav1/frequencies/selected</comm-freq-prop>
 </params>
 </instrument>

 <instrument include="../Instruments/navcomm.xml">
 <params>
 <comm-freq-prop>/radios/comm2/frequencies/selected</comm-freq-prop>
 <nav-freq-prop>/radios/nav2/frequencies/selected</comm-freq-prop>
 </params>
 </instrument>

Instrument Architecture:
-----------------------
Instruments are defined in separate configuration files. An instrument
consists of a base width and height, one or more stacked layers, and
zero or more actions. Base dimensions are specified as follows:

<PropertyList>                   <!-- remember, all xml files start like this -->
 <name>Airspeed Indicator</name> <!-- names are good -->
 <w-base>128</w-base>            <!-- required width spec-->
 <h-base>128</h-base>            <!-- required height spec-->
  <layers>                       <!-- begins layers section -->

Height and width can be overriden in the top level panel.xml by
specifying <w> and <h>. Transformations are caculated against the base
size regardless of the display size. This ensures that instruments
remain calibrated

Textures:
--------
FG uses red/green/blue/alpha .rgba files for textures. Dimensions for
texture files should be power of 2 with a maximum 8:1 aspect ratio.
The lowest common denominator for maximum texture size is 256 pixels.
This is due to the limitations of certain video accelerators, most
notably those with 3Dfx chipset such as the Voodoo2.

Instrument Layers**:
-------------------
The simplest layer is a <texture>. These can be combined in <switch> layers

<texture>
A texture layer looks like this:

  <layer>                      <!-- creates a layer -->
   <name>face</name>
   <texture>                   <!-- defines it as a texture layer -->
    <path>Aircraft/c172/Instruments/Textures/faces-2.rgb</path>
    <x1>0</x1>                 <!-- lower boundary for texture cropping-->
    <y1>0.51</y1>              <!-- left boundary  for texture cropping-->
    <x2>0.49</x2>              <!-- upper boundary  for texture cropping-->
    <y2>1.0</y2>               <!-- right boundary  for texture cropping-->
   </texture>                  <!-- closing texure tag -->
  </layer>                     <!-- closing layer tag -->

The texture cropping specification is represented as a decimal. There
is a table at the end of this document for converting from pixel
coordinates to percentages.

This particular layer, being a gauge face has no transformations
applied to it.  Layers with that aren't static *must* include <w> and
<h> parameters to be visible.

<type> May be either text or switch..

<type>switch</type>
A switch layer is composed of two or more nested layers and will
display one of the nested layers based on a boolean property. For a
simple example of a switch see
$FG_ROOT/Aircraft/c172/Instruments/brake.xml.

  <layer>
   <name>Brake light</name>
   <type>switch</type>                    <!-- define layer as a switch -->
   <property>/controls/brakes</property>  <!-- tie it to a property -->
    <layer1>                              <!-- layer for true state -->
     <name>on</name>                      <!-- label to make life easy -->
     <texture>                            <!-- layer1 of switch is a texture layer -->
     <path>Aircraft/c172/Instruments/Textures/brake.rgb</path>
     <x1>0.25</x1>
     <y1>0.0</y1>
     <x2>0.5</x2>
     <y2>0.095</y2>
     </texture>
     <w>64</w>                          <!-- required width - layer isn't static -->
     <h>24</h>                          <!-- required height - layer isn't static -->
    </layer1>                           <!-- close layer1 of switch -->
    <layer2>                            <!-- layer for false state -->
     <name>off</name>
     <texture>
     <path>Aircraft/c172/Instruments/Textures/brake.rgb</path>
     <x1>0.0</x1>
     <y1>0.0</y1>
     <x2>0.25</x2>
     <y2>0.095</y2>
     </texture>
     <w>64</w>
     <h>24</h>
   </layer2>
  </layer>

Switches can have more than 2 states. This requires nesting one switch
inside another.  One could make, for example, a 3 color LED by nesting
switch layers.

<type>text</type>
A text layer may be static, as in a label, generated from a property
or a combination of both.  This example is a switch that contains both
static and dynamic text:

 <layer1>                         <!-- switch layer -->
  <name>display</name>
  <type>text</type>               <!-- type == text -->
  <point-size>12</point-size>     <!-- font size -->
  <color>                         <!-- specify rgb values to color text -->
   <red>1.0</red>
   <green>0.5</green>
   <blue>0.0</blue>
  </color>                        <!-- close color section -->
  <chunks>                        <!-- sections of text are referred to as chunks -->
   <chunk>                        <!-- first chunk of text -->
    <type>number-value</type>     <!-- value defines it as dynamic -->
    <property>/radios/nav1/dme/distance</property>    <!-- ties it to a property -->
    <scale>0.00053995680</scale>  <!-- convert between statute and nautical miles? -->
    <format>%5.1f</format>        <!-- define format -->
   </chunk>
  </chunks>
 </layer1>
 <layer2>                         <!-- switch layer -->
  <name>display</name>
  <type>text</type>               <!-- type == text -->
  <point-size>10</point-size>     <!-- font size -->
  <color>                         <!-- specify rgb values to color text -->
   <red>1.0</red>
   <green>0.5</green>
   <blue>0.0</blue>
  </color>                        <!-- close color section -->
  <chunks>                        <!-- sections of text are referred to as chunks -->
   <chunk>                        <!-- first chunk of text -->
    <type>literal</type>          <!-- static text -->
    <text>---.--</text>           <!-- fixed value -->
   </chunk>
  </chunks>
 </layer2>


Transformations:
---------------
A transformation is a rotation, an x-shift, or a
y-shift. Transformations can be static or they can be based on
properties. Static rotations are useful for flipping textures
horizontally or vertically. Transformations based on properties are
useful for driving instrument needles. I.E. rotate the number of
degrees equal to the airspeed. X and y shifts are relative to the
center of the instrument. Each specified transformation type takes an
<offset>.  Offsets are relative to the center of the instrument. A
shift without an offset has no effect. For example, let's say we have
a texure that is a circle. If we use this texture in two layers, one
defined as having a size of 128x128 and the second layer is defined as
64x64 and neither is supplied a shift and offset the net result
appears as 2 concentric circles.


About Transformations and Needle Placement:
------------------------------------------

When describing placement of instrument needles, a transformation
offset must be applied to shift the needles fulcrum or else the needle
will rotate around it's middle. The offset will be of <type> x-shift
or y-shift depending on the orientation of the needle section in the
cropped texture.

This example comes from the altimeter.xml

  <layer>
   <name>long needle (hundreds)</name>  <!-- the altimeter has more than one needle -->
   <texture>
    <path>Aircraft/c172/Instruments/Textures/misc-1.rgb</path>
    <x1>0.8</x1>
    <y1>0.78125</y1>
    <x2>0.8375</x2>
    <y2>1.0</y2>
   </texture>
   <w>8</w>
   <h>56</h>
   <transformations>                    <!-- begin defining transformations -->
    <transformation>                    <!-- start definition of
                                             transformation that drives the needle -->
     <type>rotation</type>
     <property>/steam/altitude</property>  <!-- bind it to a property -->
     <max>100000.0</max>                <!-- upper limit of instrument -->
     <scale>0.36</scale>                <!-- once around == 1000 ft -->
    </transformation>                   <!-- close this transformation -->
    <transformation>                    <!-- shift the fulcrum of the needle -->
     <type>y-shift</type>               <!-- y-shift relative to needle -->
     <offset>24.0</offset>              <!-- amount of shift -->
    </transformation>
   </transformations>
  </layer>

This needles has its origin in the center of the instrument. If the
needles fulcrum was towards the edge of the instrument, the
transformations to place the pivot point must precede those which
drive the needle,

Interpolation
-------------
Non linear transformations are now possible via the use of
interpolation tables.

 <transformation>
 ...
 <interpolation>
 <entry>
 <ind>0.0</ind>            <!-- raw value -->
 <dep>0.0</dep>            <!-- displayed value -->
 </entry>
 <entry>
 <ind>10.0</ind>
 <dep>100.0</dep>
 </entry>
 <entry>
 <ind>20.0</ind>
 <dep>-5.0</dep>
 </entry>
 <entry>
 <ind>30.0</ind>
 <dep>1000.0</dep>
 </entry>
 </interpolation>
 </transformation>

Of course, interpolation tables are useful for non-linear stuff, as in
the above example, but I kind-of like the idea of using them for
pretty much everything, including non-trivial linear movement -- many
instrument markings aren't evenly spaced, and the interpolation tables
are much nicer than the older min/max/scale/offset stuff and should
allow for a more realistic panel without adding a full equation parser
to the property manager.

If you want to try this out, look at the airspeed.xml file in the base
package, and uncomment the interpolation table in it for a very funky,
non-linear and totally unreliable airspeed indicator.


Actions:
-------
An action is a hotspot on an instrument where something will happen
when the user clicks the left or center mouse button.  Actions are
always tied to properties: they can toggle a boolean property, adjust
the value of a numeric property, or swap the values of two properties.
The x/y placement for actions specifies the origin of the lower left
corner.  In the following example the first action sets up a hotspot
32 pixels wide and 16 pixels high. It lower left corner is placed 96
pixels (relative to the defined base size of the instrument) to the
right of the center of the instrument. It is also 32 pixels below the
centerline of the instrument.  The actual knob texture over which the
action is superimposed is 32x32.  Omitted here is a second action,
bound to the same property, with a positive increment value. This
second action is placed to cover the other half of the knob. The
result is that clicking on the left half of the knob texture decreases
the value and clicking the right half increases the value. Also
omitted here is a second pair of actions with the same coordinates but
a larger increment value. This second pair is bound to a different
mouse button. The net result is that we have both fine and coarse
adjustments in the same hotspot, each bound to a different mouse
button.

These examples come from the radio stack:
<actions>                              <!-- open the actions section -->
  <action>                             <!- first action -->
   <name>small nav frequency decrease</name>
   <type>adjust</type>
   <button>0</button>                  <!-- bind it to a mouse button -->
   <x>96</x>                           <!-- placement relative to instrument center -->
   <y>-32</y>
   <w>16</w>                           <!-- size of hotspot -->
   <h>32</h>
   <property>/radios/nav1/frequencies/standby</property>    <!-- bind to a property -->
   <increment>-0.05</increment>        <!-- amount of adjustment per mouse click -->
   <min>108.0</min>                    <!-- lower range -->
   <max>117.95</max>                   <!-- upper range -->
   <wrap>1</wrap>                      <!-- value wraps around when it hits bounds -->
  </action>
  <action>
   <name>swap nav frequencies</name>
   <type>swap</type>                   <!-- define type of action -->
   <button>0</button>
   <x>48</x>
   <y>-32</y>
   <w>32</w>
   <h>32</h>
   <property1>/radios/nav1/frequencies/selected</property1>   <!-- properties to
   <property2>/radios/nav1/frequencies/standby</property2>         toggle between -->
  </action>
  <action>
   <name>ident volume on/off</name>
   <type>adjust</type>
   <button>1</button>
   <x>40</x>
   <y>-24</y>
   <w>16</w>
   <h>16</h>
   <property>/radios/nav1/ident</property>  <!-- Morse code ID of nav beacons -->
   <increment>1.0</increment>          <!-- the increment equals the max value
                                            so this toggles on/off -->
   <min>0</min>
   <max>1</max>
   <wrap>1</wrap>                      <!-- a shortcut to avoid having separate
                                            actions for on/off -->
  </action>
</actions>

More About Textures:
-------------------
As previously stated, the usual size instrument texture files in FGFS
are 256x256 pixels, red/green/blue/alpha format. However the mechanism
for specifying texture cropping coordinates is decimal in nature. When
calling a section of a texture file the 0,0 lower left convention is
used.  There is a pair of x/y coordinates defining which section of
the texture to use.

The following table can be used to calculate texture cropping
specifications.

# of divisions | width in pixels | decimal specification
per axis
        1   =   256 pixels              1
        2   =   128 pixels,             0.5
        4   =   64 pixels,              0.25
        8   =   32 pixels,              0.125
        16  =   16 pixels,              0.0625
        32  =   8 pixels,               0.03125
        64  =   4 pixels,               0.015625
        128 =   2 pixels,               0.0078125

A common procedure for generating gauge faces is to use a vector
graphics package such as xfig, exporting the result as a postscript
file. 3D modeling tools may also be used and I prefer them for pretty
items such as levers, switches, bezels and so forth.  Ideally, the
size of the item in the final render should be of proportions that fit
into the recommended pixel widths.  The resulting files can be
imported into a graphics manipulation package such as GIMP, et al for
final processing.

How do I get my panels/instruments into the base package?
-------------------------------------------------------
Cash bribes always help ;) Seriously though, there are two main
considerations.  Firstly, original artwork is a major plus since you
as the creator can dictate the terms of distribution.  All Artwork must
have a license compatible with the GPL.  Artwork of unverifiable
origin is not acceptable.  Secondly, texture sizes must meet the
lowest common denominator of 256e2 pixels.  Artwork from third parties
may be acceptable if it meets these criteria.

*  If there are *any* XML parsing errors, the panel will fail to load,
   so it's worth downloading a parser like Expat (http://www.jclark.com/xml/)
   for checking your XML. FlightGear will print the location of errors, but
   the messages are a little cryptic right now.

** NOTE: There is one built-in layer -- for the mag compass ribbon --
   and all other layers are defined in the XML files.  In the future,
   there may also be built-in layers for special things like a
   weather-radar display or a GPS (though the GPS could be handled with
   text properties).


--- End of README.xmlpanel ---


--- Start of README.xmlpanel.html ---

<HTML><HEAD><TITLE>Users Guide to FlightGear panel configuration</TITLE></HEAD>
<BODY>
<H1>Users Guide to FlightGear panel configuration</H1>

<CITE>
Version 0.7.7.2, July 24 2001
Author: John Check
</CITE>

<ol>
 <li><A HREF="#history">Some History</A></li>
 <li><A HREF="#property_manager">About The Property Manager</A></li>
 <li><A HREF="#xml">XML and The Property Manager</A></li>
 <li><A HREF="#load_panel">Loading Panels</A></li>
 <li><A HREF="#window_geometry">Regarding Window Geometry</A></li>
 <li><A HREF="#panel_architecture">Panel Architecture</A></li>
 <li><A HREF="#example_panel">Example Top Level Panel Config</A></li>
 <li><A HREF="#indexed_properties">Indexed Properties</A></li>
 <li><A HREF="#inclusion">Inclusion</A></li>
 <li><A HREF="#instrument_architecture">Instrument Architecture</A></li>
 <li><A HREF="#textures">Textures</A></li>
 <li><A HREF="#instrument_layers">Instrument Layers</A></li>
 <li><A HREF="#transformations">Transformations</a></li>
 <li><A HREF="#conditions">Conditions</A></li>
 <li><A HREF="#needle_placement">About Transformations and Needle Placement</A></li>
 <li><A HREF="#interpolation">Interpolation Tables</A></li>
 <li><A HREF="#actions">Actions</A></li>
 <li><A HREF="#more_texture">More About Textures</A></li>
 <li><A HREF="#generating_textures">Generating Textures</A></li>
 <li><A HREF="#contribute">Contributing Panels</A></li>
 <li><A HREF="#units">Units</A></li>
</ol> 

<P>
This document describes the configuration of
FlightGear flight simulator's aircraft panel display via XML.
The information was culled from the fgfs-devel@flightgear.org
mailing list and my experiences making alternate panels.
Corrections and additions are encouraged.
</P>



<HR WIDTH="20%">
<H2><A NAME="history">Some History:</A></H2>
<HR WIDTH="20%">
<p>
Older versions of FGFS had a hard coded display of instruments.
This was a less than ideal state of affairs due to FGFS ability
to use different aircraft models. Being primarily developed on
UNIX type systems, a modular approach is taken towards the
simulation. To date, most alternatives to the default
Cessna 172 aircraft are the product of research institutions
interested in the flight characteristics and not cosmetics.
The result of this was that one could fly the X-15 or a Boeing 747
but be limited to C172 instrumentation.
</P>
<P>
A rewrite of the panel display code was done around v0.7.5 by
developer David Megginson allowing for configuration of the panel
via XML to address this limitation. Some major changes and additions
were made during the course of version 0.7.7 necessitating a rewrite
and expansion of this document.
</P>


<HR WIDTH="20%">
<H2><A NAME="property_manager">About The Property Manager:</A></H2>
<HR WIDTH="20%">
<p>
While intimate knowledge of the property manager is unnecessary to create 
aircraft panels, some familiarity with the concept is required.
FlightGear provides a hierarchical representation of all aspects of
the state of the running simulation that is known as the property tree.
Some properties, such as velocities, are read only. Others such as the frequencies to which the navcom radios are tuned or the position of control surfaces
can be set by various means.
</P>
<P>
FlightGear can optionally provide an interface to these properties for external
applications such as Atlas, the moving map program, or even lowly telnet via
a network socket. Data can even be routed to a serial port and connected to
say, a GPS receiver.
Aside from its usefulness in a flight training context, being able to manipulate
the property tree on a running copy of FG allows for switching components on the fly,
a positive boon for panel authors.
To see the property tree start FG with the following command line:
</P>

<PRE>
fgfs --props=socket,bi,5,localhost,5500,tcp
</PRE>
<br>

<P>
Then use telnet to connect to localhost on port 5500. You can browse the
tree as you would a filesystem.
</P>

<HR WIDTH="20%">
<H2><A NAME="xml">XML And The Property Manager:</A></H2>
<HR WIDTH="20%">
<p>
Panel instruments interface with the property tree to get/set values as
appropriate. Properties for which FG doesn't yet provide a value can be
created by simply making them up. Values can be adjusted using the telnet
interface allowing for creation and testing of instruments while code to
drive them is being developed.
</P>
<P>
If fact, the XML configuration system allows a user to combine
components such as flight data model, aircraft exterior model,
heads up display, and of course control panel. Furthermore,
such a preconfigured aircraft.xml can be included into a scenario
with specific flight conditions. These can be manually specified or
a FG session can be saved and/or edited and reloaded later. Options specified
in these files can be overridden on the command line. For example:
</P>

<PRE>
--prop:/sim/panel/path=Aircraft/c172/Panels/c172-panel.xml
</PRE>
<br>

<P>
passed as an option, would override a panel specified elsewhere.
Property tree options all have the same format, specify the node
and supply it a value.
</P>
<p>
The order of precedence for options is thus:
</p>

<pre>
Source           Location      Format
------           --------      ------
command line
.fgfsrc          ~/           command line options
system.fgfsrc    $FG_ROOT     ""      ""
preferences.xml  $FG_ROOT     XML property list
</pre>
<br>



<HR WIDTH="20%">
<H2><A NAME="load_panel">Loading Panels on the fly:</A></H2>
<HR WIDTH="20%">
<p>
When editing a panel configuration, pressing Shift +F3 will reload the
panel. If your changes don't seem to be taking effect, check the console output.
It will report the success or failure of the panel reload*. Editing textures requires
restarting FGFS so the new textures can be loaded. Panels can be switched on the fly
by setting the /sim/panel/path property value and reloading.
</P>



<HR WIDTH="20%">
<H2><A NAME="window_geometry">Regarding Window Geometry:</A></H2>
<HR WIDTH="20%">
<p>
For the sake of simplicity the FGFS window is always considered to be 1024x768
so all x/y values for instrument placement should relative to these dimensions.
Since FG uses OpenGL 0,0 represents the lower left hand corner of the
screen. Panels may have a virtual size larger than 1024x768. Vertical scrolling is accomplished
with Shift+F5/F6. Horizontal scrolling is via Shift+F7/F8. An offset should be supplied
to set the default visible area. It is possible to place items to overlap the 3D viewport.
</p>

<HR WIDTH="20%">
<H2><A NAME="panel_architecture">Panel Architecture:</A></H2>
<HR WIDTH="20%">
<p>
All of the panel configuration files are XML-encoded* property lists.
The root element of each file is always named &lt;PropertyList&gt;. Tags are
almost always found in pairs, with the closing tag having a slash prefixing
the tag name, i.e &lt;/PropertyList&gt;. The exception is the tag representing an aliased
property. In this case a slash is prepended to the closing angle bracket.
(see section Aliasing)
Properties must have units specified where appropriate. See section "Units"
at the end of this doc.
</P>
<P>
The top level panel configuration file is composed of a &lt;name&gt;, a &lt;background&gt;
texture and zero or more &lt;instruments&gt;.
</P>
<p>
[ Paths are relative to $FG_ROOT ( the installed location of FGFS data files ). ]<br>
[ Absolute paths may be used. Comments are bracketed with &lt;!-- --&gt;.       ]
</p>
<HR WIDTH="20%">
<H2><A NAME="example_panel">Example Top Level Panel Config:</A></H2>
<HR WIDTH="20%">
<p>
<PRE>
&lt;PropertyList&gt;
 &lt;name&gt;Example Panel&lt;/name&gt;
 &lt;background&gt;Aircraft/c172/Panels/Textures/panel-bg.rgb&lt;/background&gt;
 &lt;w&gt;1024&lt;/w&gt;                      &lt;!-- virtual width --&gt;
 &lt;h&gt;768&lt;/h&gt;                       &lt;!-- virtual height --&gt;
 &lt;y-offset&gt;-305&lt;/y-offset&gt;        &lt;!-- hides the bottom part --&gt;
 &lt;view-height&gt;172&lt;/view-height&gt;   &lt;!-- amount of overlap between 2D panel and 3D viewport --&gt;

 &lt;instruments&gt; 

  &lt;instrument include="../Instruments/clock.xml"&gt;
   &lt;name&gt;Chronometer&lt;/name&gt;   &lt;!-- currently optional but strongly recommended --&gt;
   &lt;x&gt;150&lt;/x&gt;                 &lt;!-- required horizontal placement --&gt;
   &lt;y&gt;645&lt;/y&gt;                 &lt;!-- required vertical placement --&gt;
   &lt;w&gt;72&lt;/w&gt;                  &lt;!-- optional width specification --&gt;
   &lt;h&gt;72&lt;/h&gt;                  &lt;!-- optional height specification --&gt;
  &lt;/instrument&gt;

 &lt;/instruments&gt;

&lt;/PropertyList&gt;
</PRE>
<BR>


<HR WIDTH="20%">
<H2><A NAME="indexed_properties">Indexed Properties:</A></H2>
<HR WIDTH="20%">
<p>
The property manager  assigns incremental indices to repeated
properties with the same parent node, so that
</P>
<PRE>
 &lt;PropertyList&gt;
 &lt;x&gt;1&lt;/x&gt;
 &lt;x&gt;2&lt;/x&gt;
 &lt;x&gt;3&lt;/x&gt;
 &lt;/PropertyList&gt;
</PRE><BR>
<p>
shows up as
</P>
<PRE>
 /x[0] = 1
 /x[1] = 2
 /x[2] = 3
</PRE><BR>
<p>
In fact, the panel I/O code insists that every instrument have the XML element 
name "instrument", every layer have the name "layer", every text chunk have the
name 

"chunk", every action have the name "action", and every transformation
have the name "transformation" -- this makes the XML more regular (so
that it can be created in a DTD-driven tool) and also allows us to
include other kinds of information (such as doc strings) in the lists
without causing confusion.
</P>

<HR WIDTH="20%">
<H2><A NAME="inclusion">Inclusion:</A></H2>
<HR WIDTH="20%">
<p>
Inclusion means that a node can include another property list as if it
were a part of the current file.
To clarify how inclusion works, consider the following examples:
</P>
<p>
If bar.xml contains
</P>
<PRE>
 &lt;PropertyList&gt;
 &lt;a&gt;1&lt;/a&gt;
 &lt;b&gt;
 &lt;c&gt;2&lt;/c&gt;
 &lt;/b&gt;
 &lt;/PropertyList&gt;
</PRE><BR>
<p>
then the declaration
</P>
<PRE>
 &lt;foo include="../bar.xml"&gt;
 &lt;/foo&gt;
</PRE><br>
<p>
is exactly equivalent to
</P>
<PRE>
 &lt;foo&gt;
 &lt;a&gt;1&lt;/a&gt;
 &lt;b&gt;
 &lt;c&gt;2&lt;/c&gt;
 &lt;/b&gt;
 &lt;/foo&gt;
</PRE>
<br>
<p>
However, it is also possible to selectively override properties in the
included file. For example, if the declaration were
</p>

<PRE>
 &lt;foo include="../bar.xml"&gt;
 &lt;a&gt;3&lt;/a&gt;
 &lt;/foo&gt;
</PRE>
<BR>
<p>
then the property manager would see
</P>
<PRE>
 &lt;foo&gt;
 &lt;a&gt;3&lt;/a&gt;
 &lt;b&gt;
 &lt;c&gt;2&lt;/c&gt;
 &lt;/b&gt;
 &lt;/foo&gt;
</PRE>
<br>
<p>
with the original 'a' property's value replaced with 3.
</P>
<p>
Inclusion  allows property files to be broken up and reused
arbitrarily -- for example, there might be separate texture cropping
property lists for commonly-used textures or layers, to avoid
repeating the information in each instrument file.
</P>


<HR WIDTH="20%">
<H2><A NAME="aliasing">Aliasing:</A></H2>
<HR WIDTH="20%">
<p>
Properties can alias other properties, similar to a symbolic link
in Unix. When the target property changes value, the new value will
show up in the aliased property as well. For example,
</p>
<PRE>
 &lt;PropertyList&gt;
 &lt;foo&gt;3&lt;/foo&gt;
 &lt;bar alias="/foo"/&gt;
 &lt;/PropertyList&gt;
</PRE>
<br>
<p>
will look the same to the application as
</p>
<PRE>
 &lt;PropertyList&gt;
 &lt;foo&gt;3&lt;/foo&gt;
 &lt;bar&gt;3&lt;/bar&gt;
 &lt;/PropertyList&gt;
</PRE>
<br>
<p>
except that when foo changes value, bar will change too.
</p>
<p>
*IMPORTANT*
-----------
The combination of inclusions and aliases is very powerful, because it
allows for parameterized property files. However, you must keep in
mind that when an instrument is included by reference, its root is 
*not* the root of the property tree, therefore aliases must be relative.
The relative location of the alias' root in the property hierarchy depends  
on whether the alias is used in a layer, a switch or an action.
In lieu of snappy mnemonic, please use the following table.
</p>
<pre>
when alias
is used in     go up
---------      -----
layer          5 ( ../../../../../params/foo )
switch         3 ( ../../../params/foo )
action         3 ( ../../../params/foo )
</pre>
<br>

<p>
As an example of inclusion and aliasing, consider the XML file
for the NAVCOM radio, which includes a parameter subtree at the start,
like this:
</p>

<PRE>
 &lt;PropertyList&gt;
 &lt;params&gt;
 &lt;comm-freq-prop&gt;/radios/comm1/frequencies/selected-mhz&lt;/comm-freq-prop&gt;
 &lt;nav-freq-prop&gt;/radios/nav1/frequencies/selected-mhz&lt;/nav-freq-prop&gt;
 &lt;/params&gt;

 ...

 &lt;chunk&gt;
 &lt;type&gt;number-value&lt;/type&gt;
 &lt;property alias="../../../../../params/nav-freq-prop"/&gt;
 &lt;/chunk&gt;

 ...
 &lt;/PropertyList&gt;
</PRE>
<br>
<P>
The same instrument file is used for navcomm1 and navcomm2 simply by
overriding the parameters at inclusion in the top level panel property list.
</P>

<pre>
 &lt;instrument include="../Instruments/navcomm.xml"&gt;
 &lt;name&gt;NAVCOM 1 radio&lt;/name&gt;
 &lt;params&gt;
 &lt;comm-freq-prop&gt;/radios/comm1/frequencies/selected-mhz&lt;/comm-freq-prop&gt;
 &lt;nav-freq-prop&gt;/radios/nav1/frequencies/selected-mhz&lt;/nav-freq-prop&gt;
 &lt;/params&gt;
 .....
 &lt;/instrument&gt;

 &lt;instrument include="../Instruments/navcomm.xml"&gt;
 &lt;name&gt;NAVCOM 2 radio&lt;/name&gt;
 &lt;params&gt;
 &lt;comm-freq-prop&gt;/radios/comm2/frequencies/selected-mhz&lt;/comm-freq-prop&gt;
 &lt;nav-freq-prop&gt;/radios/nav2/frequencies/selected-mhz&lt;/nav-freq-prop&gt;
 &lt;/params&gt;
 .....
 &lt;/instrument&gt;
</PRE>
<br>

<HR WIDTH="20%">
<H2><A NAME="instrument_architecture">Instrument Architecture:</A></H2>
<HR WIDTH="20%">

<p>
Instruments are defined in separate configuration files. An instrument
consists of a base width and height, one or more stacked layers,
and zero or more actions. Base dimensions are specified as follows:
</p>
<pre>
&lt;PropertyList&gt;                   &lt;!-- remember, all xml files start like this --&gt;
 &lt;name&gt;Airspeed Indicator&lt;/name&gt; &lt;!-- names are good --&gt;
 &lt;w-base&gt;128&lt;/w-base&gt;            &lt;!-- required width spec--&gt;
 &lt;h-base&gt;128&lt;/h-base&gt;            &lt;!-- required height spec--&gt;
  &lt;layers&gt;                       &lt;!-- begins layers section --&gt;
</pre>
<br>

<p>
Height and width can be overriden in the top level panel.xml by
specifying &lt;w&gt; and &lt;h&gt;. Transformations are caculated against the base size
regardless of the display size. This ensures that instruments remain calibrated.
</p>

<HR WIDTH="20%">
<H2><A NAME="textures">Textures:</A></H2>
<HR WIDTH="20%">
<p>
FG uses red/green/blue/alpha .rgba files for textures. Dimensions for
texture files should be power of 2 with a maximum 8:1 aspect ratio.
The lowest common denominator for maximum texture size is 256 pixels.
This is due to the limitations of certain video accelerators, most notably
those with 3Dfx chipset such as the Voodoo2.

</p>

<HR WIDTH="20%">
<H2><A NAME="instrument_layers">Instrument Layers**:</A></H2>
<HR WIDTH="20%">
<p>
The simplest layer is a &lt;texture&gt;. These can be combined in &lt;switch&gt; layers
</p>
<p>
&lt;texture&gt;
A texture layer looks like this:
</p>
<pre>
  &lt;layer&gt;                      &lt;!-- creates a layer --&gt;
   &lt;name&gt;face&lt;/name&gt;
   &lt;texture&gt;                   &lt;!-- defines it as a texture layer --&gt;
    &lt;path&gt;Aircraft/c172/Instruments/Textures/faces-2.rgb&lt;/path&gt;
    &lt;x1&gt;0&lt;/x1&gt;                 &lt;!-- lower boundary for texture cropping--&gt;
    &lt;y1&gt;0.51&lt;/y1&gt;              &lt;!-- left boundary  for texture cropping--&gt;
    &lt;x2&gt;0.49&lt;/x2&gt;              &lt;!-- upper boundary  for texture cropping--&gt;
    &lt;y2&gt;1.0&lt;/y2&gt;               &lt;!-- right boundary  for texture cropping--&gt;
   &lt;/texture&gt;                  &lt;!-- closing texure tag --&gt;
  &lt;/layer&gt;                     &lt;!-- closing layer tag --&gt;
</pre>
<br>
<p>
The texture cropping specification is represented as a decimal. There is a table
at the end of this document for converting from pixel coordinates to percentages.
</p>
<p>
This particular layer, being a gauge face has no transformations applied to it.
Layers with that aren't static *must* include &lt;w&gt; and &lt;h&gt; parameters to be visible.
</p>
<p>
&lt;type&gt; May be either text or switch..
</p>
<p>
&lt;type&gt;switch&lt;/type&gt;
A switch layer is composed of two or more nested layers and will display
one of the nested layers based on a boolean property. For a simple example
of a switch see $FG_ROOT/Aircraft/c172/Instruments/brake.xml.
</p>
<pre>
  &lt;layer&gt;
   &lt;name&gt;Brake light&lt;/name&gt;
   &lt;type&gt;switch&lt;/type&gt;                      &lt;!-- define layer as a switch --&gt;
   &lt;property&gt;/controls/gear/brake-left&lt;/property&gt;    &lt;!-- tie it to a property --&gt;
    &lt;layer1&gt;                                &lt;!-- layer for true state --&gt;
     &lt;name&gt;on&lt;/name&gt;                        &lt;!-- label to make life easy --&gt;
     &lt;texture&gt;                              &lt;!-- layer1 of switch is a texture layer --&gt;
     &lt;path&gt;Aircraft/c172/Instruments/Textures/brake.rgb&lt;/path&gt;
     &lt;x1&gt;0.25&lt;/x1&gt;
     &lt;y1&gt;0.0&lt;/y1&gt;
     &lt;x2&gt;0.5&lt;/x2&gt;
     &lt;y2&gt;0.095&lt;/y2&gt;
     &lt;/texture&gt;
     &lt;w&gt;64&lt;/w&gt;                              &lt;!-- required width - layer isn't static --&gt;
     &lt;h&gt;24&lt;/h&gt;                              &lt;!-- required height - layer isn't static --&gt;
    &lt;/layer1&gt;                               &lt;!-- close layer1 of switch --&gt;
    &lt;layer2&gt;                                &lt;!-- layer for false state --&gt;
     &lt;name&gt;off&lt;/name&gt;
     &lt;texture&gt;
     &lt;path&gt;Aircraft/c172/Instruments/Textures/brake.rgb&lt;/path&gt;
     &lt;x1&gt;0.0&lt;/x1&gt;
     &lt;y1&gt;0.0&lt;/y1&gt;
     &lt;x2&gt;0.25&lt;/x2&gt;
     &lt;y2&gt;0.095&lt;/y2&gt;
     &lt;/texture&gt;
     &lt;w&gt;64&lt;/w&gt;
     &lt;h&gt;24&lt;/h&gt;
   &lt;/layer2&gt;
  &lt;/layer&gt;
</pre>
<br>
<p>
Switches can have more than 2 states. This requires nesting one switch inside another.
One could make, for example, a 3 color LED by nesting switch layers.
</p>

<p>
&lt;type&gt;text&lt;/type&gt;
A text layer may be static, as in a label, generated from a property or a combination of both.
This example is a switch that contains both static and dynamic text:
</p>

<pre>
   &lt;layer1&gt;                               &lt;!-- switch layer --&gt;
    &lt;name&gt;display&lt;/name&gt;
    &lt;type&gt;text&lt;/type&gt;                     &lt;!-- type == text --&gt;
    &lt;point-size&gt;12&lt;/point-size&gt;           &lt;!-- font size --&gt;
    &lt;color&gt;                               &lt;!-- specify rgb values to color text --&gt;
     &lt;red&gt;1.0&lt;/red&gt;
     &lt;green&gt;0.5&lt;/green&gt;
     &lt;blue&gt;0.0&lt;/blue&gt;
    &lt;/color&gt;                              &lt;!-- close color section --&gt;
    &lt;chunks&gt;                              &lt;!-- sections of text are referred to as chunks --&gt;
     &lt;chunk&gt;                              &lt;!-- first chunk of text --&gt;
      &lt;type&gt;number-value&lt;/type&gt;           &lt;!-- value defines it as dynamic --&gt;
      &lt;property&gt;/radios/nav1/dme/distance-nm&lt;/property&gt;      &lt;!-- ties it to a property --&gt;
      &lt;scale&gt;0.00053995680&lt;/scale&gt;        &lt;!-- convert between  statute and nautical miles? --&gt;
      &lt;format&gt;%5.1f&lt;/format&gt;              &lt;!-- define format --&gt;
     &lt;/chunk&gt;
    &lt;/chunks&gt;
   &lt;/layer1&gt;
   &lt;layer2&gt;                                &lt;!-- switch layer --&gt;
    &lt;name&gt;display&lt;/name&gt;
    &lt;type&gt;text&lt;/type&gt;                      &lt;!-- type == text --&gt;
    &lt;point-size&gt;10&lt;/point-size&gt;            &lt;!-- font size --&gt;
    &lt;color&gt;                                &lt;!-- specify rgb values to color text --&gt;
     &lt;red&gt;1.0&lt;/red&gt;
     &lt;green&gt;0.5&lt;/green&gt;
     &lt;blue&gt;0.0&lt;/blue&gt;
    &lt;/color&gt;                               &lt;!-- close color section --&gt;
    &lt;chunks&gt;                               &lt;!-- sections of text are referred to as chunks --&gt;
     &lt;chunk&gt;                               &lt;!-- first chunk of text --&gt;
      &lt;type&gt;literal&lt;/type&gt;                 &lt;!-- static text --&gt;
      &lt;text&gt;---.--&lt;/text&gt;                  &lt;!-- fixed value --&gt;
     &lt;/chunk&gt;
    &lt;/chunks&gt;
   &lt;/layer2&gt;
</pre>
<br>
Note that the value to be displayed can be modified using &lt;scale&gt; for multiplication, 
&lt;offset&gt; for addition, and &lt;truncate&gt;true&lt;/truncate&gt; for truncation.  The order of
operation is always scale-offset-truncation, which may require you to adapt your formula.  For instance, the
normal conversion from Fahrenheit to Celsius would be C = (F-32)*0.555555556.  Because of the order
of operation above you must use the formula C = (F*0.55555556)-17.77777777.
<br>

<HR WIDTH="20%">
<H2><A NAME="conditions">Conditions:</A></H2>
<HR WIDTH="20%">

<p>
A condition may appear in a binding (for keyboard, joystick, or panel
action) or in most parts of a panel configuration file (specifically,
for an instrument, layer, transformation, text chunk, or action).  If
a condition is present, it must succeed for the component to be used
(i.e. if the condition fails, the binding will not be fired, the layer
will not be drawn, etc.).  Conditions are compiled to an efficient
internal form and load time.
</p>
<p>
For example, to ensure that a layer is drawn only if the /foo/bar
property has the value "active", you would do the following:
</p>
<pre>
  &lt;layer&gt;
   &lt;name&gt;FooBar Layer&lt;/name&gt;
   &lt;condition&gt;
    &lt;equals&gt;
     &lt;property&gt;/foo/bar&lt;/property&gt;
     &lt;value&gt;active&lt;/value&gt;
    &lt;/equals&gt;
   &lt;/condition&gt;
   ...
  &lt;/layer&gt;
</pre>
<p>
To draw a different layer when the /foo/bar property does not have the
value "active", you could follow with this:
</p>
<pre>
  &lt;layer&gt;
   &lt;name&gt;FooBar Layer&lt;/name&gt;
   &lt;condition&gt;
    &lt;not-equals&gt;
     &lt;property&gt;/foo/bar&lt;/property&gt;
     &lt;value&gt;active&lt;/value&gt;
    &lt;/not-equals&gt;
   &lt;/condition&gt;
   ...
  &lt;/layer&gt;
</pre>
<p>
While conditions were originally created for panel designers, they
have proven to  be very useful for binding input devices (such
as the keyboard or joystick), since they effectively allow any key,
axis, button, or panel action to act as a modifier for any other key,
axis, button, or panel action, and in fact, allow mind-numbingly
complicated combinations for people who like them (i.e. Emacs users).
</p>
<pre>
  &lt;!-- make 'u' a modifier key --&gt;
  &lt;!-- could also use property-toggle to make it a toggle modifier --&gt;
  &lt;key n="117"&gt;
   &lt;name&gt;u&lt;/name&gt;
   &lt;desc&gt;Special 'u' modifier&lt;/desc&gt;

   &lt;binding&gt;
    &lt;command&gt;property-assign&lt;/command&gt;
    &lt;property&gt;/modifiers/u&lt;/property&gt;
    &lt;value&gt;1&lt;/value&gt;
   &lt;/binding&gt;

   &lt;mod-up&gt;
    &lt;binding&gt;
     &lt;command&gt;property-assign&lt;/command&gt;
     &lt;property&gt;/modifiers/u&lt;/property&gt;
     &lt;value&gt;0&lt;/value&gt;
    &lt;/binding&gt;
   &lt;/mod-up&gt;

  &lt;/key&gt;

  &lt;!-- take different actions based on the u modifier --&gt;
  &lt;key n="118"&gt;
   &lt;name&gt;v&lt;/name&gt;

   &lt;binding&gt;
    &lt;condition&gt;
     &lt;property&gt;/modifiers/u&lt;/property&gt;
    &lt;/condition&gt;
    &lt;command&gt;property-toggle&lt;/command&gt;
    &lt;property&gt;/foo/bar&lt;/property&gt;
   &lt;/binding&gt;

   &lt;binding&gt;
    &lt;condition&gt;
     &lt;not&gt;
      &lt;property&gt;/modifiers/u&lt;/property&gt;
     &lt;/not&gt;
    &lt;/condition&gt;
    &lt;command&gt;property-toggle&lt;/command&gt;
    &lt;property&gt;/bar/foo&lt;/property&gt;
   &lt;/binding&gt;

  &lt;/key&gt;
</pre>
<p>
The &lt;condition&gt; element acts as an implicit 'and' group for everything
contained in it.  Here are the elements that can appear inside:
</p>
<pre>
  &lt;property&gt;[name]&lt;/property&gt;

  - true if the named property returns a true boolean value (i.e. a
    non-0 numeric value)

  &lt;and&gt;[condition...]&lt;/and&gt;

  - true if all of the conditions contained in it are true

  &lt;or&gt;[condition...]&lt;/or&gt;

  - true if any of the conditions contained in it is true

  &lt;not&gt;[condition]&lt;/not&gt;

  - true if the condition contained in it is false

  &lt;less-than&gt;...&lt;/less-than&gt;
  &lt;less-than-equals&gt;...&lt;/less-than-equals&gt;
  &lt;equals&gt;...&lt;/equals&gt;
  &lt;not-equals&gt;...&lt;/not-equals&gt;
  &lt;greater-than&gt;...&lt;/greater-than&gt;
  &lt;greater-than-equals&gt;...&lt;/greater-than-equals&gt;
</pre>
<p>
  - all of these take two child elements; the first, "property", is
    the property to test; the second argument may be "property" or
    "value".  If it is also "property" (i.e. property[1]), the named
    property's value will be used; otherwise, the literal value
    provided will be used
  - be warned that any string comparison other than equals/not-equals
    is guaranteed to be flaky
</p>

<HR WIDTH="20%">
<H2><A NAME="transformations">Transformations:</A></H2>
<HR WIDTH="20%">
<p>
A transformation is a rotation, an x-shift, or a y-shift. Transformations
can be static  or they can be based on properties. Static rotations are
useful for flipping textures horizontally or vertically. Transformations
based on properties are useful for driving instrument needles. I.E. rotate the
number of degrees equal to the airspeed. X and y shifts are relative to the
center of the instrument. Each specified transformation type takes an &lt;offset&gt;.</p><p>
Offsets are relative to the center of the instrument. A shift without an offset
has no effect. For example, let's say we have a texture that is a circle. If we
use this texture in two layers, one defined as having a size of 128x128 and
the second layer is defined as 64x64 and neither is supplied  a shift and offset
the net result appears as 2 concentric circles.
</p>

<HR WIDTH="20%">
<H2><A NAME="needle_placement">About Transformations and Needle Placement:</A></H2>
<HR WIDTH="20%">

<p>
When describing placement of instrument needles, a transformation offset must
be applied to shift the needles fulcrum or else the needle will rotate around it's
middle. The offset will be of &lt;type&gt; x-shift or y-shift depending on the orientation of
the needle section in the cropped texture.
</p>

<p>
This example comes from the altimeter.xml
</p>

<pre>
  &lt;layer&gt;
   &lt;name&gt;long needle (hundreds)&lt;/name&gt;        &lt;!-- the altimeter has more than one needle --&gt;
   &lt;texture&gt;
    &lt;path&gt;Aircraft/c172/Instruments/Textures/misc-1.rgb&lt;/path&gt;
    &lt;x1&gt;0.8&lt;/x1&gt;
    &lt;y1&gt;0.78125&lt;/y1&gt;
    &lt;x2&gt;0.8375&lt;/x2&gt;
    &lt;y2&gt;1.0&lt;/y2&gt;
   &lt;/texture&gt;
   &lt;w&gt;8&lt;/w&gt;
   &lt;h&gt;56&lt;/h&gt;
   &lt;transformations&gt;                          &lt;!-- begin defining transformations --&gt;
    &lt;transformation&gt;                          &lt;!-- start definition of transformation that drives the needle --&gt;
     &lt;type&gt;rotation&lt;/type&gt;
     &lt;property&gt;/steam/altitude-ft&lt;/property&gt;     &lt;!-- bind it to a property --&gt;
     &lt;max&gt;100000.0&lt;/max&gt;                      &lt;!-- upper limit of instrument --&gt;
     &lt;scale&gt;0.36&lt;/scale&gt;                      &lt;!-- once around == 1000 ft --&gt;
    &lt;/transformation&gt;                         &lt;!-- close this transformation --&gt;
    &lt;transformation&gt;                          &lt;!-- this one shifts the fulcrum of the needle --&gt;
     &lt;type&gt;y-shift&lt;/type&gt;                     &lt;!-- y-shift relative to needle --&gt;
     &lt;offset&gt;24.0&lt;/offset&gt;                    &lt;!-- amount of shift --&gt;
    &lt;/transformation&gt;
   &lt;/transformations&gt;
  &lt;/layer&gt;
</pre>
<br>

<p>
This needles has its origin in the center of the instrument. If the needles fulcrum was
towards the edge of the instrument, the transformations to place the pivot point must
precede those which drive the needle,
</p>

<HR WIDTH="20%">
<H2><A NAME="interpolation">Interpolation Tables:</A></H2>
<HR WIDTH="20%">

<p>
Non linear transformations are now possible via the use of interpolation tables.
</p>

<pre>
 &lt;transformation&gt;
 ...
 &lt;interpolation&gt;
 &lt;entry&gt;
 &lt;ind&gt;0.0&lt;/ind&gt;            &lt;!-- raw value --&gt;
 &lt;dep&gt;0.0&lt;/dep&gt;            &lt;!-- displayed value --&gt;
 &lt;/entry&gt;
 &lt;entry&gt;
 &lt;ind&gt;10.0&lt;/ind&gt;
 &lt;dep&gt;100.0&lt;/dep&gt;
 &lt;/entry&gt;
 &lt;entry&gt;
 &lt;ind&gt;20.0&lt;/ind&gt;
 &lt;dep&gt;-5.0&lt;/dep&gt;
 &lt;/entry&gt;
 &lt;entry&gt;
 &lt;ind&gt;30.0&lt;/ind&gt;
 &lt;dep&gt;1000.0&lt;/dep&gt;
 &lt;/entry&gt;
 &lt;/interpolation&gt;
 &lt;/transformation&gt;
</pre>
<br>

<p>
Of course, interpolation tables are useful for non-linear stuff, as in
the above example, but I kind-of like the idea of using them for
pretty much everything, including non-trivial linear movement -- many
instrument markings aren't evenly spaced, and the interpolation tables
are much nicer than the older min/max/scale/offset stuff and should
allow for a more realistic panel without adding a full equation parser
to the property manager.
</p>
<p>
If you want to try this out, look at the airspeed.xml file in the base
package, and uncomment the interpolation table in it for a
very funky, non-linear and totally unreliable airspeed indicator.
</p>

<HR WIDTH="20%">
<H2><A NAME="actions">Actions:</A></H2>
<HR WIDTH="20%">

<p>
An action is a hotspot on an instrument where something will happen
when the user clicks the left or center mouse button.  Actions are
always tied to properties: they can toggle a boolean property, adjust
the value of a numeric property, or swap the values of two properties.
The x/y placement for actions specifies the origin of the lower left corner.
In the following example the first action sets up a hotspot 32 pixels wide
and 16 pixels high. It lower left corner is placed 96 pixels (relative to the
defined base size of the instrument) to the right of the center of the
instrument. It is also 32 pixels below the centerline of the instrument.
The actual knob texture over which the action is superimposed is 32x32.
Omitted here is a second action, bound to the same property, with a positive
increment value. This second action is placed to cover the other half of the
knob. The result is that clicking on the left half of the knob texture decreases
the value and clicking the right half increases the value. Also omitted here
is a second pair of actions with the same coordinates but a larger increment
value. This second pair is bound to a different mouse button. The net result
is that we have both fine and coarse adjustments in the same hotspot, each
bound to a different mouse button.
</p>

<p>
These examples come from the radio stack:
</p>

<pre>
&lt;actions&gt;                              &lt;!-- open the actions section --&gt;
  &lt;action&gt;                             &lt;!- first action --&gt;
   &lt;name&gt;small nav frequency decrease&lt;/name&gt;
   &lt;type&gt;adjust&lt;/type&gt;
   &lt;button&gt;0&lt;/button&gt;                  &lt;!-- bind it to a mouse button --&gt;
   &lt;x&gt;96&lt;/x&gt;                           &lt;!-- placement relative to instrument center --&gt;
   &lt;y&gt;-32&lt;/y&gt;
   &lt;w&gt;16&lt;/w&gt;                           &lt;!-- size of hotspot --&gt;
   &lt;h&gt;32&lt;/h&gt;
   &lt;property&gt;/radios/nav1/frequencies/standby-mhz&lt;/property&gt;    &lt;!-- bind to a property --&gt;
   &lt;increment&gt;-0.05&lt;/increment&gt;        &lt;!-- amount of adjustment per mouse click --&gt;
   &lt;min&gt;108.0&lt;/min&gt;                    &lt;!-- lower range --&gt;
   &lt;max&gt;117.95&lt;/max&gt;                   &lt;!-- upper range --&gt;
   &lt;wrap&gt;1&lt;/wrap&gt;                      &lt;!-- boolean value -- value wraps around when it hits bounds --&gt;
  &lt;/action&gt;
  &lt;action&gt;
   &lt;name&gt;swap nav frequencies&lt;/name&gt;
   &lt;type&gt;swap&lt;/type&gt;                   &lt;!-- define type of action --&gt;
   &lt;button&gt;0&lt;/button&gt;
   &lt;x&gt;48&lt;/x&gt;
   &lt;y&gt;-32&lt;/y&gt;
   &lt;w&gt;32&lt;/w&gt;
   &lt;h&gt;32&lt;/h&gt;
   &lt;property1&gt;/radios/nav1/frequencies/selected-mhz&lt;/property1&gt;   &lt;!-- properties to toggle between --&gt;
   &lt;property2&gt;/radios/nav1/frequencies/standby-mhz&lt;/property2&gt;
  &lt;/action&gt;
  &lt;action&gt;
   &lt;name&gt;ident volume on/off&lt;/name&gt;
   &lt;type&gt;adjust&lt;/type&gt;
   &lt;button&gt;1&lt;/button&gt;
   &lt;x&gt;40&lt;/x&gt;
   &lt;y&gt;-24&lt;/y&gt;
   &lt;w&gt;16&lt;/w&gt;
   &lt;h&gt;16&lt;/h&gt;
   &lt;property&gt;/radios/nav1/ident&lt;/property&gt;  &lt;!-- this property is for Morse code identification of nav beacons --&gt;
   &lt;increment&gt;1.0&lt;/increment&gt;          &lt;!-- the increment equals the max value so this toggles on/off --&gt;
   &lt;min&gt;0&lt;/min&gt;
   &lt;max&gt;1&lt;/max&gt;
   &lt;wrap&gt;1&lt;/wrap&gt;                      &lt;!-- a shortcut to avoid having separate actions for on/off --&gt;
  &lt;/action&gt;
&lt;/actions&gt;
</pre>
<br>

<HR WIDTH="20%">
<H2><A NAME="more_texture">More About Textures:</A></H2>
<HR WIDTH="20%">

<p>
As previously stated, the usual size instrument texture files in FGFS are  256x256
pixels, red/green/blue/alpha format. However the mechanism for specifying
texture cropping coordinates is decimal in nature. When calling a section
of a texture file the 0,0 lower left convention is used.
There is a pair of x/y coordinates defining which section of the texture
to use.
</p>
<p>
The following table can be used to calculate texture cropping specifications.
</p>
<pre>
# of divisions | width in pixels | decimal specification
per axis
        1   =   256 pixels              1
        2   =   128 pixels,             0.5
        4   =   64 pixels,              0.25
        8   =   32 pixels,              0.125
        16  =   16 pixels,              0.0625
        32  =   8 pixels,               0.03125
        64  =   4 pixels,               0.015625
        128 =   2 pixels,               0.0078125
        256 =   1 pixel,                0.00390625
</pre>
<br>

<p>
The displayed size of a texture in pixels is set in the instrument
configuration file. The size of the cropped area in pixels is not
directly related to the final display size.
</p>
<p>
What that table represents is:
</p>
<p>
1 / (256 / # of pixels)
</p>
<p>
Take as an example, a section 64 pixels wide on the texture file.
256/64 = 4
1/4 = 0.25
</p>
<p>
Or lets consider 1 pixel wide
256/1 = 256
1/256 = 0.00390625
</p>
<p>
If the section starts at the extreme left of the texture, the
starting number is 0.0 and the end is 0.25
If the section *doesn't* start at the edge you need to take the starting
pixel and calculate an offset. Lets say you start 2 pixels from the
edge and you are cropping a section 64 pixels wide...
</p>

<pre>
256/2 = 128
1/128 = 0.0078125 &lt;- this is the value for a 2 pixel wide offset


0.0078125 &lt;- start at
0.25      &lt;- add value for 64 px wide
0.2571825 &lt;- end at
</pre>
<br>

<HR WIDTH="20%">
<H2><A NAME="generating_textures">Generating Textures:</A></H2>
<HR WIDTH="20%">

<p>
A common procedure for generating gauge faces is to use a
vector graphics package such as xfig, exporting the result as a
postscript file. 3D modeling tools may also be used and I prefer them
for pretty items such as levers, switches, bezels and so forth.
Ideally, the size of the item in the final render
should be of proportions that fit into the recommended pixel widths.
The resulting files can  be imported into a graphics manipulation
package such as GIMP, et al for final processing.
</P>

<HR WIDTH="20%">
<H2><A NAME="contribute">Contributing Panels And Instruments</A></H2>
<HR WIDTH="20%">

<p>
There are two main considerations when contributing panels and instruments.
Firstly, original artwork is a major plus since you as the creator can dictate the terms
of distribution. All Artwork must have a license compatible with the GPL.
Artwork of unverifiable origin is not acceptable.
Secondly, texture sizes must meet the lowest common denominator of 256e2 pixels.
Artwork from third parties may be acceptable if it meets these criteria.
</p>

<HR WIDTH="20%">
<H2><A NAME="units">UNITS:</A></H2>
<HR WIDTH="20%">
<p>
Here is a list of property names including appropriate units:
</p>

<PRE>
/autopilot/locks/nav1 =&gt; /autopilot/locks/nav[0]
/autopilot/settings/altitude += "-ft"
/autopilot/settings/climb-rate += "-fpm"
/autopilot/settings/heading-bug += "-deg"
/consumables/fuel/tank1/level =&gt; /consumables/fuel/tank[0]/level-gal_us
/consumables/fuel/tank2/level =&gt; /consumables/fuel/tank[1]/level-gal_us
/engines/engine0/cht =&gt; /engines/engine[0]/cht-degf
/engines/engine0/egt =&gt; /engines/engine[0]/egt-degf
/engines/engine0/fuel-flow =&gt; /engines/engine[0]/fuel-flow-gph
/engines/engine0/mp =&gt; /engines/engine[0]/mp-osi
/engines/engine0/rpm =&gt; /engines/engine[0]/rpm
/environment/clouds/altitude += "-ft"
/environment/magnetic-dip += "-deg"
/environment/magnetic-variation += "-deg"
/environment/visibility += "-m"
/environment/wind-down += "-fps"
/environment/wind-east += "-fps"
/environment/wind-north += "-fps"
/orientation/heading += "-deg"
/orientation/heading-magnetic += "-deg"
/orientation/pitch += "-deg"
/orientation/roll += "-deg"
/position/altitude += "-ft"
/position/altitude-agl += "-ft"
/position/latitude += "-deg"
/position/longitude += "-deg"
/radios/adf/frequencies/selected += "-khz"
/radios/adf/frequencies/standby += "-khz"
/radios/adf/rotation += "-deg"
/radios/nav1/* =&gt; /radios/nav[0]/*
/radios/nav2/* =&gt; /radios/nav[1]/*
/radios/nav[*]/dme/distance += "-nm"
/radios/nav[*]/frequencies/selected += "-mhz"
/radios/nav[*]/frequencies/standby += "-mhz"
/radios/nav[*]/radials/actual += "-deg"
/radios/nav[*]/radials/selected += "-deg"
/sim/model/h-rotation =&gt; /sim/model/heading-offset-deg
/sim/model/p-rotation =&gt; /sim/model/roll-offset-deg
/sim/model/r-rotation =&gt; /sim/model/pitch-offset-deg
/sim/model/x-offset += "-m"
/sim/model/y-offset += "-m"
/sim/model/z-offset += "-m"
/sim/view/goal-offset += "-deg"
/sim/view/offset += "-deg"
/steam/adf += "-deg"
/steam/airspeed += "-kt"
/steam/altitude += "-ft"
/steam/gyro-compass += "-deg"
/steam/gyro-compass-error += "-deg"
/steam/mag-compass += "-deg"
/steam/vertical-speed += "-fpm"
/velocities/airspeed += "-kt"
/velocities/side-slip += "-rad"
/velocities/speed-down += "-fps"
/velocities/speed-east += "-fps"
/velocities/speed-north += "-fps"
/velocities/uBody += "-fps"
/velocities/vBody += "-fps"
/velocities/wBody += "-fps"
/velocities/vertical-speed += "-fps"
</pre>
<br>
<p>
*  If there are *any* XML parsing errors, the panel will fail to load,
   so it's worth downloading a parser like Expat (http://www.jclark.com/xml/)
   for checking your XML. FlightGear will print the location of errors, but
   the messages are a little cryptic right now.
</P>
<p>
** NOTE: There is one built-in layer -- for the mag compass ribbon --
   and all other layers are defined in the XML files.  In the future,
   there may also be built-in layers for special things like a
   weather-radar display or a GPS (though the GPS could be handled with
   text properties).
</p>
</BODY>
</HTML>

--- End of README.xmlpanel.html ---


--- Start of README.xmlparticles ---

Document started 27/01/2008 by Tiago Gusmo
Updated 02/02/2008 to reflect syntax changes
Updated 03/02/2008 to add trails (connected particles)

This is a short specification/tutorial to define particle systems in
FlightGear using XML

Meaningless example (what i had accumulated due to tests):

  <particlesystem>
    <name>fuel</name>
<!--     <texture>particle.rgb</texture> -->
    <emissive>false</emissive>
    <lighting>true</lighting>

    <offsets>
      <x-m>35</x-m>
      <y-m>-0.3</y-m>
      <z-m>0</z-m>
      <!--<pitch-deg>90</pitch-deg>-->
    </offsets>

    <!--<condition>
      <and>
        <equals>
          <property>engines/engine/smoking</property>
          <value>true</value>
        </equals>
        <less-than>
          <property>position/altitude-agl-ft</property>
          <value>12000</value>
        </less-than>
      </and>
    </condition>-->

    <attach>world</attach>

    <placer>
      <type>point</type>
    </placer>

    <shooter>
      <theta-min-deg>84</theta-min-deg>
      <theta-max-deg>86</theta-max-deg>
      <phi-min-deg>-1.5</phi-min-deg>
      <phi-max-deg>1.5</phi-max-deg>
      <speed>
        <value>10</value>
        <spread>2.5</spread>
      </speed>
      <rotation-speed>
        <x-min-deg-sec>0</x-min-deg-sec>
        <y-min-deg-sec>0</y-min-deg-sec>
        <z-min-deg-sec>0</z-min-deg-sec>
        <x-max-deg-sec>0</x-max-deg-sec>
        <y-max-deg-sec>0</y-max-deg-sec>
        <z-max-deg-sec>0</z-max-deg-sec>
      </rotation-speed>
    </shooter>

    <counter>
      <particles-per-sec>
        <value>1</value>
        <spread>0</spread>
      </particles-per-sec>
    </counter>

    <align>billboard</align>

    <particle>
      <start>
        <color>
          <red>
            <value>0.9</value>
          </red>
          <green>
            <value>0.09</value>
          </green>
          <blue>
            <value>0.09</value>
          </blue>
          <alpha>
            <value>1.0</value>
          </alpha>
        </color>
        <size>
          <value>0.25</value>
        </size>
      </start>

      <end>
        <color>
          <red>
            <value>1</value>
          </red>
          <green>
            <value>0.1</value>
          </green>
          <blue>
            <value>0.1</value>
          </blue>
          <alpha>
            <value>0.0</value>
          </alpha>
        </color>
        <size>
          <value>4</value>
        </size>
      </end>

      <life-sec>
        <value>10</value>
      </life-sec>

      <mass-kg>0.25</mass-kg>
      <radius-m>0.1</radius-m>
    </particle>

    <program>
      <fluid>air</fluid>
      <gravity type="bool">true</gravity>
      <wind type="bool">true</wind>
    </program>
</particlesystem>

Stick this inside any model XML like it was an animation and it should
work (notice the condition requires wheel on the ground)

Specification:

Note:
<VALUEORPROP/> means you can either specify a property with factor and
offset (result = (prop*factor)+offset ) in the usual way


<particlesystem>  = the base tag
  <type>string</type> = can be "normal" or "trail", normal is the usual quad
                        particles, trail is a string of connected line shapes
                        by default.
  <offsets>  = this places the source of the particles (the emitter) in relation
               to the perhaps already offset model (see model-howto.html for details)
    <x-m>float</x-m>
    <y-m>float</y-m>
    <z-m>float</z-m>
    <pitch-deg>float</pitch-deg>
    <roll-deg>float</roll-deg>
    <heading-deg>float</heading-deg>
  </offsets>
  <condition> = a typical condition that if not true stops particles from being
    ....        emitted (PPS=0)
  </condition>
  <name>string</name> = the name of the particle system (so it can be referenced
                        by normal animations)
  <attach>string</attach> = can be "world" or "local". "world means the particles
                            aren't "physically linked" to the model (necessary for
                            use outside moving models), "local" means the opposite
                            (can be used for static objects or inside moving objects)
  <texture>string</texture> = the texture path relative to the XML file location
  <emissive>bool</emissive> = self-explanatory
  <lighting>bool</lighting> = yet to be tested, but seems obvious
  <align>string</align> = can be "billboard" or "fixed"
  <placer> = where particles are born
    <type>string</type> = can be "sector" (inside a circle), "segments"(user-defined
                          segments) and "point" (default)
    *<radius-min-m>float</radius-min-m> = only for sector, inner radius at which
                                          particles appear
    *<radius-max-m>float</radius-max-m> = only for sector, outer radius at which
                                          particles appear
    *<phi-min-deg>float</phi-min-deg> = only for sector, starting angle of the
                                        slide at which particles appear
    *<phi-max-deg>float</phi-max-deg> = only for sector, ending angle of the slide
                                        at which particles appear
    <segments> = only for segments, encloses sequential points that form segments
      <vertex> = specifies one point, put as many as you want
        <x-m>float</x-m>
        <y-m>float</y-m>
        <z-m>float</z-m>
      </vertex>
      ....
      <vertex>
      ...
      </vertex>
    </segments>
  </placer>
  <shooter> = the shooter defines the initial velocity vector for your particles
    *<theta-min-deg>float</theta-min-deg> = horizontal angle limits of the particle cone
    *<theta-max-deg>float</theta-max-deg>
    *<phi-min-deg>float</phi-min-deg> = vertical angle limits of the particle cone
    *<phi-max-deg>float</phi-max-deg>   for an illustration of theta/phi see
    http://www.cs.clemson.edu/~malloy/courses/3dgames-2007/tutor/web/particles/particles.html
    <speed-mps> = the scalar velocity (meter per second)
     <VALUEORPROP/> = see note
     *<spread> = the "tolerance" in each direction so values are in the range
                 [value-spread, value+spread]
    </speed-mps>
    <rotation-speed> = the range of initial rotational speed of the particles
      *<x-min-deg-sec>float</x-min-deg-sec>
      *<y-min-deg-sec>float</y-min-deg-sec>
      *<z-min-deg-sec>float</z-min-deg-sec>
      *<x-max-deg-sec>float</x-max-deg-sec>
      *<y-max-deg-sec>float</y-max-deg-sec>
      *<z-max-deg-sec>float</z-max-deg-sec>
    </rotation-speed>
  </shooter>
  <counter>
    <particles-per-sec>
      <VALUEORPROP/> = see note
      *<spread> = the "tolerance" in each direction so values are in the range
                  [value-spread, value+spread]
    </particles-per-sec>
  </counter>
  <particle> = defines the particle properties
    <start>
      <color> = initial color (at time of emission)
        <red><VALUEORPROP/></red> = color component in normalized value [0,1]
        <green><VALUEORPROP/></green>
        <blue><VALUEORPROP/></blue>
        <alpha><VALUEORPROP/></alpha>
      </color>
      <size> = as above, but for size
        <VALUEORPROP/>
      </size>
    </start>
    <end>
      <color> = final color (at the end of the particle life)
        <red><VALUEORPROP/></red>
        <green><VALUEORPROP/></green>
        <blue><VALUEORPROP/></blue>
        <alpha><VALUEORPROP/></alpha>
      </color>
      <size>
        <VALUEORPROP/>
      </size>
    </end>
    *<life-sec> = the time the particles will be alive, in seconds
      <VALUEORPROP/>
    *</life-sec>
    *<radius-m>float</radius-m> = each particles is physically treated as a sphere
                                  with this radius
    *<mass-kg>float</mass-kg> = mass in KG
  </particle>
  <program> = defines external forces acting upon a particle
    <fluid>string<fluid> = can be "air" or "water"
    <gravity>bool</gravity> = can be "true" or "false". uses standard gravity
    <wind>bool</wind> = can be "true" or "false". uses user position wind (not the
                        model position, but shouldn't be noticeable, you want to
                        disabled it when using local attach)
  </program>
</particles>

Remarks:
* Don't forget you can use existing animations with particles, so if you want to
  direct or translate the emitter, just use translate, rotate, spin and so on
  (other animations might have interesting effects too I guess)

* Particle XML should be compatible with plib, as the tags will be ignored (you
  might get some warning if you attach them to animations though)

* Try not to use a lot of particles in a way that fills the screen, that will demand
  lots of fill rate and hurt FPS

* If you don't use any properties nor conditions, your particle system doesn't need
  to use a callback a so it's slightly better on the CPU (mostly useful for static models)

* If your particle lifetime is too big you might run out of particles temporarily
  (still being investigated)

* Use mass and size(radius) to adjust the reaction to gravity and wind
  (mass/size = density)

* Although at the moment severe graphical bugs can be seen in the trails,
  they are usable.

* Consider your options correctly! You should consider giving them no initial
  velocity and most important, no spread, otherwise particles will race and the
  trail will fold. Start simple (no velocities and forces) and work your way up.

--- End of README.xmlparticles ---


--- Start of README.xmlsound ---

Users Guide to FlightGear sound configuration
Version 0.9.8, October 30, 2005
Author: Erik Hofman <erik at ehofman dot com>

This document is an attempt to describe the configuration of
FlightGear flight simulator's aircraft sound in XML.

Sound Architecture:
------------------
All of the sound configuration files are XML-encoded* property lists.
The root element of each file is always named <PropertyList>. Tags are
almost always found in pairs, with the closing tag having a slash
prefixing the tag name, i.e </PropertyList>. The exception is the tag
representing an aliased property. In this case a slash is prepended to
the closing angle bracket.  (see section Aliasing)

The top level sound configuration file is composed of a <fx>, a
<name>, a <path> sound file and zero or more <volume> and/or <pitch>
definitions.

[ Paths are relative to $FG_ROOT (the root of the installed base package .) ]
[ Absolute paths may be used. Comments are bracketed with <!-- -->.         ]

A limited sound configuration file would look something like this:

<PropertyList>
 <fx>
  <engine>
   <name>engine</name>
   <path>Sounds/wasp.wav</path>
   <mode>looped</mode>
   <condition>
    <property>/engines/engine/running</property>
   </condition>
   <volume>
    <property>/engines/engine/mp-osi</property>
    <factor>0.005</factor>
    <min>0.15</min>
    <max>0.5</max>
    <offset>0.15</offset>
   </volume>
   <pitch>
    <property>/engines/engine/rpm</property>
    <factor>0.0012</factor>
    <min>0.3</min>
    <max>5.0</max>
    <offset>0.3</offset>
   </pitch>
  </engine>
 </fx>
</PropertyList>

This would define an engine sound event handler for a piston engine driven
aeroplane. The sound representing the engine is located in $FG_ROOT/Sounds
and is named wasp.wav. The event is started when the property
/engines/engine/running becomes non zero. 

When that happens, the sound will be played looped (see <mode>) until the
property returns zero again. As you can see the volume is mp-osi dependent,
and the pitch of the sound depends on the engine rpm.

Configuration description:
-------------------------
   
<fx>
        Named FX subtree living under /sim/sound
 
 < ... >
        This is the event separator. The text inside the brackets
        can be anything. Bit it is advised to give it a meaningful name
        like: crank, engine, rumble, gear, squeal, flap, wind or stall
 
        The value can be defined multiple times, thus anything which is
        related may have the same name (grouping them together).
 
   <name>
        This defines the name of the event. This name is used internally
        and, although it can me defined multiple times in the same file,
        should normally have an unique value.
 
        Multiple definitions of the same name will allow multiple sections
        to interfere in the starting and stopping of the sample.

        This method can't be used to control the pitch or volume of the 
        sample, but instead multiple volume or pitch section should be
        included inside the same event.

        The types "raise" and "fall" will stop the playback of the sample
        regardless of any other event. This means that when the type "raise"
        is supplied, sample playback will stop when the event turns false.
        Using the type "fall" will stop playback when the event turns true.

        IMPORTANT:
        If the trigger is used for anything else but stopping the sound
         at a certain event, all sections with the same name *should* have
        exactly the same sections for everything but property and type.

        In the case of just stopping the sample at a certain event, the
        sections for path, volume and pitch may be omitted.

   <path>
        This defined th path to the sound file. The path is relative to the
        FlightGear root directory but could be specified absolute.

   <condition>
        Define a condition that triggers the event.
        For a complete description of the FlightGear conditions,
        please read docs-mini/README.conditions

        An event should define either a condition or a property.
 
   <property>
        Define which property triggers the event, and refers to a node
        in the FlightGear property tree. Action is taken when the property
        is non zero.

        A more sophisticated mechanism to trigger the event is described
        in <condition>
 
   <mode>
        This defines how the sample should be played:
 
        once:           the sample is played once.
                        this is the default.
 
        looped:         the sample plays continuously,
                        until the event turns false.

        in-transit:     the sample plays continuously,
                        while the property is changing its value.

  <type>
        This defines the type os this sample:

        fx:             this is the default type and doesn't need to be defined.

        avionics:       sounds set to this time don't have a position and
                        orientation but are treated as if it's mounted to
                        the aircraft panel. it's up to the user to define
                        if it can always be heard or only when in cockpit
                        view.
   
   <volume> / <pitch>
        Volume or Pitch definition. Currently there may be up to 5
        volume and up to 5 pitch definitions defined within one sound
        event. 

        The volume elements are processed as follows

          total_offset = 0
          total_volume = 1.0

          for each <volume> element:

            (a) Use either <property> or <internal> as the base value
            (b) apply any <type> function to the value
            (c) value = value * factor
            (d) value = max(value, <max>)
            (e) value = min(value, <min>)
            (f) if <factor> was originally negative then use
                offset-mode otherwise use normal mode

                (normal-mode) 
                  total_offset = total_offset + offset
                  total_volume = total_volume * value

                (offset-mode) 
                  value = value + offset
                  total_volume = total_volume * value

        Then after processing all of the <volume> blocks the total
        volume will be determined by

           volume  = total_offset + total_volume;

     <expression>
        Defines the AN SGExpression to be used to calculate the volume 
        or pitch. When an expression is used all other tags in the 
        volume block are ignored. 
        Refs: README.expressions 
              http://wiki.flightgear.org/Expressions     

     <property>
        Property to use for the base value for the calculation.

     <factor>
        Defines the multiplication factor for the property value.

        If factor is negative then it will cause the calculation for
        this element to use the offset-mode as defined above. The
        negative value for the factor will be converted to positive
 
     <offset>
        The offset elements will be summed and added to the to the
        calculated volume from all of the volume blocks, except when
        using offset-mode in which case the offset is directly added
        to the calculated volume within each volume block

     <internal>
        Defines which internal variable should be used for the calculation.

        The value is treated as a floating point number.

        The following internals are available at this time:

        dt_play:        the number of seconds since the sound started playing.

        dt_stop:        the number of seconds after the sound has stopped.
 
     <delay-sec>
        Defines the delay after the volume block becomes active.

        An example would be to have two sounds that relate to a single
        property and the delay-sec element can be used to allow one
        sound to start after the end of the first one simply by
        setting the delay-sec to the duration of the sample.

     <type>
        Defines the function that should be used upon the property
        before it is used for calculating the net result:

        lin:            linear handling of the property value.
                        this is the default.
 
        ln:             convert the property value to a natural logarithmic
                        value before scaling it. Anything below 1 will return
                        zero.
 
        log:            convert the property value to a true logarithmic
                        value before scaling it. Anything below 1 will return
                        zero.

        inv:            inverse linear handling (1/x).

        abs:            absolute handling of the value (always positive).

        sqrt:           calculate the square root of the absolute value
                        before scaling it.
 
     <random>
        Add a bit of randomness to the offset. Only used for pitch.
 
     <min>
        Minimum allowed value.
        This is useful if sounds start to sound funny. Anything lower
        will be truncated to this value.
 
     <max>
        Maximum allowed value.
        This is useful if sounds gets to loud. Anything higher will be
        truncated to this value.

   <position>
        Specify the position of the sounds source relative to the
        aircraft center.  The coordinate system used is a left hand
        coordinate system where +Y = left, -Y = right, -Z = down, +Z =
        up, -X = forward, +X = aft.  Distances are in meters.
        The volume calculation due to distance and orientation of the
        sounds source ONLY work on mono samples!

     <x>
        X dimension offset

     <y>
        Y dimension offset

     <z>
        Z dimension offset


   <orientation>
        Specify the orientation of the sounds source.

        The zero vector is default, indicating that a Source is not directional.
        Specifying a non-zero vector will make the Source directional in
        the X,Y,Z direction

     <x>
        X dimension

     <y>
        Y dimension

     <z>
        Z dimension

     <inner-angle>
        The inner edge of the audio cone in degrees (0.0 - 180.0).
        Any sound withing that angle will be played at the current gain.

     <outer-angle>
        The outer edge of the audio cone in degrees (0.0 - 180.0).
        Any sound beyond the outer cone will be played at "outer-gain" volume.

     <outer-gain>
        The gain at the outer edge of the cone.


   <reference-dist>
        Set a reference distance of sound in meters. This is the
        distance where the volume is at its maximum.
        Volume is clamped to this maximum for any distance below.
        Volume is attenuated for any distance above.
        Attenuation depends on reference and maximum distance. See
        OpenAL specification on "AL_INVERSE_DISTANCE_CLAMPED" mode
        for details on exact computation.

   <max-dist>
        Set the maximum audible distance for the sound in meters.
        Sound is cut-off above this distance.


Creating a configuration file:
------------------------------

To make things easy, there is a default value for most entries to allow a
sane configuration when a certain entry is omitted.

Default values are:

type:   lin
factor: 1.0
offset: 0.0 for volume, 1.0 for pitch
min:    0.0
max:    0.0 (don't check)

 
 
Calculations are made the following way (for both pitch and volume):
 
   value = 0;
   offs = 0;

   for (n = 0;  n < max; n++) {
      if (factor < 0)
      {
         value += offset[n] - abs(factor[n]) * function(property[n]);
      }
      else
      {
          value += factor[n] * function(property[n]);
          offs += offset[n];
      }
   }

   volume = offs + value;

where function can be one of: lin, ln, log, inv, abs or sqrt

--- End of README.xmlsound ---


--- Start of README.xmlsyntax ---

XML IN FIFTEEN MINUTES OR LESS

Written by David Megginson, david@megginson.com
Last modified: $Date$

This document is in the Public Domain and comes with NO WARRANTY!


1. Introduction
---------------

FlightGear uses XML for much of its configuration.  This document
provides a minimal introduction to XML syntax, concentrating only on
the parts necessary for writing and understanding FlightGear
configuration files.  For a full description, read the XML
Recommendation at 

  http://www.w3.org/TR/

This document describes general XML syntax.  Most of the XML
configuration files in FlightGear use a special format called
"Property Lists" -- a separate document will describe the specific
features of the property-list format.


2. Elements and Attributes
--------------------------

An XML document is a tree structure with a single root, much like a
file system or a recursive, nested list structure (for LISP fans).
Every node in the tree is called an _element_: the start and end of
every element is marked by a _tag_: the _start tag_ appears at the
beginning of the element, and the _end tag_ appears at the end.

Here is an example of a start tag: 

  <foo>

Here is an example of an end tag:

  </foo>

Here is an example of an element:

  <foo>Hello, world!</foo>

The element in this example contains only data element, so it is a
leaf node in the tree.  Elements may also contain other elements, as
in this example:

  <bar>
   <foo>Hello, world!</foo>
   <foo>Goodbye, world!</foo>
  </bar>

This time, the 'bar' element is a branch that contains other, nested
elements, while the 'foo' elements are leaf elements that contain only
data.  Here's the tree in ASCII art (make sure you're not using a
proportional font):

  bar +-- foo -- "Hello, world!"
      |
      +-- foo -- "Goodbye, world!"

There is always one single element at the top level: it is called the
_root element_.  Elements may never overlap, so something like this is
always wrong (try to draw it as a tree diagram, and you'll understand
why):

  <a><b></a></b>

Every element may have variables, called _attributes_, attached to
it.  The attribute consists of a simple name=value pair in the start
tag:

  <foo type="greeting">Hello, world!</foo>

Attribute values must be quoted with '"' or "'" (unlike in HTML), and
no two attributes may have the same name.

There are rules governing what can be used as an element or attribute
name.  The first character of a name must be an alphabetic character
or '_'; subsequent characters may be '_', '-', '.', an alphabetic
character, or a numeric character.  Note especially that names may not
begin with a number.


3. Data
-------

Some characters in XML documents have special meanings, and must
always be escaped when used literally:

  <  &lt;
  &  &amp;
  
Other characters have special meanings only in certain contexts, but
it still doesn't hurt to escape them:

  >  &gt;
  '  &apos;
  "  &quot;

Here is how you would escape "x < 3 && y > 6" in XML data:

  x &lt; 3 &amp;&amp; y &gt; 6

Most control characters are forbidden in XML documents: only tab,
newline, and carriage return are allowed (that means no ^L, for
example).  Any other character can be included in an XML document as a
character reference, by using its Unicode value; for example, the
following represents the French word "cafe" with an accent on the
final 'e':

  caf&#233;

By default, 8-bit XML documents use UTF-8, **NOT** ISO 8859-1 (Latin
1), so it's safest always to use character references for characters
above position 127 (i.e. for non-ASCII).

Whitespace always counts in XML documents, though some specific
applications (like property lists) have rules for ignoring it in some
contexts.


4. Comments
-----------

You can add a comment anywhere in an XML document except inside a tag
or declaration using the following syntax:

  <!-- comment -->

The comment text must not contain "--", so be careful about using
dashes.


5. XML Declaration
------------------

Every XML document may begin with an XML declaration, starting with
"<?xml" and ending with "?>".  Here is an example:

  <?xml version="1.0" encoding="UTF-8"?>

The XML declaration must always give the XML version, and it may also
specify the encoding (and other information, not discussed here).
UTF-8 is the default encoding for 8-bit documents; you could also try

  <?xml version="1.0" encoding="ISO-8859-1"?>

to get ISO Latin 1, but some XML parsers might not support that
(FlightGear's does, for what it's worth).


6. Other Stuff
--------------

There are other kinds of things allowed in XML documents.  You don't
need to use them for FlightGear, but in case anyone leaves one lying
around, it would be useful to be able to recognize it.

XML documents may contain different kinds of declarations starting
with "<!" and ending with ">":

  <!DOCTYPE html SYSTEM "html.dtd">

  <!ELEMENT foo (#PCDATA)>

  <!ENTITY myname "John Smith">

and so on.  They may also contain processing instructions, which look
a bit like the XML declaration:

  <?foo processing instruction?>

Finally, they may contain references to _entities_, like the ones used
for escaping special characters, but with different names (we're
trying to avoid these in FlightGear):

  &chapter1;

  &myname;


Enjoy.

--- End of README.xmlsyntax ---


--- Start of README.yasim ---

Coordinate system notes: All positions specified are in meters (which
is weird, since all other units in the file are English).  The X axis
points forward, Y is left, and Z is up.  Take your right hand, and
hold it like a gun.  Your first and second fingers are the X and Y
axes, and your upwards-pointing thumb is the Z.  This is slightly
different from the coordinate system used by JSBSim.  Sorry.  The
origin can be placed anywhere, so long as you are consistent.  I use
the nose of the aircraft.

XML Elements
------------

airplane: The top-level element for the file.  It contains only one
          attribute:
          mass: The empty (no fuel) weight, in pounds.

approach: The approach parameters for the aircraft.  The solver will
          generate an aircraft that matches these settings.  The element
          can (and should) contain <control> elements indicating pilot
          input settings, such as flaps and throttle, for the
          approach.
          speed: The approach airspeed, in knots TAS.
          aoa:   The approach angle of attack, in degrees
          fuel:  Fraction (0-1) of fuel in the tanks.  Default is 0.2.

cruise:   The cruise speed and altitude for the solver to match.  As
          above, this should contain <control> elements indicating
          aircraft configuration.  Especially, make sure the engines
          are generating enough thrust at cruise!
          speed: The cruise speed, in knots TAS.
          alt:   The cruise altitude, in feet MSL.
          fuel:  Fraction (0-1) of fuel in the tanks.  Default is 0.2.

cockpit:  The location of the cockpit (pilot eyepoint).
          x,y,z: eyepoint location (see coordinates note)

fuselage: This defines a tubelike structure.  It will be given an even
          mass and aerodynamic force distribution by the solver.  You
          can have as many as you like, in any orientation you please.
          ax,ay,az: One end of the tube (typically the front)
          bx,by,bz: The other ("back") end.
          width:    The width of the tube, in meters.
          taper:    The approximate radius at the "tips" of the fuselage
                    expressed as a fraction (0-1) of the width value.
          midpoint: The location of the widest part of the fuselage,
                    expressed as a fraction of the distance between A and B.
          idrag:    Multiplier for the "induced drag" generated by this
                    object. Default is one. With idrag=0 the fuselage
                    generates only drag.
          cx,cy,cz: Factors for the generated drag in the fuselages "local
                    coordinate system" with x pointing from end to front,
                    z perpendicular to x with y=0 in the aircraft coordinate
                    system. E.g. for a fuselage of a height of 2 times the
                    width you can define cy=2 and (due to the doubled front
                    surface) cx=2.

wing:     This defines the main wing of the aircraft.  You can have
          only one (but see below about using vstab objects for extra
          lifting surfaces).  The wing should have a <stall> subelement to
          indicate stall behavior, control surface subelements (flap0,
          flap1, spoiler, slat) to indicate what and where the control
          surfaces are, and <control> subelements to map user input
          properties to the control surfaces.
          x,y,z:     The "base" of the wing, specified as the location of
                     the mid-chord (not leading edge, trailing edge, or
                     aerodynamic center) point at the root of the LEFT
                     (!)  wing.
          length:    The length from the base of the wing to the midchord
                     point at the tip.  Note that this is not the same
                     thing as span.
          chord:     The chord of the wing at its base, along the X axis
                     (not normal to the leading edge, as it is
                     sometimes defined).
          incidence: The incidence angle at the wing root, in degrees.
                     Zero is level with the fuselage (as in an
                     aerobatic plane), positive means that the leading
                     edge is higher than the trailing edge (as in a
                     trainer).
          twist:     The difference between the incidence angle at the
                     wing root and the incidence angle at the wing
                     tip.  Typically, this is a negative number so
                     that the wing tips have a lower angle of attack
                     and stall after the wing root (washout).
          taper:     The taper fraction, expressed as the tip chord
                     divided by the root chord.  A taper of one is a
                     hershey bar wing, and zero would be a wing ending
                     at a point.  Defaults to one.
          sweep:     The sweep angle of the wing, in degrees.  Zero is
                     no sweep, positive angles are swept back.
                     Defaults to zero.
          dihedral:  The dihedral angle of the wing.  Positive angles
                     are upward dihedral.  Defaults to zero.
          idrag:     Multiplier for the "induced drag" generated by this
                     surface.  In general, low aspect wings will
                     generate less induced drag per-AoA than high
                     aspect (glider) wings.  This value isn't
                     constrained well by the solution process, and may
                     require tuning to get throttle settings correct in
                     high AoA (approach) situations.
          camber:    The lift produced by the wing at zero angle of
                     attack, expressed as a fraction of the maximum
                     lift produced at the stall AoA.

hstab:    These defines the horizontal stabilizer of the aircraft.
          Internally, it is just a wing object and therefore works the
          same in XML.  You are allowed only one hstab object; the
          solver needs to know which wing's incidence to play with to
          get the aircraft trimmed correctly.

vstab:    A "vertical" stabilizer.  Like hstab, this is just another
          wing, with a few special properties.  The surface is not
          "mirrored" as are wing and hstab objects.  If you define a
          left wing only, you'll only get a left wing.  The default
          dihedral, if unspecified, is 90 degrees instead of zero.
          But all parameters are equally settable, so there's no
          requirement that this object be "vertical" at all.  You can
          use it for anything you like, such as extra wings for
          biplanes.  Most importantly, these surfaces are not involved
          with the solver computation, so you can have none, or as
          many as you like.

mstab:    A mirrored horizontal stabilizer. Exactly the same as wing, but
          not involved with the solver computation, so you can have none,
          or as many as you like.

stall:    A subelement of a wing (or hstab/vstab/mstab) that specifies the
          stall behavior.
          aoa:   The stall angle (maximum lift) in degrees.  Note that
                 this is relative to the wing, not the fuselage (since
                 the wing may have a non-zero incidence angle).
          width: The "width" of the stall, in degrees.  A high value
                 indicates a gentle stall.  Low values are viscious
                 for a non-twisted wing, but are acceptable for a
                 twisted one (since the whole wing will not stall at
                 the same time).
          peak:  The height of the lift peak, relative to the
                 post-stall secondary lift peak at 45 degrees.
                 Defaults to 1.5.  This one is deep voodoo, and
                 probably doesn't need to change much.  Bug me for an
                 explanation if you're curious.

flap0, flap1, slat, spoiler:
          These are subelements of wing/hstab/vstab objects, and specify
          the location and effectiveness of the control surfaces.
          start:  The position along the wing where the control
                  surface begins.  Zero is the root, one is the tip.
          end:    The position where the surface ends, as above.
          lift:   The lift multiplier for a flap or slat at full
                  extension.  One is a no-op, a typical aileron might
                  be 1.2 or so, a giant jetliner flap 2.0, and a
                  spoiler 0.0.  For spoilers, the interpretation is a
                  little different -- they spoil only "prestall" lift.
                  Lift due purely to "flat plate" effects isn't
                  affected.  For typical wings that stall at low AoA's
                  essentially all lift is pre-stall and you don't have
                  to care.  Jet fighters tend not to have wing
                  spoilers, for exactly this reason.  This value is
                  not applicable to slats, which affect stall AoA
                  only.
          drag:   The drag multiplier, as above.  Typically should be
                  higher than the lift multiplier for flaps.
          aoa:    Applicable only to slats.  This indicates the
                  angle by which the stall AoA is translated by the
                  slat extension.

thruster: A very simple "thrust only" engine object.  Useful for
          things like thrust vectoring nozzles.  All it does is map
          its THROTTLE input axis to its output thrust rating.  Does
          not consume fuel, etc...
          thrust:   Maximum thrust in pounds
          x,y,z:    The point on the airframe where thrust will be
                    applied.
          vx,vy,vy: The direction of the thrust in airframe
                    coordinates.  The vector will be normalized
                    automatically, so any non-zero vector will work
                    fine.

jet:      A turbojet/fan engine.  It accepts a <control> subelement to map a
          property to its throttle setting, and an <actionpt> subelement
          to place the action point of the thrust at a different
          position than the mass of the engine.
          x,y,z:          The location of the engine, as a point mass.
                          If no actionpt is specified, this will also
                          be the point of application of thrust.
          mass:           The mass of the engine, in pounds.
          thrust:         The maximum sea-level thrust, in pounds.
          afterburner:    Maximum total thrust with afterburner/reheat,
                          in pounds [defaults to "no additional
                          thrust"].
          rotate:         Vector angle of the thrust in degrees about the
                          Y axis [0].
          n1-idle:        Idling rotor speed [55].
          n1-max:         Maximum rotor speed [102].
          n2-idle:        Idling compressor speed [73].
          n2-max:         Maximum compressor speed [103].
          tsfc:           Thrust-specific fuel consumption [0.8].
                          This should be considerably lower for modern
                          turbofans.
          egt:            Exhaust gas temperature at takeoff [1050].
          epr:            Engine pressure ratio at takeoff [3.0].
          exhaust-speed:  The maximum exhaust speed in knots [~1555].
          spool-time:     Time, in seconds, for the engine to respond to
                          90% of a commanded power setting.

propeller: A propeller.  This element requires an engine subtag.
           Currently <piston-engine> and <turbine-engine> are
           supported.
           x,y,z:         The position of the mass (!) of the
                          engine/propeller combination.  If the point
                          of force application is different (and it
                          will be) it should be set with an <actionpt>
                          subelement.
           mass:          The mass of the engine/propeller, in pounds.
           moment:        The moment, in kg-meters^2.  This has to be
                          hand calculated and guessed at for now.  A
                          more automated system will be forthcoming.
                          Use a negative moment value for
                          counter-rotating ("European" -- CCW as seen
                          from behind the prop) propellers.
                          A good guess for this value is the radius of
                          the prop (in meters) squared times the mass
                          (kg) divided by three; that is the moment of
                          a plain "stick" bolted to the prop shaft.
           radius:        The radius, in meters, or the propeller.
           cruise-speed:  The max efficiency cruise speed of the
                          propeller.  Generally not the same as the
                          aircraft's cruise speed.
           cruise-rpm:    The RPM of the propeller at max-eff. cruise.
           cruise-power:  The power sunk by the prop at cruise, in horsepower.
           cruise-alt:    The reference cruise altitude in feet.
           takeoff-power: The takeoff power required by the propeller...
           takeoff-rpm:   ...at the given takeoff RPM.
           min-rpm:       The minimum operational RPM for a constant speed
                          propeller.  This is the speed to which the
                          prop governor will seek when the blue lever
                          is at minimum.  The coarse-stop attribute
                          limits how far the governor can go into trying
                          to reach this RPM.
           max-rpm:       The maximum operational RPM for a constant speed
                          propeller.  See above.  The fine-stop attribute
                          limits how far the governor can go in trying
                          to reach this RPM.
           fine-stop:     The minimum pitch of the propeller (high RPM) as a
                          ratio of ideal cruise pitch.  This is set to 0.25
                          by default -- a higher value will result in a
                          lower RPM at low power settings (e.g. idle, taxi,
                          and approach).
           coarse-stop:   The maximum pitch of the propeller (low RPM) as
                          a ratio of ideal cruise pitch.  This is set to
                          4.0 by default -- a lower value may result in a
                          higher RPM at high power settings.
           gear-ratio:    The factor by which the engine RPM is multiplied
                          to produce the propeller RPM.  Optional (defaults
                          to 1.0).
           contra:        When set (contra="1"), this indicates that the
                          propeller is a contra-rotating pair.  It
                          will not contribute to the aircraft's net
                          gyroscopic moment, nor will it produce
                          asymmetric torque on the aircraft body.
                          Asymmetric slipstream effects, when
                          implemented, will also be zero when this is
                          set.

piston-engine: A piston engine definition.  This must be a subelement
               of an enclosing <propeller> tag.
               eng-power:    Maximum BHP of the engine at sea level.
               eng-rpm:      The engine RPM at which eng-power is developed
               displacement: The engine displacement in cubic inches.
               compression:  The engine compression ratio.
               turbo-mul:    The turbo/super-charger pressure multiplier.
                             Static pressure will be multiplied by this
                             value to get the manifold pressure.
               wastegate-mp: The maximum manifold pressure.  Beyond
                             this, the gate will release to keep the
                             MP below this number. (inHG).  This value
                             can be changed at runtime using the
                             WASTEGATE control axis, which is a
                             multiplier in the range [0:1].
               turbo-lag:    Time lag, in seconds, for 90% of a power change
                             to be reflected in the turbocharger boost
                             pressure.

turbine-engine: A turbine engine definition.  This must be a subelement
                of an enclosing <propeller> tag.
                eng-power:   Maximum BHP of the engine at a suitable
                             cruise altitude.
                eng-rpm:     The engine RPM at which eng-power is
                             developed.  Note that this is "shaft" RPM
                             as seen by the propeller.  Don't use a
                             gear-ratio on the enclosing propeller, or
                             else you'll get confused. :)
                alt:         The altitude at which eng-power is developed.
                             This should be high enough to be lower (!)
                             than the flat-rating power.
                flat-rating: The maximum allowed power developed by
                             the engine.  Most turboprops are flat
                             rated below a certain altitude and
                             temperature range to prevent engine
                             damage.
                min-n2:      N2 (percent) turbine speed at zero throttle.
                max-n2:      N2 (percent) turbine speed at max throttle.
                bsfc:        Specific fuel consumption, in lbs/hr per
                             horsepower.


actionpt: Defines an "action point" for an enclosing jet or propeller
          element.  This is the location where the force from the thruster
          will be applied.
          x,y,z:  The location of force application.

gear:     Defines a landing gear.  Accepts <control> subelements to map
          properties to steering and braking. Can also be used to simulate
          floats. Although the coefficients are still called ..fric, it
          is calculated in fluids as a drag (proportional to the square
          of the speed). In fluids gears are not considered to detect
          crashes (as on ground).
          x,y,z:  The location of the fully-extended gear tip.
          compression:  The distance in meters along the "up" axis that
                        the gear will compress.
          initial-load: The initial load of the spring in multiples of
                        compression. Defaults to 0. (With this parameter
                        a lower spring-constants will be used for the
                        gear-> can reduce numerical problems (jitter))
                        Note: the spring-constant is varied from 0%
                        compression to 20% compression to get continuous
                        behavior around 0 compression. (could be physically
                        explained by wheel deformation)
          upx/upy/upz:  The direction of compression, defaults to
                        vertical (0,0,1) if unspecified.  These are
                        used only for a direction -- the vector need
                        not be normalized, as the length is specified
                        by "compression".
          sfric:        Static (non-skidding) coefficient of
                        friction.  Defaults to 0.8.
          dfric:        Dynamic friction.  Defaults to 0.7.
          spring:       A dimensionless multiplier for the automatically
                        generated spring constant.  Increase to make
                        the gear stiffer, decrease to make it
                        squishier.
          damp:         A dimensionless multiplier for the automatically
                        generated damping coefficient.  Decrease to
                        make the gear "bouncier", increase to make it
                        "slower".  Beware of increasing this too far:
                        very high damping forces can make the numerics
                        unstable.  If you can't make the gear stop
                        bouncing with this number, try increasing the
                        compression length instead.
          on-water:     if this is set to "0" the gear will be ignored if
                        on water. Defaults to "0"
          on-solid:     if this set to "0" the gear will be ignored if
                        not on water. Defaults to "1"
          speed-planing:
          spring-factor-not-planing:
                        At zero speed the spring factor is multiplied by
                        spring-factor-not-planing. Above speed-planing this
                        factor is equal to 1. The idea is, to use this for
                        floats simulating the transition from swimming to
                        planing. speed-planing defaults to 0,
                        spring-factor-not-planing defaults to 1.
          reduce-friction-by-extension: at full extension the friction is
                        reduced by this relative value. 0.7 means 30% friction
                        at full extension. If you specify a value greater
                        than one, the friction will be zero before reaching
                        full extension. Defaults to "0"
          ignored-by-solver: with the on-water/on-solid tags you can have more
                        than one set of gears in one aircraft, If the solver
                        (who automatically generates the spring constants)
                        would take all gears into account, the result would be
                        wrong. E. G. set this tag to "1" for all gears, which
                        are not active on runways. Defaults to "0". You can
                        not exclude all gears in the solving process.

launchbar: Defines a catapult launchbar or strop. The default acceleration
            provided by the catapult is 25m/s^2. This can be
            modified by the use of the control axis LACCEL.
           x,y,z:      The location of the mount point of the launch bar or
                       strop on the aircraft.
           length:     The length of the launch bar from mount point to tip
           down-angle: The max angle below the horizontal the
                       launchbar can achieve.
           up-angle:   The max angle above the horizontal the launchbar
                       can achieve.
           holdback-{x,y,z}: The location of the holdback mount point
                             on the aircraft.
           holdback-length: The length of the holdback from mount
                            point to tip.  Note: holdback up-angle and
                            down-angle are the same as those defined
                            for the launchbar and are not specified in
                            the configuration.

tank:     A fuel tank.  Tanks in the aircraft are identified
          numerically (starting from zero), in the order they are
          defined in the file.  If the left tank is first, "tank[0]"
          will be the left tank.
          x,y,z:    The location of the tank.
          capacity: The maximum contents of the tank, in pounds.  Not
                    gallons -- YASim supports fuels of varying
                    densities.
          jet:      A boolean.  If present, this causes the fuel
                    density to be treated as Jet-A.  Otherwise,
                    gasoline density is used.  A more elaborate
                    density setting (in pounds per gallon, for
                    example) would be easy to implement.  Bug me.

ballast:  This is a mechanism for modifying the mass distribution of
          the aircraft.  A ballast setting specifies that a particular
          amount of the empty weight of the aircraft must be placed at
          a given location.  The remaining non-ballast weight will be
          distributed "intelligently" across the fuselage and wing
          objects.  Note again: this does NOT change the empty weight
          of the aircraft.
          x,y,z: The location of the ballast.
          mass:  How much mass, in pounds, to put there.  Note that
                 this value can be negative.  I find that I often need
                 to "lighten" the tail of the aircraft.

weight:   This is an added weight, something not part of the empty
          weight of the aircraft, like passengers, cargo, or external
          stores.  The actual value of the mass is not specified here,
          instead, a mapping to a property is used.  This allows
          external code, such as the panel, to control the weight
          (loading a given cargo configuration from preference files,
          dropping bombs at runtime, etc...)
          x,y,z:      The location of the weight.
          mass-prop:  The name of the fgfs property containing the
                      mass, in pounds, of this weight.
          size:       The aerodynamic "size", in meters, of the
                      object.  This is important for external stores,
                      which will cause drag.  For reasonably
                      aerodynamic stuff like bombs, the size should be
                      roughly the width of the object.  For other
                      stuff, you're on your own.  The default is zero,
                      which results in no aerodynamic force (internal
                      cargo).

solve-weight:
          Subtag of approach and cruise parameters.  Used to specify a
          non-zero setting for a <weight> tag during solution.  The
          default is to assume all weights are zero at the given
          performance numbers.
          idx:    Index of the weight in the file (starting with zero).
          weight: Weight setting in pounds.


control-input:
          This element manages a mapping from fgfs properties (user
          input) to settable values on the aircraft's objects.  Note
          that the value to be set MUST (!) be valid on the given
          object type.  This is not checked for by the parser, and
          will cause a runtime crash if you try it.  Wing's don't have
          throttle controls, etc...  Note that multiple axes may be
          set on the same value.  They are summed before setting.

          axis:  The name of the double-valued fgfs property "axis" to
                 use as input, such as "/controls/flight/aileron".
          control: Which control axis to set on the objects.  It can have
                   the following values:
                  THROTTLE - The throttle on a jet or propeller.
                  MIXTURE - The mixture on a propeller.
                  REHEAT - The afterburner on a jet
                  PROP - The propeller advance
                  BRAKE - The brake on a gear.
                  STEER - The steering angle on a gear.
                  INCIDENCE - The incidence angle of a wing.
                  FLAP0 - The flap0 deflection of a wing.
                  FLAP1 - The flap1 deflection of a wing.
                  FLAP[0/1]EFFECTIVENESS - a multiplier for flap lift, but not drag
                                           (useful for blown flaps)
                  SLAT - The slat extension of a wing.
                  SPOILER - The spoiler extension for a wing.
                  CYCLICAIL - The "aileron" cyclic input of a rotor
                  CYCLICELE - The "elevator" cyclic input of a rotor
                  COLLECTIVE - The collective input of a rotor
                  ROTORENGINEON - If not equal zero the rotor is rotating
                  WINCHRELSPEED - The relative winch speed
          LACCEL - The acceleration provided by the catapult.
                  {... and many more, see FGFDM.cpp ...}
          invert: Negate the value of the property before setting on
                  the object.
          split:  Applicable to wing control surfaces.  Sets the
                  normal value on the left wing, and a negated value
                  on the right wing.
          square: Squares the value before setting.  Useful for
                  controls like steering that need a wide range, yet
                  lots of sensitivity in the center.  Obviously only
                  applicable to values that have a range of [-1:1] or
                  [0:1].
          src0/src1/dst0/dst1:
                  If present, these defined a linear mapping from the
                  source to the output value.  Input values in the
                  range src0-src1 are mapped linearly to dst0-dst1,
                  with clamping for input values that lie outside the
                  range.

control-output:
          This can be used to pass the value of a YASim control axis
          (after all mapping and summing is applied) back to the
          property tree.

          control: Name of the control axis.  See above.
          prop:    Property node to receive the value.
          side:    Optional, for split controls.  Either "right" or "left"
          min/max: Clamping applied to output value.

control-speed:
          Some controls (most notably flaps and hydraulics) have
          maximum slew rates and cannot respond instantly to pilot
          input.  This can be implemented with a control-speed tag,
          which defines a "transition time" required to slew through
          the full input range.  Note that this tag is
          semi-deprecated, complicated control input filtering can be
          done much more robustly from a Nasal script.

          control: Name of the control axis. See above.
          transition-time: Time in seconds to slew through input range.

control-setting:
          This tag is used to define a particular setting for a
          control axis inside the <cruise> or <approach> tags, where
          obviously property input is not available.  It can be used,
          for example, to inform the solver that the approach
          performance values assume full flaps, etc...

          axis:  Name of the control input (i.e. a property name)
          value: Value of the control axis.

hitch:    A hitch, can be used for winch-start (in gliders) or aerotow (in
          gliders and motor aircrafts) or for external cargo with helicopter.
          You can do aerotow over the net via multiplayer (see j3 and bocian
          as an example).

          name:  the name of the hitch. must be aerotow if you want to do
                 aerotow via multiplayer. You will find many properties
                 at /sim/hitches/name. Most of them are directly tied to
                 the internal variables, you can modify them as you like.
                 You can add a listener to the property "broken", e. g. for
                 playing a sound.
          x,y,z: The position of the hitch
          force-is-calculated-by-other: if you want to simulate aerotowing
                 over the internet, set this value to "1" in the motor
                 aircraft. Don't specify or set this to zero in gliders.
                 In a LAN the time lag might be small enough to set it on
                 both aircrafts to "0". It's intended, that this is done
                 automatically in the future.

tow: The tow used for aerotow or winch. This must be a subelement
               of an enclosing <hitch> tag.
          length: upstretched length in m
          weight-per-meter: in kg/m
          elastic-constant: lower values give higher elasticity
          break-force: in N
          mp-auto-connect-period: the every x seconds a towed multiplayer
                 aircraft is searched. If found, this tow is connected
                 automatically, parameters are copied from the other
                 aircraft. Should be set only in the motor aircraft, not
                 in the glider

winch: The tow used for aerotow or winch. This must be a subelement
               of an enclosing <hitch> tag.
          max-tow-length:
          min-tow-length:
          initial-tow-length: all are in m. The initial tow length also
                 defines the length/search radius used for the mp-autoconnect
                 feature
          max-winch-speed: in m/s
          power: in kW
          max-force: in N


rotor:    A rotor. Used for simulating helicopters. You can have one, two
          or even more.
          There is a drawing of a rotor in the Doc-directory
          (README.yasim.rotor.png) Please find the measures from this drawing
          for several parameters in square brackets [].
          If you specify a rotor, you do not need to specify a wing or hstab,
          the settings for approach and cruise will be ignored then. You have
          to specify the solver results manually. See below.
          The rotor generates downwash acting on all stabs, surfaces and
          fuselages. For all fuselages in the rotor downwash you should
          specify idrag="0" to get realistic results.

          name:    The name of the rotor.
                   (some data is stored at /rotors/name/)
                   The rpm, cone angle, yaw angle and roll angle are stored
                   for the complete rotor. For every blade the position
                   angle, the flap angle and the incidence angle are stored.
                   All angles are in degree, positive values always mean "up".
                   This is not completely tested, but seem to work at least
                   for rotors rotating counterclockwise.
                   A value stall gives the fraction of the rotor in stall
                   (weighted by the fraction the have on lift and drag
                   without stall). Use this for modifying the rotor-sound.
          x,y,z:   The position of the rotor center
          nx,ny,nz: The normal of the rotor (pointing upwards, will be
                   normalized by the computer)
          fx,fy,fz: A Vector pointing forward, if not perpendicular to the
                   normal it will be corrected by the computer
          diameter: The diameter in meter [D]
          numblades: The number of blades
          weightperblade: The weight per blade in pounds
          relbladecenter: The relative center of gravity of the blade. Maybe
                   not 100% correct interpreted; use 0.5 for the start and
                   change in small steps [b/R]
          chord:     The chord of the blade its base, along the X axis
                     (not normal to the leading edge, as it is
                     sometimes defined). [c]
          twist:     The difference between the incidence angle at the
                     blade root and the incidence angle at the wing
                     tip.  Typically, this is a negative number so
                     that the rotor tips have a lower angle of attack.
          taper:     The taper fraction, expressed as the tip chord
                     divided by the root chord.  A taper of one is a
                     bar blade, and zero would be a blade ending
                     at a point.  Defaults to one. [d/c]
          rel-len-where-incidence-is-measured: If the blade is twisted,
                     you need a point where to measure the incidence angle.
                     Zero means at the base, 1 means at the tip. Typically
                     it should be something near 0.7
          rel-len-blade-start: Typically the blade is not mounted in the
                   center of the rotor [a/R]
          rpm:     rounds per minute.
          phi0:    initial position of this rotor
          ccw:     determines if the rotor rotates clockwise (="0") or
                   counterclockwise (="1"), (if you look on the top of the
                   normal, so the bo105 has counterclockwise rotor).
                   "true" and "false" are not any longer supported to
                   increase my lifespan. ;-)
          maxcollective: The maximum of the collective incidence in degree
          mincollective: The minimum of the collective incidence in degree
          maxcyclicele: The maximum of the cyclic incidence in degree for
                   the elevator like function
          mincyclicele: The minimum of the cyclic incidence in degree for
                   the elevator like function
          maxcyclicail: The maximum of the cyclic incidence in degree for
                   the aileron like function
          mincyclicail: The minimum of the cyclic incidence in degree for
                   the aileron like function
          airfoil-incidence-no-lift: non symmetric airfoils produces lift
                   with no incidence. This is is the incidence, where the
                   airfoil is producing no lift. Zero for symmetrical airfoils
                   (default)
          incidence-stall-zero-speed:
          incidence-stall-half-sonic-speed: the stall incidence is a function
                   of the speed. I found some measured data, where this is
                   linear over a wide range of speed. Of course the linear
                   region ends at higher speeds than zero, but just
                   extrapolate the linear behavior to zero.
          lift-factor-stall: In stall airfoils produce less lift. Without
                   stall the c-lift of the profile is assumed to be
                   sin(incidence-"airfoil-incidence-no-lift")*liftcoef;
                   And in stall:
                   sin(2*(incidence-"airfoil-incidence-no-lift"))*liftcoef*...
                   ..."lift-factor-stall";
                   Therefore this factor is not the quotient between lift
                   with and without stall. Use 0.28 if you have no idea.
          drag-factor-stall: The drag of an airfoil in stall is larger than
                   without stall.
                   Without stall c-drag is assumed to be
                   abs(sin(incidence-"airfoil-incidence-no-lift"))...
                   ..*dragcoef1+dragcoef0);
                   With stall this is multiplied by drag-factor
          stall-change-over: For incidence<"incidence-stall" there is no stall.
                   For incidence>("incidence-stall"+"stall-change-over") there
                   is stall. In the range between this incidences it is
                   interpolated linear.

          pitch-a:
          pitch-b: collective incidence angles, If you start flightgear
                   with --log-level=info, flightgear reports lift and needed
                   power for theses incidence angles
          forceatpitch-a:
          poweratpitch-b:
          poweratpitch-0: old tokens, not supported any longer, the result are
                   not exactly the expected lift and power values. Will be
                   removed in one of the next updates.directly.Use "real"
                   coefficients instead (see below) and adjust the lift with
                   rotor-correction-factor.

          The airfoil of the rotor is described as follows:
          The way is to define the lift and drag coefficients directly.
          Without stall the c-lift of the profile is assumed to be
                   sin(incidence-"airfoil-incidence-no-lift")*liftcoef;
          And in stall:
                   sin(2*(incidence-"airfoil-incidence-no-lift"))*liftcoef*...
                   ..."lift-factor-stall";
          Without stall c-drag is assumed to be
                   abs(sin(incidence-"airfoil-incidence-no-lift"))...
                   ..*dragcoef1+dragcoef0);
          See above, how the coefficients are defined with stall.
          The parameters:
          airfoil-lift-coefficient: liftcoef
          airfoil-drag-coefficient0: dragcoef0
          airfoil-drag-coefficient1: dragcoef1
                   To find the right values: see README.yasim.rotor.ods
                   (Open Office file) or README.yasim.rotor.xls (Excel
                   file). With theses files you can generate graphs of the
                   airfoil coefficients and adjust the parameters to match
                   real airfoils. For many airfoils you find data published
                   in the internet. Parameters for the airfoils NACA 23012
                   (main rotor of bo105) and NACA 0012 (tail rotor of bo105?)
                   are included.

          rotor-correction-factor:
                   If you calculate the lift of a heli rotor or even of a
                   propeller, you get a value larger than the real measured
                   one. (Due to vortex effects.) This is considered in the
                   simulation, but with a old theory by Prantl, which is known
                   to give still too large. This is corrected by this token,
                   default: 1
          flapmin: Minimum flapping angle. (Should normally never reached)
          flapmax: Maximum flapping angle. (Should normally never reached)
          flap0:   Flapping angle at no rotation, i.e. -5
          dynamic: this changes the reactions speed of the rotor to an input.
                   normally 1 (Maybe there are rotors with a little faster
                   reaction, than use a value a little greater than one.
                   A value greater than one will result in a more inert,
                   system. Maybe it's useful for simulating the rotor of the
                   Bell UH1
          rellenflaphinge: The relative length from the center of the rotor
                   to the flapping hinge. Can be taken from pictures of the
                   helicopter (i.e. 0 for Bell206, about 0.05 for most
                   rotors) For rotors without flapping hinge (where the blade
                   are twisted instead, i.e. Bo 105, Lynx) use a mean value,
                   maybe 0.2. This value has a extreme result in the behavior
                   of the rotor [F/r]
          sharedflaphinge: determines, if the rotor has one central flapping
                   hinge (="1") for the blades (like the Bell206 or the tail
                   rotor of the Bo 105), default is "0".
          delta3: Some rotors have a delta3 effect, which results in a
                   decreasing of the incidence when the rotor is flapping.
                   A value of 0 (as most helicopters have) means no change in
                   incidence, a value of 1 result in a decreases of one degree
                   per one degree flapping.
                   So delta3 is the proportional factor between flapping and
                   decrease of incidence. I.e. the tail rotor of a Bo105 has
                   a delta3 of 1.
                   In some publications delta3 is described by an angle. The
                   value in YASim is the atan of this angle
          delta:   A factor for the damping constant for the flapping. 1 means
                   a analytical result, which is only a approximation. Has a
                   very strong result in the reaction of the rotor system on
                   control inputs.
                   If you know the flapping angle for a given cyclic input you
                   can adjust this by changing this value. Or if you now the
                   maximum roll rate or ...
          translift-maxfactor: Helicopters have "translational lift", which
                   is due to turbulence. In forward flying the rotor gets less
                   turbulence air and produces more lift. The factor is the
                   quotient between lift at high airspeeds to the lift at
                   hover (with same pitch).
          translift-ve: the speed, where the translational lift reaches 1/e of
                   the maximum value. In m/s.
          ground-effect-constant: Near to the ground the rotor produces more
                   torque than in higher altitudes. The ground effect is
                   calculated as
                   factor = 1+diameter/altitude*"ground-effect-constant"
          number-of-parts:
          number-of-segments: The rotor is simulated in "number-of-parts"
                   different directions.
                   In every direction the rotor is simulated at
                   number-of-segments points. If the value is to small, the
                   rotor will react unrealistic. If it is to high, cpu-power
                   will be wasted. I now use a value of 8 for
                   "number-of-parts" and 8 for number-of-segments for the main
                   rotor and 4 for "number-of-parts" and 5 for
                   "number-of-segments" for the tail rotor.
                   "number-of-parts" must be a multiple of 4 (if not, it
                   is corrected)
          cyclic-factor: The response of a rotor to cyclic input is hard to
                   calculate (its a damped oscillator in resonance, some
                   parameters have very large impact to the cyclic response)
                   With this parameter (default 1) you can adjust the
                   simulator to the real helo.
          downwashfactor: A factor for the downwash of the rotor, default 1.
          balance: The balance of the rotor. 1.0: the rotor is 100% balanced,
                   0.0: half of the blades are missing. Use a value near one
                   (0.98 ... 0.999) to add some vibration.
          tiltcenterx:
          tiltcentery:
          tiltcenterz: The center for the tilting of the complete rotorhead/
                       mast. Can be used for simulating of the Osprey or small
                       autogyros.
          mintiltyaw:
          mintiltpitch:
          mintiltroll:
          maxtiltyaw:
          maxtiltpitch:
          maxtiltroll: The limits (in degree) for tilting the rotor head

          All rotor can have <control> subelements for the cyclic
          (CYCLICELE, CYCLICAIL) and collective (COLLECTIVE) input.
          and can have <control> subelements for the tilting the whole rotor
          head around the y-axis (TILTPITCH), the x-axis (TILTROLL) and the
          z-axis (TILTYAW). ROTORBALANCE is a factor for the balance.

rotorgear: If you are using one or more rotors you have to define a
          rotorgear. It connects all the rotors and adds a simple engine.
          In future it will be possible, to add a YASim-engine.
          max-power-engine: the maximum power of the engine, in kW.
          engine-prop-factor: the engine is working as a pd-regulator. This
                   is the width of the regulation-band, or, in other words,
                   the inverse of the proportional-factor of the regulator.
                   If you set it to 0.02, than up to 98% of the rotor-rpm
                   the engine will produce maximum torque. At 100% of
                   the engine will produce no torque.  It is planned to use
                   YASim-engines instead of this simple engine.
          engine-accel-limit: The d-factor of the engine is defined as the
                   maximum acceleration rate of the engine in %/s,
                   default is 5%/s.
          max-power-rotor-brake: the maximum power of the rotor brake, in kW
                   at normal rpm (most? real rotor brakes would be overheated
                   if used at normal rpm, but this is not simulated now)
          rotorgear-friction: the power loss due to friction in kW at normal
                   RPM
          yasimdragfactor:
          yasimliftfactor: the solver is not working with rotor-aircraft.
                   Therefore you have to specify the results yourself.
                   10 for drag and 140 for lift seem to be good starting
                   values. Although the solve is not invoked for aircraft
                   with at least one rotor, you need to specify the cruise
                   and the approach settings. The approach speed is needed to
                   calculate the gear springs. Use a speed of approx. 50knots.
                   They do not need to match any real value.

          The rotorgear needs a <control> subelement for the engine
          (ROTORGEARENGINEON) and can have further <control> subelements:
                   ROTORBRAKE: rotor brake
                   ROTORRELTARGET: the target rpm of the engine relative to
                               the "normal" value for the governor. Default is
                               1.
                   ROTORENGINEMAXRELTORQUE: the maximum torque of the engine
                               relative to the torque defined by the engine-
                               power. Default is 1. By setting the rel-target
                               to a large number you get control over the
                               engine by this control.
                               Alternatively you can use these two values for
                               individual start-up sequences (see the s58)


--- End of README.yasim ---


--- Start of autopush-config.xml.template ---

<PropertyList>
	<steer-cmd-norm	alias="/controls/flight/rudder"/>
	<yaw alias="/gear/gear[0]/steering-norm"/>
	<yaw-mult type="float">MULTIPLIER</yaw-mult>
	<pitch-deg type="float">PITCH</pitch-deg>
	<min-turn-radius-m type="float">MIN_RADIUS</min-turn-radius-m>
	<stopping-distance-m type="float">STOP_DIST</stopping-distance-m>
	<chocks	alias="/controls/gear/wheel-chocks"/>
	<available type="int">1</available>
	<enabled type="int"/>
	<connected type="bool">false</connected>
	<target-speed-km_h type="float">0.0</target-speed-km_h>
	<K_p type="float">0.5</K_p>
	<F_p type="float">0.15</F_p>
	<K_i type="float">0.25</K_i>
	<F_i type="float">0.1</F_i>
	<K_d type="float">0.0</K_d>
	<F_d type="float">0.0</F_d>
	<driver>
		<F_V type="float">8.0</F_V>
		<K_psi type="float">0.03</K_psi>
		<F_psi type="float">1.0</F_psi>
		<K_psidot type="float">0.03</K_psidot>
		<F_psidot type="float">1.0</F_psidot>
	</driver>
	<route>
		<show type="bool"/>
	</route>
	<debug type="int">0</debug>
</PropertyList>

--- End of autopush-config.xml.template ---


--- Start of index.html ---

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>FlightGear Help System</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link rel="stylesheet" type="text/css" href="FGShortRef.css"> 
</head>

<body>
 <a href="http://www.flightgear.org"><img src="img/fglogosm.jpg"></a>
 <h3 class="likesectionHead"><a name="x1-1000"></a>
 <span class="ptmbi7t-x-x-120">FlightGear </span>Help System</h3>
 <p class="noindent"><b>Basic help resources on
 <span class="ptmbi7t-x-x-120">FlightGear</span>:</b>

 <p class="indent"> <a href="http://flightgear.sourceforge.net/manual/2020.3/">The complete manual (online)</a>
  <p class="indent"> <a href="FGShortRef.html">Short reference including key codes</a>
                    (also available as <a href="FGShortRef.pdf">PDF</a>)
 <p class="indent"> <a href="README.Joystick.html">Guide to joystick and keyboard configuration</a>

 <p class="noindent"><b>Information for power users:</b>
 <p class="indent"> <a href="README.local_weather.html">Guide for the Local Weather Package</a>
 <p class="indent"> <a href="README.xmlpanel.html">Guide for panel makers</a>
 <p class="indent"> <a href="README.xmlhud">Guide for HUD makers</a>
 <p class="indent"> <a href="model-howto.html">Guide for using 3D models</a>

 <p class="noindent"><b>Getting more help:</b>
 <p class="indent">Additional documentation can be found in the <a href=".">Docs/</a> folder.
 <p class="indent">Since FGFS has a brisk pace of development, some information may be inaccurate.
 <p class="indent">More information and help is available on the <a href="http://www.flightgear.org/forums">FlightGear Forum</a> and <a href="http://wiki.flightgear.org">FlightGear Wiki</a>.
 <p class="indent">Get new versions, add-ons and more from the website at <a href="http://www.flightgear.org/">www.flightgear.org</a> for free.
<hr>
<font size="-1">
Copyright 1996-2021, The FlightGear Contributors<br>
FlightGear is free and open source software, licensed under the GNU General Public License Version 2.
</font>
</body>
</html> 


--- End of index.html ---


--- Start of model-howto.html ---


<!-- Standard Header Begin -->
<html>

<head>
  <title>FlightGear Flight Simulator</title>
  <link rel="stylesheet" type="text/css" href="../default.css"> 
</head>

<body>
  <div id="top">
    <a href="../"><img id="titlebar" src="../images/fglogosm.jpg" alt=""></a>
  </div>

  <table id="global">
    <tbody><tr>
      <td id="menu">
	<!-- Use a replacescript to update the menu -->
	<h3>About</h3>
	<a href="..">Home</a><br>
      </td>
      <td id="page">
<!-- Standard Header End -->
<h1>Mini-HOWTO: 3D Aircraft Models in FlightGear</h1>

<h2>11 March 2002</h2>
<h2>David Megginson</h2>
<br>

<div>
<h3>Introduction</h3>

<br>This mini-HOWTO explains how to add 3D aircraft models to
FlightGear, and how to animate and position those models.  No C++
programming is required, but the user will need some knowledge of
FlightGear's property system and XML markup, and will need to
understand the coordinate system FlightGear uses for its models:<br>

<ul>
<li>distances are in meters 
<li>angles are in degrees 
<li>the x-axis runs lengthwise, towards the back 
<li>the y-axis runs sideways, towards the right 
<li>the z-axis runs upwards 
<li>heading is a rotation around the z-axis, where 
        positive is clockwise viewed from above 
<li>pitch is a rotation around the y-axis, where 
        positive is clockwise viewed from the left 
<li>roll is a rotation around the x-axis, where positive is clockwise
viewed from behind</li>
</ul>

<img src="img/model-howto-heading.jpg" width="500" height="497" alt="Heading Illiustration">
<img src="img/model-howto-pitch.jpg" width="499" height="349" alt="Pitch Illiustration">
<img src="img/model-howto-roll.jpg" width="500" height="244" alt="Roll Illiustration">

<p>This mini-HOWTO contains three parts:</p>

<ol>
<li><a href="#loading">Loading the model</a>
<li><a href="#repositioning">Repositioning the model</a>
<li><a href="#animating">Animating the model</a></li>
</ol>

<!-- end of "Summary" -->
</div>


<div><a name="loading"></a>
<h3>1. Loading the model</h3>

<p>Through <a href="http://www.openscenegraph.org/">OpenSceneGraph</a>,
FlightGear supports many different 3D file formats, including VRML2,
AC3D, DXF, and
<a href="http://trac.openscenegraph.org/projects/osg/wiki/Support/UserGuides/Plugins">many others</a>.
The property <var>/sim/model/path</var> in the main FlightGear
property tree controls what model will be loaded; it takes
a string value giving the relative path of the model from
<var>FG_ROOT</var> (the root of the base package, such as
<code>/usr/local/lib/FlightGear</code> or
<code>C:\FLIGHTGEAR\</code>).</p>

<p>The easiest way to load a new model is to set the property at
startup with the <var>--prop:</var> command-line option; for example,
to use a 3D aircraft model that you have installed in
<code>$FG_ROOT/Models/my-cessna.wrl</code>, you could invoke
FlightGear like this (under Unix-like systems):</p>

<blockquote><pre>fgfs --prop:/sim/model/path=Models/my-cessna.wrl
</pre></blockquote>

<p>(<strong>Note:</strong> Normaly any textures used by the model must appear
in the same directory.  If <code>my-cessna.wrl</code> uses the
textures <code>cessna01.rgb</code> and <code>cessna02.rgb</code>, you
should install those textures in <code>$FG_ROOT/Models/</code>. 
It is howerever possible to specify a path (relative to the model path)
to specify where the textures could be found.)</p>

<p>When you want to set a 3D model permanently as the default for an
aircraft rather than specifying it on the command line, you need to
edit an aircraft settings file.  In the
<code>$FG_ROOT/Aircraft/</code> directory there is a series of files
ending in <code>-set.xml</code>, such as <code>c172-set.xml</code>,
<code>dc3-yasim-set.xml</code>, and <code>beech99-uiuc-set.xml</code>.
When you start FlightGear with the <var>--aircraft</var> option, it
reads the properties from one of these files; for example</p>

<blockquote><pre>fgfs --aircraft=dc3-yasim
</pre></blockquote>

<p>Loads the properties from
<code>$FG_ROOT/Aircraft/dc3-yasim-set.xml</code> into the main
FlightGear property tree.  These files are in the same XML
property-list format as <code>$FG_ROOT/preferences.xml</code> and the
FlightGear save files.  There may be many XML files with different
startup conditions, sounds, panels, 3D models, etc. for any single
aircraft type, so you are best off copying an existing one, renaming
it, then changing the value inside the <var>path</var> element inside
<var>model</var> inside <var>sim</var>:</p>

<blockquote><pre>&lt;PropertyList&gt;
 &lt;sim&gt;
  &lt;model&gt;
   &lt;path&gt;Models/my-cessna.wrl&lt;/path&gt;
   &lt;texture-path&gt;./Textures&lt;/texture-path&gt;
  &lt;/model&gt;
 &lt;/sim&gt;
&lt;/PropertyList&gt;
</pre></blockquote>

<p>So far, all of the examples have had the <var>/sim/model/path</var>
property point directly at the 3D model file
(<code>Models/my-cessna.wrl</code>); however, if you want to be able
to reposition or animate the model, you need to point to an
intermediate XML file instead, and then put the repositioning and
animation information into the XML file.  Here's a simple example of a
3D-model wrapper file, with no repositioning or animation
information:</p>

<blockquote><pre>&lt;PropertyList&gt;
 &lt;path&gt;my-cessna.wrl&lt;/path&gt;
 &lt;texture-path&gt;./Textures&lt;/texture-path&gt;
&lt;/PropertyList&gt;
</pre></blockquote>

<p>Like the <var>-set.xml</var> files, this file is in XML property
list format, but the properties in it are not added to the main
FlightGear property tree; they're used only while loading the
model.  The following sections will explain how to add repositioning
and animation information to the file; for now, the only property to
worry about is <var>path</var>: it provides the relative path to the
actual 3D file from the XML wrapper file (<strong>not</strong> from
<var>FG_ROOT</var>!).  Usually, you should put the wrapper file in the
same directory as the 3D file, and then have
<var>/sim/model/path</var> point to the wrapper file, either on the
command line</p>

<blockquote><pre>fgfs --prop:/sim/model/path=Models/my-cessna.xml
</pre></blockquote>

<p>or in the <code>-set.xml</code> file:</p>

<blockquote><pre>&lt;PropertyList&gt;
 &lt;sim&gt;
  &lt;model&gt;
   &lt;path&gt;Models/my-cessna.xml&lt;/path&gt;
  &lt;/model&gt;
 &lt;/sim&gt;
&lt;/PropertyList&gt;
</pre></blockquote>

<!-- end of "Loading the model" -->
</div>


<div><a name="repositioning"></a>
<h3>2. Repositioning the Model</h3>

<p>Often, an aircraft model not designed specifically for FlightGear
will not be positioned or oriented correctly; for example, it might be
too far off the ground, and the nose might point to the side or even
straight up.</p>

<p>Inside the XML wrapper file (<em>not</em> the main FlightGear
property tree), there are six properties that allow you to tweak the
default position and orientation of the model:</p>

<dl compact ><dt><strong>/offsets/x-m</strong><dd>The distance to reposition the model along the 
        x-axis.<dt><strong>/offsets/y-m</strong><dd>The distance to reposition the model along the 
        y-axis.<dt><strong>/offsets/z-m</strong><dd>The distance to reposition the model along the 
        z-axis.<dt><strong>/offsets/heading-deg</strong><dd>The angle by which to rotate the model around 
        the z-axis.<dt><strong>/offsets/roll-deg</strong><dd>The angle by which to rotate the model around 
        the x-axis.<dt><strong>/offsets/pitch-deg</strong><dd>The angle by which to rotate the model around the y-axis.</dd></dl>

<p>For example, if you wanted to use the 3D model
<code>my-cessna.wrl</code> but found that the nose was pointing to the
right instead of straight-ahead and the wheels were 1.5 meters off the
ground, you could reorient it in the XML wrapper file like this:</p>

<blockquote><pre>&lt;PropertyList&gt;
 &lt;path&gt;Models/my-cessna.xml&lt;/path&gt;
 &lt;offsets&gt;
  &lt;heading-deg&gt;270&lt;/heading-deg&gt;
  &lt;z-m&gt;-1.5&lt;/z-m&gt;
 &lt;/offsets&gt;
&lt;/PropertyList&gt;
</pre></blockquote>

<p>It usually takes a bit of experimentation to get the model
positioned correctly.</p>

<!-- end of "Repositioning the Model" -->
</div>


<div><a name="animating"></a>
<h3>3. Animating the Model</h3>

<p>Now for the interesting part.  FlightGear allows you to animate
models by having parts rotate or spin in response to property changes:
for example, the propellers can spin when the engine is on and the
elevators can move up and down with your controller.  There is no
fixed limit on what parts can be animated: the only requirements are
that the part is named in the 3D model file, and that there is a
property in the main tree that you can use to get the positioning
information.</p>

<p>Currently, there are several types of animation recognized:</p>

<ol>
<li>none 
<li>billboard 
<li>rotate 
<li><a href="#scale">scale</a>
<li><a href="#blend">blend</a>
<li><a href="#select">select</a>
<li>spin 
<li>timed 
<li>translate 
<li><a href="#texrotate">texrotate</a>
<li><a href="#textranslate">textranslate</a>
<li><a href="#textmultiple">textmultiple</a>
<li><a href="#material">material</a>
<li><a href="#range">range</a>
<li><a href="#alphatest">alpha-test</a>
<li><a href="#noshadow">noshadow</a>
<li><a href="#dist-scale">dist-scale</a>
<li><a href="#flash">flash</a></li>
</ol>

<p>Typically you will use combinations of rotate, spin, and translate
to animate the main control surfaces for most standard-configuration
aircraft. <var>spin</var> rotates the
object around an axis with a known rotational velocity (not worrying
about the exact position), and <var>rotate</var> rotates the object
around an axis to an exact position.</p>

<p>Every animation appears inside an <var>animation</var> element, and
contains a <var>type</var> property and at least one
<var>object-name</var> property:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>It is possible to omit the <var>type</var> parameter. In this case,
the type is <var>none</var> and the animation is there only to group
objets under a single name that can be used in another animation located
farther in the file. Grouping objects in animations, with a <var>type</var>
or not, has the effect of reparenting the objects specified in <var>object-name</var>.
The rule is that the group is inserted between the first object and its parent, 
and then subsequent objects are removed from their original parent and added
to the new group.</p>

<p><var>none</var> animations are also handy to reorganise objects in a model. 
When objects are translucents, they should be drawn back to front in order to 
see the world that lies behind through the object. But the drawing order is often 
the order of appearance in the model file, and it is hard to control inside the 
modeler. This way, one can ignore the order in the modeler, and force the 
reordering at load time. The order is of course the order of appearance of
the <var>object-name</var> clause inside the animation. Be aware that this 
can be ruined by another subsequent animation (last have precedence over first).</p>

<p>The object name must match exactly the object name used in the 3D
file (including case).  You may include more than one object name to
apply the same transformation to more than one object, assuming that
they rotate around exactly the same line:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;LeftElevator&lt;/object-name&gt;
 &lt;object-name&gt;RightElevator&lt;/object-name&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>It is possible to omit the <var>type</var> parameter. In this case,
the type is <var>null</var> and the animation is there only to group
objets under a single name that can be used in another animation located
farther in the file. Grouping objects in animations, with a <var>type</var>
or not, has the effect of reparenting the objects specified in <var>object-name</var>.
The rule is that the group is inserted between the first object and its parent, 
and then subsequent objects are removed from their original parent and added
to the new group.</p>

<p>The resulting branch is solid when it comes to compute Height Over Terrain (HOT).
When an object is there to model a beam of light, or another non solid artefact, it 
can be interesting to ignore it for crash detection. It is done by inserting </p>
<blockquote><pre>&lt;enable-hot type="boolean"&gt;false&lt;/enable-hot&gt;</pre></blockquote>
<p>in the animation clause. By default, <var>enable-hot</var> is set to true and one
can land on the roof of a building.</p>

<p>Each animation must be associated with exactly one property from
the main FlightGear property tree (remember that the properties in the
wrapper file are not part of the main tree), using <var>property</var>
to provide the property name:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
 &lt;property&gt;controls/rudder&lt;/property&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>This example rotates the rudder according to the value of the
<var>/controls/rudder</var> property (or at least, it will when we
specify the center and axis of rotation below); however,
<var>/controls/rudder</var> is normalized from -1.0 to 1.0, and we
probably want to rotate the rudder more than that; as a result, we
need to use the <var>factor</var> property to do scaling.  For
example, if the rudder on the actual aircraft rotates 18 degrees in
each direction, we would use a factor of 18 to scale the rudder
position from -18 degrees to 18 degrees:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
 &lt;property&gt;controls/rudder&lt;/property&gt;
 &lt;factor&gt;18&lt;/factor&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>If you wanted to reverse the direction of rudder movement, you
would use a factor of -18.</p>

<p>There is also an <var>offset-deg</var> property that can be useful for
starting the rotation from a point other than center.  For example,
let's say that you want the rudder to start 1% to the left rather than
dead center; you could specify that like this:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
 &lt;property&gt;controls/rudder&lt;/property&gt;
 &lt;offset-deg&gt;-0.01&lt;/offset-deg&gt;
 &lt;factor&gt;18&lt;/factor&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>The offset is applied <em>after</em> the factor.</p>

<p>Finally, there are <var>min</var> and <var>max</var> properties
that can constrain the amount of rotation in degrees, as in this (very
complicated) example for the Cessna 310 landing gear:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;NoseWheel&lt;/object-name&gt;
 &lt;property&gt;gear/gear[0]/position-norm&lt;/property&gt;
 &lt;factor&gt;120&lt;/factor&gt;
 &lt;offset-deg&gt;-1&lt;/offset-deg&gt;
 &lt;min&gt;-90&lt;/min&gt;
 &lt;max&gt;0&lt;/max&gt;
 &lt;center&gt;
  &lt;x-m&gt;-2.28&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;-0.65&lt;/z-m&gt;
 &lt;/center&gt;
 &lt;axis&gt;
  &lt;x&gt;0&lt;/x&gt;
  &lt;y&gt;1&lt;/y&gt;
  &lt;z&gt;0&lt;/z&gt;
 &lt;/axis&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>In this example, the gear position (from 0.0 for fully retracted to
1.0 for fully extended) is multiplied by a factor of 120 and an offset
of -1, then clamped to between -90 and 0.  In the 3D model, the gear
is extended by default, so we end up with the following rotations
through the gear's range of movement:</p>

<table border="1">

<tbody><tr>
<th>position-norm</th>
<th>+ offset -1</th>
<th>* factor 120</th>
<th>clamped to min/max -90:0</th>
<th>comments</th>
</tr>

<tr>
<td>0.0</td>
<td>-1.0</td>
<td>-120.0</td>
<td>-90.0</td>
<td>fully retracted</td>
</tr>

<tr>
<td>0.25</td>
<td>-0.75</td>
<td>-90.0</td>
<td>-90.0</td>
<td>still retracted</td>
</tr>

<tr>
<td>0.5</td>
<td>-0.5</td>
<td>-60.0</td>
<td>-50.0</td>
<td>1/3 extended</td>
</tr>

<tr>
<td>0.75</td>
<td>-0.25</td>
<td>-30.0</td>
<td>-30.0</td>
<td>2/3 extended</td>
</tr>

<tr>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>fully extended (default position)</td>
</tr>

</tbody></table>

<p>The gear does not move at all during the first 1/4 of the
position-norm value, giving the doors a chance to open and close in a
separate animation.  Obviously, this would be easier to manage with an
interpolation table, and future versions of the model animation will
likely support interpolation.</p>

<p>Update: Interpolation tables our now supported.  Each table entry 
plots a dependency point and output values 
are interpolated in a linear manner between two points.  In the following 
example an input property value of 
25 will result in an application of a value 65 to the animation 
(65 degrees rotation maybe):</p>

<blockquote><pre> &lt;interpolation&gt;
   &lt;entry&gt;
    &lt;ind&gt;0&lt;/ind&gt;
    &lt;dep&gt;0&lt;/dep&gt;
   &lt;/entry&gt;
   &lt;entry&gt;
    &lt;ind&gt;16.67&lt;/ind&gt;
    &lt;dep&gt;60&lt;/dep&gt;
   &lt;/entry&gt;
   &lt;entry&gt;
    &lt;ind&gt;25&lt;/ind&gt;
    &lt;dep&gt;65&lt;/dep&gt;
   &lt;/entry&gt;
   &lt;entry&gt;
    &lt;ind&gt;33.3333&lt;/ind&gt;
    &lt;dep&gt;70&lt;/dep&gt;
   &lt;/entry&gt;
   &lt;entry&gt;
    &lt;ind&gt;66.6667&lt;/ind&gt;
    &lt;dep&gt;71&lt;/dep&gt;
   &lt;/entry&gt;
   &lt;entry&gt;
    &lt;ind&gt;100&lt;/ind&gt;
    &lt;dep&gt;75&lt;/dep&gt;
   &lt;/entry&gt;
  &lt;/interpolation&gt;
</pre></blockquote>

<p>For a <var>spin</var> animation, the property provides a value in
revolutions per minute (RPM) rather than an absolute position in
degrees, and offset is not used.  You can still use <var>factor</var>
to scale the property value if it is not in RPM.</p>

<p>Now, it is necessary to specify the axis of rotation for the
object, its virtual hinge.  This is often the hardest part, requiring
a lot of trial-and-error when the axis of rotation is not lined up
with the x-, y-, or z- axis (think of ailerons on a swept wing with a
non-zero dihedral angle).  You need to provide two groups of
information: a point through which the axis of rotation passes, and
the direction in which the axis is moving.</p>

<p>Update: there is now an alternate method for specifying axes 
that avoids the trial-and-error approach. See below after the Cessna 
172 animation examples.<p>
<p>For the point through which the axis passes, you use the
<var>/center/x-m</var>, <var>/center/y-m</var>, and
<var>/center/z-m</var> properties to specify a position in meters,
using the aircraft's coordinate system.  Note that this is the system
before repositioning: if the original model was pointing sideways,
then your fuselage will run along the y-axis rather than the
x-axis.  Here is an example for a rudder:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
 &lt;property&gt;controls/rudder&lt;/property&gt;
 &lt;factor&gt;18&lt;/factor&gt;
 &lt;center&gt;
  &lt;x-m&gt;5.45&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;0.0&lt;/z-m&gt;
 &lt;/center&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>In this example, the point is right on the y and z axes, but 5.45
meters along the x axis (i.e. towards the back of the plane).</p>

<p>Finally, in addition to the center point, it's necessary to specify
the direction of the axis that passes through it, using the properties
<var>/axis/x</var>, <var>/axis/y</var>, and <var>axis/z</var>.  These
are unitless values showing the rate of change in each direction; for
example, a straight up-and-down rotational axis could be specified
like this:</p>

<blockquote><pre>&lt;axis&gt;
 &lt;x&gt;0&lt;/x&gt;
 &lt;y&gt;0&lt;/y&gt;
 &lt;z&gt;1&lt;/z&gt;
&lt;/axis&gt;
</pre></blockquote>

<p>or like this:</p>

<blockquote><pre>&lt;axis&gt;
 &lt;x&gt;0&lt;/x&gt;
 &lt;y&gt;0&lt;/y&gt;
 &lt;z&gt;1000000&lt;/z&gt;
&lt;/axis&gt;
</pre></blockquote>

<p>Since there's 0 movement along the other two axes, it doesn't
matter.  On the other hand, let's say that the rudder hinge sloped
back 5% because of a swept tail.  In that case, the x-axis would have
to show some movement as well:</p>

<blockquote><pre>&lt;axis&gt;
 &lt;x&gt;0.05&lt;/x&gt;
 &lt;y&gt;0&lt;/y&gt;
 &lt;z&gt;1&lt;/z&gt;
&lt;/axis&gt;
</pre></blockquote>

<p>That could just as easily be written as</p>

<blockquote><pre>&lt;axis&gt;
 &lt;x&gt;1&lt;/x&gt;
 &lt;y&gt;0&lt;/y&gt;
 &lt;z&gt;20&lt;/z&gt;
&lt;/axis&gt;
</pre></blockquote>

<p>as long as the ratios are the same.  For a complicated rotation
axis, like that for an aileron on a swept-back wing with a significant
dihedral angle, you'll have to specify movement along all three
axes:</p>

<blockquote><pre>&lt;axis&gt;
 &lt;x&gt;0.15&lt;/x&gt;
 &lt;y&gt;1.00&lt;/y&gt;
 &lt;z&gt;0.01&lt;/z&gt;
&lt;/axis&gt;
</pre></blockquote>

<p>Here's a complete example, showing the animation for the rudder on
the Cessna 172:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;rotate&lt;/type&gt;
 &lt;object-name&gt;Rudder&lt;/object-name&gt;
 &lt;property&gt;controls/rudder&lt;/property&gt;
 &lt;factor&gt;18&lt;/factor&gt;
 &lt;center&gt;
  &lt;x-m&gt;5.45&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;0.0&lt;/z-m&gt;
 &lt;/center&gt;
 &lt;axis&gt;
  &lt;x&gt;0.72&lt;/x&gt;
  &lt;y&gt;0.0&lt;/y&gt;
  &lt;z&gt;1.0&lt;/z&gt;
 &lt;/axis&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>And here's an example of a spin, using the Cessna 172
propeller:</p>

<blockquote><pre>&lt;animation&gt;
 &lt;type&gt;spin&lt;/type&gt;
 &lt;object-name&gt;Propeller&lt;/object-name&gt;
 &lt;property&gt;engines/engine[0]/rpm&lt;/property&gt;
 &lt;center&gt;
  &lt;x-m&gt;0&lt;/x-m&gt;
  &lt;y-m&gt;0&lt;/y-m&gt;
  &lt;z-m&gt;-.25&lt;/z-m&gt;
 &lt;/center&gt;
 &lt;axis&gt;
  &lt;x&gt;1.0&lt;/x&gt;
  &lt;y&gt;0.0&lt;/y&gt;
  &lt;z&gt;0.0&lt;/z&gt;
 &lt;/axis&gt;
&lt;/animation&gt;
</pre></blockquote>

<p>There is an alternate method of specifying the axis that can often be find much easier.  
This method is particularly
helpful for rotating on axes that are at odd angles, such as ailerons on dihedral swept 
wings.</p>

<p>It is not necessary to specify a &lt;center&gt; tag for this method as it will be calculated 
automatically.  The &lt;axis&gt; tag requres two sets of coordinates (x1-m,y1-m,z1-m and 
x2-m,y2-m,z2-m), one for each end of the axis.
With an aileron, for example, you would need to specify coordinates from both the right and left
corner of the aileron along the hinged edge.  If your object rotates in the direction opposite 
of what you intended you may correct it by simply swapping the two sets of coordinate values (swap x1 
and x2, y1 and y2, z1 and z2).</p>

<p>Here is an example from the 747-400:</p>

<blockquote><pre>&lt;animation&gt;
  &lt;type&gt;rotate&lt;/type&gt;
  &lt;object-name&gt;AileronLeftOuter&lt;/object-name&gt;
  &lt;property&gt;surface-positions/left-aileron-pos-norm&lt;/property&gt;
  &lt;factor&gt;-30&lt;/factor&gt;
  &lt;axis&gt;
   &lt;x1-m&gt;18.28&lt;/x1-m&gt;
   &lt;y1-m&gt;-21.55&lt;/y1-m&gt;
   &lt;z1-m&gt;-0.37&lt;/z1-m&gt;
   &lt;x2-m&gt;22.51&lt;/x2-m&gt;
   &lt;y2-m&gt;-28.37&lt;/y2-m&gt;
   &lt;z2-m&gt;0.08&lt;/z2-m&gt;
  &lt;/axis&gt;
 &lt;/animation&gt;
</pre></blockquote>

<p>You can get a lot of your initial measurements by viewing the model
in a 3D editor like <a href="http://prettypoly.sourceforge.net/">PPE</a>, and you can also
use PPE to name or rename objects so that you can animate them in
FlightGear.  In the end, though, you'll almost have to do a little
tweaking by trial and error until everything looks right.</p>

<p>This document will likely be out of date by the time you read it.
Look at the actual XML wrapper files (currently in
<code>$FG_ROOT/Aircraft/<em>aircraft-type</em>/Models/</code>) to look
at how FlightGear is doing things now.  In the future, we'll be adding
other animation types, including selecting among different versions of
the same object (such as a translucent propeller disk for high RPM),
non-rotational transformations, scaling, and conditionals (i.e. draw
engine exhaust only above a certain velocity).</p>

<p>It is often desired to apply several animations on the same object. 
It is simply done by specifying multiple animations with the same 
<var>object-name</var>. But you must be aware of the order of execution of
these specified animations. Every new animation takes precedence over previously 
declared one. As we already seen, each new animation is inserted as the parent 
of the object specified as the first <var>object-name</var>. That means that if
a rotation is already declared, and a new translation is to be inserted, it will 
be between the rotation and the object, making the translation acting on the 
object, and the rotation acting on the translated object.<br>
So, as a rule of thumb, remember that animations are executed from the 
bottom of the animation file to its top.</p>

<p>Most animations can be conditioned by a boolean expression on 
properties. A condition is introduced by the <var>condition</var> element, 
like in this example&nbsp;:</p>
<blockquote><pre> &lt;condition&gt;
   &lt;greater-than&gt;
    &lt;property&gt;sim/time/sun-angle-rad&lt;/property&gt;
    &lt;value&gt;1.57&lt;/value&gt;
   &lt;/greater-than&gt;
  &lt;/condition&gt;</pre></blockquote>
<p>Valid condition elements are&nbsp;:</p>
<blockquote><dl>
 <dt><var>property</var></dt>
  <dd>A valid property full path</dd>
 <dt><var>not</var></dt>
 <dt><var>and</var></dt>
 <dt><var>or</var></dt>
  <dd>Boolean operators</dd>
 <dt><var>less-than</var></dt>
 <dt><var>less-than-equals</var></dt>
 <dt><var>greater-than</var></dt>
 <dt><var>greater-than-equals</var></dt>
 <dt><var>equals</var></dt>
 <dt><var>not-equals</var></dt>
  <dd>Comparison operators</dd>
 <dt><var>value</var></dt>
  <dd>A literal value</dd>
</dl></blockquote>
<p>These elements can be combined to build an arbitrary expression.</p>
<p>Animations without conditions are always executed. Animation with a condition
are only executed when the condition evaluated to <var>true</var>.</p>

<p>FlightGear sceneries use shared models. These models are loaded once and
displayed multiple times. If we apply a transformation on an object of the model,
every occurence of the model will show the same transformation, creating a 
very unnatural unison. To solve this kind of problem, several animations 
support the notion of personality. It means that a set of parameters are able
to randomly vary in a specified range if the <var>use-personality</var> boolean
property is set to <var>true</var>. For the moment, <var>spin</var> and <var>timed</var>
animations support personality.</p>

<h3><a name="select">"select" animation type</a></h3>

<p>The select animation is there to remove objects ( specified in the <var>object-name</var> 
elements ) from the scene when the associated condition evaluated to <var>false</var>.</p>
<p>In the example below&nbsp;:</p>
<blockquote><pre> &lt;animation&gt;
  &lt;type&gt;select&lt;/type&gt;
  &lt;object-name&gt;StrobesOn&lt;/object-name&gt;
  &lt;object-name&gt;StrobesOff&lt;/object-name&gt;
  &lt;object-name&gt;Fixed&lt;/object-name&gt;
  &lt;condition&gt;
   &lt;greater-than&gt;
    &lt;property&gt;sim/time/sun-angle-rad&lt;/property&gt;
    &lt;value&gt;1.57&lt;/value&gt;
   &lt;/greater-than&gt;
  &lt;/condition&gt;
 &lt;/animation&gt;</pre></blockquote>
 <p>Objects <var>StrobesOn</var>, <var>StrobesOff</var> and <var>Fixed</var> are only present
 in the scene ( displayed ) when the sun is below the horizon ( the meaning of the condition).
 In other words, these objects, that are already in the scene because they were added by the
 designer of the model, are removed when the sun is above the horizon.</p>

<h3><a name="timed">"timed" animation type</a></h3>

<p>The timed animation selects only one object among those specified by <var>object-name</var>
for a specified duration. When the displayed time ends, the next object is selected for the 
matching duration.</p>
<p>The simpler form is&nbsp;:</p>
<blockquote><pre> &lt;animation&gt;
  &lt;name&gt;BeaconFlasher&lt;/name&gt;
  &lt;type&gt;timed&lt;/type&gt;
  &lt;object-name&gt;BeaconOff&lt;/object-name&gt;
  &lt;object-name&gt;BeaconOn&lt;/object-name&gt;
  &lt;duration-sec&gt;1.0&lt;/duration-sec&gt;
 &lt;/animation&gt;</pre></blockquote>
<p>In this example, each object is displayed during an equal time, specified in seconds.</p>
<p>This second example use personality&nbsp;:</p>
<blockquote><pre> &lt;animation&gt;
  &lt;type&gt;timed&lt;/type&gt;
  &lt;object-name&gt;StrobesOn&lt;/object-name&gt;
  &lt;object-name&gt;StrobesOff&lt;/object-name&gt;
  &lt;use-personality type="bool"&gt;true&lt;/use-personality&gt;
  &lt;branch-duration-sec&gt;
   &lt;random&gt;
    &lt;min&gt;0.9&lt;/min&gt;
    &lt;max&gt;1.1&lt;/max&gt;
   &lt;/random&gt;
  &lt;/branch-duration-sec&gt;
  &lt;branch-duration-sec&gt;
   &lt;random&gt;
    &lt;min&gt;0.9&lt;/min&gt;
    &lt;max&gt;1.1&lt;/max&gt;
   &lt;/random&gt;
  &lt;/branch-duration-sec&gt;
 &lt;/animation&gt;</pre></blockquote>
<p>In this case, there is a <var>branch-duration-sec</var> element for each 
<var>object-name</var> that specify a duration for that object. The value of
<var>branch-duration-sec</var> could be a literal double value in seconds.<br>
Here, literals have been replaced by the <var>random</var> element. It means
that the duration is choosen randomly between <var>min</var> and <var>max</var>.
Because of the <var>use-personality</var> element set to true, durations are 
allowed to be different for each occurence of this model, breaking the announced 
unison.</p>

<h3><a name="scale">"scale" animation type</a></h3>

<p>Here is a contrived example of one way to use the "scale" animation
type.  In this case a shadow map is placed below the aircraft and we
can control the size based on some property value (i.e. alitutude
above the ground.)  In real life, the shadow size should stay pretty
much fixed, so this technique might ultimately be more useful for a
landing light.</p>

<blockquote><pre> &lt;animation&gt;
  &lt;type&gt;scale&lt;/type&gt;
  &lt;object-name&gt;ShadowMap&lt;/object-name&gt;
  &lt;property&gt;position/altitude-agl-ft&lt;/property&gt;
  &lt;x-factor&gt;0.05&lt;/x-factor&gt;
  &lt;x-offset&gt;1.0&lt;/x-offset&gt;
  &lt;y-factor&gt;0.05&lt;/y-factor&gt;
  &lt;y-offset&gt;1.0&lt;/y-offset&gt;
  &lt;z-factor&gt;0.0&lt;/z-factor&gt;
  &lt;z-offset&gt;1.0&lt;/z-offset&gt;
  &lt;center&gt;
   &lt;x-m&gt;0.05&lt;/x-m&gt;
   &lt;y-m&gt;0.05&lt;/y-m&gt;
   &lt;z-m&gt;0.0&lt;/z-m&gt;
  &lt;/center&gt;
 &lt;/animation&gt;
</pre></blockquote>

<p>As with the other animations, you need to specify an object-name and
the property that will drive this animation.  And, as with other types
of transform animations, the order they are applied is important.  For
a given object, you will probably want to put the scaling animation
after any other translate or rotate animations.</p>

<p>You have some individual control over the X, Y, and Z axis scaling.
For each dimension you can provide factors (x-factor, y-factor, and
z-factor) and also offsets (x-offset, y-offset, and z-offset.)  You
can also specify minimum values (x-min, y-min, z-min) and maximum
values (x-max, y-max, and z-max) for scaling results.</p>

<p>You can set the center of scaling with the center tag. The center is
that point that does not ever change its position under any scaling.
If unset this defaults to the (0, 0, 0).</p>

<p>The amount of scaling for each dimension is computed by the
following formula (and then clamped if a min or max value is
specified.)</p>

<blockquote><pre>  scale = property * factor + offset
</pre></blockquote>

<p>Specifying a factor of 0.0 and an offset of 1.0 is equivalent to no
scaling at all.</p>

<p>As you can see in the above example, at ground level (the property
value = 0.0) the scaling formula will evaluate to 1.0 (no scaling.)
As altitude above the ground increases, the scaling factor will
increase by agl * 0.05 + 1.0.  Note that because a shadow has no depth
we use a z-factor of 0.0 and a z-offset of 1.0 so the formula always
evalutes to a scaling factor of 1.0 in the Z dimension.</p>

<h3><a name="blend">"blend" animation type</a></h3>

<p>The blend animation type can be used to adjust the transparency of
an object. To controll it's behavior it is possible to define:</p><p>

<table>
 <tbody><tr>
  <td><b>property</b></td>
  <td><i>use the value of this property in the calculation</i></td>
 </tr>
 <tr>
  <td><b>offset</b></td>
  <td><i>offset, ranges from 0.0 to 1.0</i></td>
 </tr>
 <tr>
  <td><b>factor</b></td>
  <td><i>multiplication factor for the property</i></td>
 </tr>
</tbody></table>

</p><p>The formula used is:
</p><blockquote><pre>alpha = property * factor + offset
</pre></blockquote>

<p>The result should be between 0.0 and 1.0 where 0.0 equals to a fully visible model and 1.0 equals to a fully transparent model.</p>

<p>To gain greater controll over the result it is possible to limit
the result by defining a &lt;min&gt; and/or a &lt;max&gt; parameter.
</p>

<p><strong>Note:</strong> This 
      effect will only work if there is already a transparent component in the 
      object, either in the vertex color or in the texture.
<!-- end of "Animating the Model" -->


<h3><a name="texrotate">"texrotate" texture rotation animation type</a></h3>

<p>This animation will adjust the texture mapping on an object 
so that the texture image appears to rotate about 
the specified center on the object.  Note that when talking 
about texture mapping,  meaningful values are from 
0.0 ~ 1.0.  Texture coordinates are commonly specified as (u,v).  
A square object's lower left corner would generally be 
specified as (u=0,v=0) and the upper right corner as (u=1,v=1).  The 
center will be (u=0.5, v=0.5).  These values
will be vary (within the 0.0 ~ 1.0 range) if only a portion of a texture is 
mapped (see compass rose example below).</p>
  
<p>For the purpose of specifying the &lt;center&gt; tag 
you need only use the x and y coordinates.  
The &lt;axis&gt; tag usually only requires a value for z.  It is possible to 
obtain some unusual texture mapping effects, like as giving the illusion of 
perspective on a flat stationary surface by using the other axes.  Here is 
an example of a rotating compass rose on the 747-400 PDF 
(primary flight display):<p>

<blockquote><pre> &lt;animation&gt;
  &lt;type&gt;texrotate&lt;/type&gt;
  &lt;object-name&gt;rose&lt;/object-name&gt;
  &lt;property&gt;orientation/heading-magnetic-deg&lt;/property&gt;
  &lt;center&gt;
   &lt;x&gt;0.75&lt;/x&gt;
   &lt;y&gt;0.75&lt;/y&gt;
   &lt;z&gt;0.0&lt;/z&gt;
  &lt;/center&gt;
  &lt;axis&gt;
   &lt;x&gt;0&lt;/x&gt;
   &lt;y&gt;0&lt;/y&gt;
   &lt;z&gt;-1&lt;/z&gt;
  &lt;/axis&gt;
 &lt;/animation&gt;
</pre></blockquote>

<p>The center in this example is (0.75, 0.75) because the compass 
rose only occupies the upper right corner of the total 
texture image that it is contained in.  The other three quardrants 
have other textures for the same model.   As mentioned 
before, the coordinates are (0,0) lower left to (1,1) upper right,  
the center of the upper right quadrant is thus (0.75, 0.75).

<h3><a name="textranslate">"textranslate" texture translation animation type</a></h3>

<p>This animation will adjust the texture mapping on an object so 
that the texture image appears to slides around 
on the object.  An &lt;axis&gt; tag is required to specify the axis 
along which the texture is moved (the direction of movement).  The 
following example displays the right most digit in the altitude indicator 
on the primary flight display:</p>

 <blockquote><pre> &lt;animation&gt;
  &lt;type&gt;textranslate&lt;/type&gt;
  &lt;object-name&gt;alt1&lt;/object-name&gt;
  &lt;property&gt;position/altitude-ft&lt;/property&gt;
  &lt;factor&gt;0.01&lt;/factor&gt;
  &lt;axis&gt;
   &lt;x&gt;0&lt;/x&gt;
   &lt;y&gt;1&lt;/y&gt;
   &lt;z&gt;0&lt;/z&gt;
  &lt;/axis&gt;
 &lt;/animation&gt;
</pre></blockquote>

<p>There are also some special properties available for use in the texture animations.  These are:</p>

<ol>
<li>step</li>
<li>scroll</li>
<li>bias</li>
</ol>

<p>The &lt;step&gt; tag is useful if you want animations to 
happen in steps rather than smoothly.  It causes values that are 
fractional (between) steps size to be ingnored.  It can be used for 
things like changing digits on nurmeric displays or a ticking second 
hand on a clock.  The &lt;scroll&gt; tag works with the
 &lt;step&gt; tag.  The scroll value specifies the distance the input 
property value should be from a step when scrolling to the next 
position begins.  This type of scrolling is common on EFIS cockpit 
displays. The following example gives an "odometer effect" 
where the hundreds position digit doesn't move until the input value 
is within is within 1 (e.g. &gt; 99):</p>

 <blockquote><pre>&lt;animation&gt;
  &lt;type&gt;textranslate&lt;/type&gt;
  &lt;object-name&gt;asi3&lt;/object-name&gt;
  &lt;property&gt;velocities/airspeed-kt&lt;/property&gt;
  &lt;factor&gt;0.001&lt;/factor&gt;
  &lt;step&gt;100&lt;/step&gt;
  &lt;scroll&gt;1&lt;/scroll&gt;
  &lt;axis&gt;
   &lt;x&gt;0&lt;/x&gt;
   &lt;y&gt;1&lt;/y&gt;
   &lt;z&gt;0&lt;/z&gt;
  &lt;/axis&gt;
 &lt;/animation&gt;
</pre></blockquote>

<p>The &lt;bias&gt; tag was added because the normal tags for adjusting properties, &lt;offset&gt; and
&lt;factor&gt; are applied after the &lt;step&gt; tag.  The &lt;bias&gt; tag allows you to apply an
offset before the &lt;step&gt; tag and, for example, fix the a radio frequency to display correctly.</p>

 <blockquote><pre>&lt;animation&gt;
  &lt;type&gt;textranslate&lt;/type&gt;
  &lt;object-name&gt;comm-digit1&lt;/object-name&gt;
  &lt;property&gt;instrumentation/comm/frequencies/standby-mhz&lt;/property&gt;
  &lt;factor&gt;10.0&lt;/factor&gt;
  &lt;step&gt;0.01&lt;/step&gt;
  &lt;bias&gt;0.005&lt;/bias&gt;
  &lt;axis&gt;
   &lt;x&gt;0&lt;/x&gt;
   &lt;y&gt;1&lt;/y&gt;
   &lt;z&gt;0&lt;/z&gt;
  &lt;/axis&gt;
 &lt;/animation&gt;
</pre></blockquote>

<h3><a name="textmultiple">"textmultiple" type, combining texture animation types</a></h3>

<p>The textmultiple animation type isn't a real animation type, but 
instead it is a method of combining multiple texture 
tansform operations on the same object.  Unlike object vertex 
operations, texture operations can not be stacked,
which means that if you configure two or more texture animation tags 
on the same object, only the first in the list will be used.   By 
listing operations using texmultiple they are combined together in 
Simgear and then handled as a single operation.</p>

<p>If you need to combine together a translation and rotation 
this is the only way to do it currently.  Note that 
transform operations are applied in the same order that they are 
listed in the configuration file.  The following  
example for the horizon texture from the 747-400 primary flight 
display explains the format clearly:</p>

<blockquote><pre>&lt;animation&gt;
  &lt;type&gt;texmultiple&lt;/type&gt;
  &lt;object-name&gt;horizon&lt;/object-name&gt;
  &lt;transform&gt;
    &lt;property&gt;orientation/pitch-deg&lt;/property&gt;
    &lt;subtype&gt;textranslate&lt;/subtype&gt;
    &lt;factor&gt;0.0045&lt;/factor&gt;
    &lt;axis&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;1&lt;/y&gt;
     &lt;z&gt;0&lt;/z&gt;
   &lt;/axis&gt;
  &lt;/transform&gt;
  &lt;transform&gt;
    &lt;property&gt;orientation/roll-deg&lt;/property&gt;
    &lt;subtype&gt;texrotate&lt;/subtype&gt;
    &lt;center&gt;
     &lt;x&gt;0.50&lt;/x&gt;
     &lt;y&gt;0.50&lt;/y&gt;
   &lt;/center&gt;
    &lt;axis&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;z&gt;-1&lt;/z&gt;
   &lt;/axis&gt;
  &lt;/transform&gt;
 &lt;/animation&gt;
</pre></blockquote>
<h3><a name="range">"range" animation type</a></h3>
<p>The range type is used to select part of a model using its distance from the
 viewer as the criterion. To be viewed, the model must be between a minimum
 distance and a maximum one. Minimum distance can be specified either with the
 &lt;min-m&gt; element or the &lt;min-property&gt; element that are exclusive.
 The first one allow to specify a fixed distance in meters, the latter allow to
 lookup the value from a property. Both can be multiplied by a fixed amount,
 specified in the &lt;min-factor&gt; element. The same apply for the maximum
 value with &lt;max-m&gt;, &lt;max-property&gt; and &lt;max-factor&gt; elements.
 The example below shows how it can be used :</p>
 <blockquote>
  <pre>&lt;animation&gt;
  &lt;type&gt;range&lt;/type&gt;
  &lt;object-name&gt;Detailed&lt;/object-name&gt;
  &lt;min-m&gt;0&lt;/min-m&gt;
  &lt;max-property&gt;/sim/rendering/static-lod/detailed&lt;/max-property&gt;
&lt;/animation&gt;
  </pre>
 </blockquote>
 <h3><a name="alphatest">"alpha-test" animation type</a></h3>
<p>This "animation" is a way to set an alpha test on a model branch. The effect
 is to avoid depth buffer writing of pixel that are not seen because they are
 transparent. This is particulary useful when modeling a metallic structure or a
 tree with a billboard. The threshold of transparency is set with the
 &lt;alpha-factor&gt; element like this :</p>
 <blockquote>
  <pre>&lt;animation&gt;
  &lt;type&gt;alpha-test&lt;/type&gt;
  &lt;object-name&gt;Detailed&lt;/object-name&gt;
  &lt;alpha-factor&gt;0.01&lt;/alpha-factor&gt;
&lt;/animation&gt;
  </pre>
 </blockquote>

 <h3><a name="noshadow">"noshadow" animation type</a></h3>
 <p>This "animation" prevents the shadow casting code to include this object,
  which might be handy when it doesn't cast a shadow (exhaust flame) or when
  it looks ugly.</p>
  <blockquote>
   <pre>&lt;animation&gt;
 &lt;type&gt;noshadow&lt;/type&gt;
 &lt;object-name&gt;Wires.1&lt;/object-name&gt;
 &lt;object-name&gt;Wires.2&lt;/object-name&gt;
&lt;/animation&gt;
   </pre>
  </blockquote>

 <h3><a name="dist-scale">"dist-scale" animation type</h3>
 <p>This animation enables to scale an object based on the distance of its 
 center to the viewer. It was designed to compensate the effect of fog on 
 emissive (light) sources that is too strong ( lights are hardly visible at distance )<br>
 Parameters, with default values, are :</p>
  <blockquote>
   <pre>&lt;animation&gt;
 &lt;type&gt;dist-scale&lt;/type&gt;
 &lt;object-name&gt;RedLight.11&lt;/object-name&gt;
 &lt;factor&gt;1.0&lt;/factor&gt;
 &lt;offset&gt;0.0&lt;/offset&gt;
 &lt;min&gt;0.0&lt;/min&gt;
 &lt;max&gt;1.0&lt;/max&gt;
 &lt;center&gt;
  &lt;x-m&gt;0.0&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;0.0&lt;/z-m&gt;
 &lt;/center&gt;
&lt;/animation&gt;
   </pre>
  </blockquote>
<p>Or, with an interpolation table :</p>
  <blockquote>
   <pre>&lt;animation&gt;
 &lt;type&gt;dist-scale&lt;/type&gt;
 &lt;object-name&gt;RedLight.11&lt;/object-name&gt;
 &lt;interpolation&gt;
  &lt;entry&gt;&lt;ind&gt;0&lt;/ind&gt;&lt;dep&gt;0.1&lt;/dep&gt;&lt;/entry&gt;
  &lt;entry&gt;&lt;ind&gt;500&lt;/ind&gt;&lt;dep&gt;0.2&lt;/dep&gt;&lt;/entry&gt;
  &lt;entry&gt;&lt;ind&gt;16000&lt;/ind&gt;&lt;dep&gt;3&lt;/dep&gt;&lt;/entry&gt;
 &lt;/interpolation&gt;
 &lt;min&gt;0.0&lt;/min&gt;
 &lt;max&gt;3.0&lt;/max&gt;
 &lt;center&gt;
  &lt;x-m&gt;0.0&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;0.0&lt;/z-m&gt;
 &lt;/center&gt;
&lt;/animation&gt;
   </pre>
  </blockquote>

 <h3><a name="flash">"flash" animation type</h3>
 <p>This animation was designed to scale an object based on the angle between 
 an arbitrary axis and the axis that goes between the viewer and the center of 
 the object. The sought effect was the <i>flash</i> of a lighthouse or beacon, 
 or whatever intense narrow light beam, hence the name.<br>
 Parameters, with default values, are :</p>
  <blockquote>
   <pre>&lt;animation&gt;
 &lt;type&gt;flash&lt;/type&gt;
 &lt;object-name&gt;WhiteFlash.2&lt;/object-name&gt;
 &lt;offset&gt;0.0&lt;/offset&gt;
 &lt;factor&gt;1.0&lt;/factor&gt;
 &lt;power&gt;1.0&lt;/power&gt;
 &lt;two-sides type="boolean"&gt;false&lt;/two-sides&gt;
 &lt;min&gt;0.0&lt;/min&gt;
 &lt;max&gt;1.0&lt;/max&gt;
 &lt;center&gt;
  &lt;x-m&gt;0.0&lt;/x-m&gt;
  &lt;y-m&gt;0.0&lt;/y-m&gt;
  &lt;z-m&gt;0.0&lt;/z-m&gt;
 &lt;/center&gt;
 &lt;axis&gt;
  &lt;x&gt;0.0&lt;/x&gt;
  &lt;y&gt;0.0&lt;/y&gt;
  &lt;z&gt;1.0&lt;/z&gt;
 &lt;/axis&gt;
&lt;/animation&gt;
   </pre>
  </blockquote>
 <p>The scale formulae is :<br>
 <center>S = factor * pow( cos_angle, power ) + offset</center><br>
 cos_angle being the cosine of the angle between the axis and the line 
 between the center and the viewer.<br>
 The value S is clamped between min and max.<br>
 No interpolation table is allowed in this animation.
 </p>

 <h3><a name="material">"material" animation type</a></h3>
<p>This "animation" can set any of the material properties on a model branch, including
the texture file path. The following minimalistic example animation allows to change the
"panel" object's emissive color from (0,0,0) to (1,.2,0) by setting the factor property
to values between 0.0 and 1.0.</p>

 <blockquote>
  <pre>&lt;animation&gt;
  &lt;type&gt;material&lt;/type&gt;
  &lt;object-name&gt;panel&lt;/object-name&gt;
  &lt;emission&gt;
    &lt;red&gt;1.0&lt;/red&gt;
    &lt;green&gt;0.2&lt;/green&gt;
    &lt;blue&gt;0.0&lt;/blue&gt;
    &lt;factor-prop&gt;/controls/lighting/instruments-norm&lt;/factor-prop&gt;
  &lt;/emission&gt;
&lt;/animation&gt;
  </pre>
 </blockquote>


<p>Changes made with this animation type are by default only effective for the objects listed in
&lt;object-name&gt; tags, whereby you can use more than one of those. The next example, however,
sets the optional &lt;global&gt; property, so that changes affect all objects that share
the same material. This is the preferred method and should be used whereever possible. It isn't
only faster, but also doesn't break other animations by forcing objects into the same branch.
Note that all material properties can be set to fixed values, for instance &lt;red&gt; or, by appending
"-prop", to the contents of another property node: &lt;red-prop&gt;. Because a "material" animation
can contain a lot of such property paths, which is a nuisance to write, hard to read, and a potential
source for typos, there's a &lt;property-base&gt; component. Its string value is prepended to
all material property names (but not to property paths in a &lt;condition&gt; statement!).
The following example shows all available elements:</p>

 <blockquote>
  <pre>&lt;animation&gt;
  &lt;type&gt;material&lt;/type&gt;
  &lt;object-name&gt;fuselage&lt;/object-name&gt;
  &lt;condition&gt;
    &lt;property&gt;sim/model/foo/animate-fuselage-material&lt;/property&gt;
  &lt;/condition&gt;
  &lt;global type="bool"&gt;true&lt;/global&gt;
  &lt;property-base&gt;/sim/model/foo/material/fuselage&lt;/property-base&gt;
  &lt;diffuse&gt;
    &lt;red-prop&gt;diffuse/red&lt;/red-prop&gt;
    &lt;green-prop&gt;diffuse/green&lt;/green-prop&gt;
    &lt;blue-prop&gt;diffuse/blue&lt;/blue-prop&gt;
    &lt;factor-prop&gt;diffuse/factor&lt;/factor-prop&gt;
    &lt;offset-prop&gt;diffuse/offset&lt;/offset-prop&gt;
  &lt;/diffuse&gt;
  &lt;ambient&gt;
    &lt;red-prop&gt;ambient/red&lt;/red-prop&gt;
    &lt;green-prop&gt;ambient/green&lt;/green-prop&gt;
    &lt;blue-prop&gt;ambient/blue&lt;/blue-prop&gt;
    &lt;factor-prop&gt;ambient/factor&lt;/factor-prop&gt;
    &lt;offset-prop&gt;ambient/offset&lt;/offset-prop&gt;
  &lt;/ambient&gt;
  &lt;emission&gt;
    &lt;red-prop&gt;emission/red&lt;/red-prop&gt;
    &lt;green-prop&gt;emission/green&lt;/green-prop&gt;
    &lt;blue-prop&gt;emission/blue&lt;/blue-prop&gt;
    &lt;factor-prop&gt;emission/factor&lt;/factor-prop&gt;
    &lt;offset-prop&gt;emission/offset&lt;/offset-prop&gt;
  &lt;/emission&gt;
  &lt;specular&gt;
    &lt;red-prop&gt;specular/red&lt;/red-prop&gt;
    &lt;green-prop&gt;specular/green&lt;/green-prop&gt;
    &lt;blue-prop&gt;specular/blue&lt;/blue-prop&gt;
    &lt;factor-prop&gt;specular/factor&lt;/factor-prop&gt;
    &lt;offset-prop&gt;specular/offset&lt;/offset-prop&gt;
  &lt;/specular&gt;
  &lt;shininess&gt;
  &lt;transparency&gt;
    &lt;alpha-prop&gt;transparency/alpha&lt;/alpha-prop&gt;
    &lt;factor-prop&gt;transparency/factor&lt;/factor-prop&gt;
    &lt;offset-prop&gt;transparency/offset&lt;/offset-prop&gt;
    &lt;min&gt;0.0&lt;min&gt;  &lt;!-- no min-prop! --&gt;
    &lt;max&gt;1.0&lt;max&gt;  &lt;!-- no max-prop! --&gt;
  &lt;/transparency&gt;
  &lt;texture&gt;texture&lt;/texture&gt;
  &lt;threshold&gt;threshold&lt;/threshold&gt;
&lt;/animation&gt;
  </pre>
 </blockquote>

<p>A change to one of the components in each color group does always update
all three color components. Unset values default to zero. The &lt;texture&gt; path
is relative to the model's &lt;texture-path&gt; directory, or, if unset, to the model
directory. All numerical values are clamped to 0.0-1.0, except &lt;shininess&gt;, which is
clamped to 0.0-128.0. The &lt;alpha&gt; property (&lt;transparency&gt; group) makes an
object fully transparent (and thus invisible) with 0.0, and fully opaque with 1.0.
("alpha" could also be called "opaqueness".) The &lt;threshold&gt; property sets the
alpha/opaqueness threshold. It is only relevant for semitransparent textures. Only parts
of the texture that are more opaque than this are diplayed at all. If it is set
to 0.0, all parts of the texture will be shown. If it is 0.5, only parts with
opaqueness greater than 0.5 (or transparency less than 0.5) are shown.</p>

<p>Note that defining two or more of these animations for the same object,
or a mixture of "material" and "blend" animations, will probably not yield
the result that you expect. Try to put all state manipulations for one
object or material in one "material" animation, and use its "transparency"
property instead of an extra "blend" animation.</p>

<p>To make a texture replaceable at runtime, use a "material" animation
like this:</p>

 <blockquote>
  <pre>&lt;animation&gt;
  &lt;type&gt;material&lt;/type&gt;
  &lt;object-name&gt;tail-vert&lt;/object-name&gt;
  &lt;texture-prop&gt;/sim/model/foo/texture&lt;/texture-prop&gt;
&lt;/animation&gt;
  </pre>
 </blockquote>

<p>and put something like this into your aircraft's *-set.xml file:</p>

 <blockquote>
  <pre>&lt;sim&gt;
  &lt;model&gt;
    &lt;foo&gt;
      &lt;texture&gt;logos/tail-logo.rgb&lt;/texture&gt;
    &lt;/foo&gt;
  &lt;/model&gt;
&lt;/sim&gt;
  </pre>
 </blockquote>


<p>You can explore the influence of material changes at runtime, if you use
a material animation like the above complete example, and call the material
dialog on it, like in the following Nasal example. Note, that the path is
the same that you would set in &lt;property-base&gt;.
</p>

 <blockquote>
  <pre>material.showDialog("/sim/model/foo/material/fuselage");</pre>
 </blockquote>

 <h3><a name="pick">"pick" animation type</h3>
 <p>This animation type is used to execute a command binding when the mouse
 is pressed on this particular object. The Commands are the usual bindings
 like used elsewhere in flightgear.
 <p>The visible property tells if the object should be visible as is. Setting
 that to false make sense if you have small buttons on the instrument model
 but you want to have huge active areas for interaction. It defaults to true.
  <blockquote>
   <pre>&lt;animation&gt;
  &lt;type&gt;pick&lt;/type&gt;
  &lt;object-name&gt;Button&lt;/object-name&gt;
  &lt;visible&gt;true&lt;/visible&gt;
  &lt;action&gt;
    &lt;button&gt;0&lt;/button&gt;
    &lt;repeatable&gt;true&lt;/repeatable&gt;
    &lt;interval-sec&gt;0.1&lt;/interval-sec&gt;
    &lt;binding&gt;
      &lt;command&gt;property-assign&lt;/command&gt;
      &lt;property&gt;instrumentation/button0-pressed&lt;/property&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/binding&gt;
    &lt;mod-up&gt;
      &lt;binding&gt;
        &lt;command&gt;property-assign&lt;/command&gt;
        &lt;property&gt;instrumentation/button0-pressed&lt;/property&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/binding&gt;
    &lt;/mod-up&gt;
  &lt;/action&gt;
  &lt;action&gt;
    &lt;button&gt;1&lt;/button&gt;
    &lt;repeatable&gt;true&lt;/repeatable&gt;
    &lt;interval-sec&gt;0.1&lt;/interval-sec&gt;
    &lt;binding&gt;
      &lt;command&gt;property-assign&lt;/command&gt;
      &lt;property&gt;instrumentation/button1-pressed&lt;/property&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/binding&gt;
    &lt;mod-up&gt;
      &lt;binding&gt;
        &lt;command&gt;property-assign&lt;/command&gt;
        &lt;property&gt;instrumentation/button1-pressed&lt;/property&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/binding&gt;
    &lt;/mod-up&gt;
  &lt;/action&gt;
&lt;/animation&gt;</pre>
  </blockquote>
 </p>

<hr>
<address>David Megginson, 11 March 2002</address>
<address>Mathias Fr&ouml;hlich, 3 Jan 2007</address>

<!-- Standard Footer Begin --></div>
      </td></tr>
    </tbody>
  </table>
  <br>
</body>

</html>

<!-- Standard Footer End -->

--- End of model-howto.html ---

